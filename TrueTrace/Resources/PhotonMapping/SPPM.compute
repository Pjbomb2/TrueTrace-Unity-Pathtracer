// #include "UnityCG.cginc"
#include "../GlobalDefines.cginc"

#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "../MainCompute/CommonData.cginc"
#include "../MainCompute/Materials.cginc"
#include "../Utility/Atmosphere/AtmosphereSampling.cginc"

RWTexture2D<float4> gHashBucketPos;
RWTexture2D<float4> gHashBucketFlux;
RWTexture2D<float4> gHashBucketDir;
RWStructuredBuffer<uint> gHashCounter;

#define gCausticRadius 0.005f
#define gCausticHashScaleFactor (1.0f / gCausticRadius)

#define gBucketYExtent 512
#define kMinCosTheta 1e-6
#define LaunchDimsX 16
#define LaunchDimsY 16

int mNumBuckets;

#pragma kernel InitKernelA
[numthreads(LaunchDimsX, LaunchDimsY, 1)]
void InitKernelA(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    if(id.x > screen_width || id.y > screen_height) return;
    gHashBucketPos[id.xy] = 0;
    gHashBucketFlux[id.xy] = 0;
    gHashBucketDir[id.xy] = 0;
}
#pragma kernel InitKernelB
[numthreads(1024, 1, 1)]
void InitKernelB(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    if(id.x > mNumBuckets) return;
    gHashCounter[id.x] = 0;
}

void IntersectTriangle(int mesh_id, const int tri_id, const SmallerRay ray, inout RayHit ray_hit, const int MatOffset, const float RandNum) {
    TrianglePos tri = triangle_get_positions(tri_id);

    float3 h = cross(ray.direction, tri.posedge2);
    float  a = dot(tri.posedge1, h);

    float  f = rcp(a);
    float3 s = ray.origin - tri.pos0;
    float  u = f * dot(s, h);

    float3 q = cross(s, tri.posedge1);
    float  v = f * dot(ray.direction, q);

    [branch]if (u >= 0 && v >= 0.0f && u + v <= 1.0f) {
        float t = f * dot(tri.posedge2, q);

        [branch]if (t > 0 && t < ray_hit.t) {
            const TriangleUvs tri2 = triangle_get_positions2(tri_id);
            const int MaterialIndex = (MatOffset + AggTrisA[tri_id].MatDat);
            //major slowdown
            #ifdef AdvancedAlphaMapped
                [branch]if(_IntersectionMaterials[MaterialIndex].MatType == CutoutIndex) {
                    float2 BaseUv = tri2.pos0 * (1.0f - u - v) + tri2.posedge1 * u + tri2.posedge2 * v;
                    if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0) 
                        if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x < _IntersectionMaterials[MaterialIndex].AlphaCutoff) return;
                }
            #endif
            #ifdef FadeMapping
                [branch]if(_IntersectionMaterials[MaterialIndex].MatType == FadeIndex) {
                    float2 BaseUv = tri2.pos0 * (1.0f - u - v) + tri2.posedge1 * u + tri2.posedge2 * v;
                    if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                        if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x - _IntersectionMaterials[MaterialIndex].AlphaCutoff <= RandNum) return;
                }
            #endif
            if(CurBounce == 0 && GetFlag(_IntersectionMaterials[MaterialIndex].Tag, Invisible)) return;
            ray_hit.t = t;
            ray_hit.u = u;
            ray_hit.v = v;
            ray_hit.mesh_id = mesh_id;
            ray_hit.triangle_id = tri_id;
        }
    }
}

inline RayHit IntersectBVH(SmallerRay GlobalRay, int pixel_index) {
    RayHit bestHit = CreateRayHit();
    GlobalRay.direction = (GlobalRay.direction == 0 ? EPSILON : GlobalRay.direction);
    SmallerRay ray = GlobalRay;
    int Reps = 0;
    uint2 stack[16];
    int stack_size = 0;
    uint2 current_group = 0;
    uint oct_inv4 = ray_get_octant_inv4(ray.direction);
    int tlas_stack_size = -1;
    int NodeOffset = 0;
    int TriOffset = 0;
    int MatOffset = 0;
    int mesh_id = -1;
                current_group.y = 0b10000000000000000000000000000000;//(uint)0x80000000;

    float RandNum = random(43, pixel_index).x;

    uint2 triangle_group = 0;



    [loop]while (Reps < MaxTraversalSamples) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)          

        [branch]if (current_group.y > 0x00FFFFFF) {
            uint child_index_offset = firstbithigh(current_group.y);

            uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
            uint relative_index = countbits(current_group.y & ~(0xffffffff << slot_index));
            uint child_node_index = current_group.x + relative_index;
            const BVHNode8Data TempNode = cwbvh_nodes[child_node_index];

            current_group.y &= ~(1 << child_index_offset);

            if (current_group.y > 0x00FFFFFF) stack[stack_size++] = current_group;

            current_group.x = (TempNode.nodes[1].x) + NodeOffset;
            triangle_group.x = (TempNode.nodes[1].y) + TriOffset;

            uint hitmask = cwbvh_node_intersect(ray, oct_inv4, bestHit.t, TempNode);

            current_group.y = (hitmask & 0xff000000) | ((TempNode.nodes[0].w >> 24) & 0xff);
            triangle_group.y = (hitmask & 0x00ffffff);

            Reps++;
        } else {
            triangle_group = current_group;
            current_group = (uint)0;
        }

        if(triangle_group.y != 0) {
            [branch]if(tlas_stack_size == -1) {
                uint mesh_offset = firstbithigh(triangle_group.y);
                triangle_group.y &= ~(1 << mesh_offset);
                mesh_id = TLASBVH8Indices[triangle_group.x + mesh_offset];
                NodeOffset = _MeshData[mesh_id].NodeOffset;
                TriOffset = _MeshData[mesh_id].TriOffset;

                if (triangle_group.y != 0) stack[stack_size++] = triangle_group;
                if (current_group.y & 0xff000000) stack[stack_size++] = current_group;

                tlas_stack_size = stack_size;

                int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                MatOffset = _MeshData[mesh_id].MaterialOffset;
                ray.direction = (mul((float3x3)_MeshData[mesh_id].W2L, ray.direction));
                ray.origin = (mul(_MeshData[mesh_id].W2L, float4(ray.origin, 1))).xyz;

                oct_inv4 = ray_get_octant_inv4(ray.direction);

                current_group.x = (uint)root_index;
                current_group.y = (uint)0x80000000;
            } else {
                while (triangle_group.y != 0) {
                    uint triangle_index = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << triangle_index);
                    IntersectTriangle(mesh_id, triangle_group.x + triangle_index, ray, bestHit, MatOffset, RandNum);//Intersect Mesh Triangles
                }
            }
        }
      
        if ((current_group.y & 0xff000000) == 0) {
            if (stack_size == 0) {//thread has finished traversing
                break;
            }

            if (stack_size == tlas_stack_size) {
                NodeOffset = 0;
                TriOffset = 0;
                tlas_stack_size = -1;
                ray = GlobalRay;
                oct_inv4 = ray_get_octant_inv4(ray.direction);
            }
            current_group = stack[--stack_size];
        }
    }
    return bestHit;
}













inline void calcFinalColor(inout PhotonRayData ray, MaterialData hitDat, RayHit hit, uint2 id, const uint pixel_index, int MaterialIndex, float2 BaseUv) {//main function
    float3 PrevOrigin = ray.origin;
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 USGNorm;//Unsmoothed geometric normal
    float3 norm;
    float3 Geomnorm;
    float3x3 Inverse = transpose((float3x3)_MeshData[hit.mesh_id].W2L);
    bool validBSDFSample;

    float3 throughput = ray.throughput;
    Geomnorm = GetTriangleNormal(hit.triangle_id, float2(hit.u, hit.v), Inverse);
    USGNorm = mul(Inverse, cross(normalize(AggTrisA[hit.triangle_id].posedge1), normalize(AggTrisA[hit.triangle_id].posedge2)));
    float wldScale = rsqrt(dot(USGNorm, USGNorm));
    USGNorm = -mul(wldScale, USGNorm);
    if(dot(USGNorm, Geomnorm) < 0) USGNorm *= -1;
    if(hitDat.MatType == CutoutIndex) USGNorm = Geomnorm;

    bool GotFlipped = dot(ray.direction, USGNorm) > 0.0f;
    if (GotFlipped) {USGNorm *= -1.0f; Geomnorm *= -1.0f;}//Backfacing surface

    norm = Geomnorm;


        float3 LocalTan = GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = SampleTexture(BaseUv, SampleNormal, hitDat);

        float3 LocalNormIN = float3((hitDat.NormalStrength * Norm - (hitDat.NormalStrength / 2.0f)), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);

        if(hitDat.SecondaryNormalTex.x > 0) {
            float2 DetailNorm = SampleTexture(BaseUv, SampleDetailNormal, hitDat);
            float3 DetailLocalNormIN = float3((hitDat.DetailNormalStrength * DetailNorm - (hitDat.DetailNormalStrength / 2.0f)), 0.0f);
            DetailLocalNormIN.z = 1.0 - 0.5 * dot(DetailLocalNormIN, DetailLocalNormIN);
            LocalNormIN = lerp(LocalNormIN, DetailLocalNormIN, hitDat.SecondaryNormalTexBlend);
        }

        norm = clamp(normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz),-1,1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
        norm = i_octahedral_32(octahedral_32(norm));


    int MaterialLobe = 2;
    float3 bsdfmodifier = 1;
    bool Refracted = false;
    float3 bsdf = 1;
    float pdf = 1;
    [branch] if (hitDat.emission > 0.0f) {
        ray.terminated = true;
        return;
    }
   
    validBSDFSample = SampleDisney(hitDat, ray.direction, GetFlag(hitDat.Tag, Thin), pdf, bsdf, norm, MaterialLobe, pixel_index, Refracted, GotFlipped);
    {
        if (Refracted) {
            Geomnorm *= -1;
            norm *= -1;
            USGNorm *= -1;
        }
        bsdf *= bsdfmodifier;
        throughput *= bsdf;
    }

    ray.origin = USGNorm * NormalOffset + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of
    throughput = max(throughput, 0);
    ray.diffuseHit = !((MaterialLobe == 3) || (MaterialLobe == 0 && hitDat.roughness < 0.3f));
    ray.Norm = octahedral_32(Geomnorm);
    ray.throughput = throughput;
    if (!validBSDFSample || any(throughput <= 0)) {
        ray.terminated = true;
        return;//If the ray failed, we have no choice but to terminate this path
    }



}
static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0};



inline void FullTrace(inout PhotonRayData GlobRay, inout RayHit bestHit, int pixel_index, int2 id, int i) {
        bestHit = IntersectBVH(CreateRay(GlobRay.origin, GlobRay.direction), pixel_index);
        int MaterialIndex;
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTrisA[bestHit.triangle_id].MatDat;
        if (bestHit.t == FarPlane) {
            GlobRay.terminated = true;
            return;
        }

        float2 BaseUv;
        MaterialData TempMat;
        BaseUv = TOHALF(AggTrisA[bestHit.triangle_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTrisA[bestHit.triangle_id].texedge1) * bestHit.u + TOHALF(AggTrisA[bestHit.triangle_id].texedge2) * bestHit.v;
        TempMat = _Materials[MaterialIndex];

        float3 TempCol = 1;
        if(TempMat.AlbedoTex.x > 0) TempCol = SampleTexture(BaseUv, SampleAlbedo, TempMat);
        TempMat.surfaceColor *= TempCol;

        TempCol = TempMat.surfaceColor;
        Unity_Hue_Degrees_float(TempCol, TempMat.Hue * 500.0f, TempMat.surfaceColor);
        TempMat.surfaceColor *= TempMat.Brightness;
        TempCol = TempMat.surfaceColor;
        Unity_Saturation_float(TempCol, TempMat.Saturation, TempMat.surfaceColor);
        Unity_Contrast_float(TempMat.surfaceColor, TempMat.Contrast);
        TempMat.surfaceColor = saturate(TempMat.surfaceColor);
        TempMat.surfaceColor = lerp(TempMat.surfaceColor, TempMat.BlendColor, TempMat.BlendFactor);

        if (TempMat.specTrans != 1 && TempMat.MetallicTex.x > 0) TempMat.metallic = pow(SampleTexture(BaseUv, SampleMetallic, TempMat), rcp(2.2f));
        if (TempMat.RoughnessTex.x > 0) {
            TempMat.roughness = saturate(pow(SampleTexture(BaseUv, SampleRoughness, TempMat), rcp(2.2f)));
            TempMat.roughness = (GetFlag(TempMat.Tag, InvertSmoothnessTexture) ? (1.0f - TempMat.roughness) : TempMat.roughness);
        }
        TempMat.metallic = saturate(TempMat.metallic);
        if(!all(TempMat.MetallicRemap == float2(0,1))) TempMat.metallic = (TempMat.metallic * (TempMat.MetallicRemap.y - TempMat.MetallicRemap.x)) + TempMat.MetallicRemap.x;
        if(!all(TempMat.RoughnessRemap == float2(0,1))) {
            if(GetFlag(TempMat.Tag, UseSmoothness)) TempMat.roughness = (TempMat.roughness * ((1.0f - TempMat.RoughnessRemap.x) - (1.0f - TempMat.RoughnessRemap.y))) + (1.0f - TempMat.RoughnessRemap.y);
            else TempMat.roughness = (TempMat.roughness * (TempMat.RoughnessRemap.y - TempMat.RoughnessRemap.x)) + TempMat.RoughnessRemap.x;
        }


        TempMat.roughness = max(TempMat.roughness, 0.00001f);
        float3 bsdf = 1;
        float3 norm = 0;
        calcFinalColor(GlobRay, TempMat, bestHit, id.xy, pixel_index, MaterialIndex, BaseUv);
}




uint Photonhash(int3 cell)
{
    //convert to uint64
    uint64_t key = 0;
    uint64_t cells = cell.x;
    cells &= 0x1FFFFF;
    key |= cells << 42;
    cells = cell.y;
    cells &= 0x1FFFFF;
    key |= cells << 21;
    cells = cell.z;
    cells &= 0x1FFFFF;
    key |= cells;

    key = (~key) + (key << 18);
    key = key ^ (key >> 31);
    key *= 21;
    key = key ^ (key >> 11);
    key = key + (key << 6);
    uint res = uint(key) ^ uint(key >> 22);
    return res;
}

int mPGDDispatchX;
int mMaxDispatchY;

#pragma kernel kernel_gen
[numthreads(32, 32, 1)]
void kernel_gen(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    PhotonRayData CurrentRay = {float3(1,1,1), 0, float3(0,0,0), false, float3(0,1,0), false};
    int pixel_index = id.x + id.y * screen_width;
    LightData SelectedLight = _UnityLights[0];
    float3 LightPos = 0;
    float3 LightDir = 0;
    float3 LightInten = 0;
    float SpotAngle = 0;
    float LightArea = 1.0f;
    float pdf = 0.0f;
    // if(SelectedLight.Type == POINTLIGHT) {
        RandomNumsWrite[id.xy] = uint4(12,0,0,0);
        LightPos = SelectedLight.Position;
        LightDir = SampleDirectionSphere(random(12, pixel_index).x, random(12, pixel_index).y);
        // LightDir.y = -abs(LightDir.y);
        LightInten = SelectedLight.Radiance;
        pdf = 1.0f / (4.0f * PI);
        // SpotAngle = SpotAngle.y;
    // }

    Photon photon = {float4(0,0,0,0), float3(0,0,0), 1.0f, float3(0,0,0), 1.0f};
    float3 lightFlux = LightInten / float(mPGDDispatchX * mMaxDispatchY) * pdf;

    CurrentRay.origin = LightPos + 0.01f * LightDir;
    CurrentRay.direction = LightDir;
    RayHit bestHit;

    bool wasReflectedSpecular = false;
    bool reflectedDiffuse = false;
int i;
    [loop]for(i = 0; i < 7; i++) {
        RandomNumsWrite[id.xy] = uint4(i+1,0,0,0);
        photon.Flux = lightFlux * CurrentRay.throughput;
        FullTrace(CurrentRay, bestHit, pixel_index, id, i);

        if(CurrentRay.terminated) break;

        photon.Pos = float4(CurrentRay.origin, 0);
        photon.Dir = CurrentRay.direction;
        reflectedDiffuse = CurrentRay.diffuseHit;

        [branch]if(reflectedDiffuse) {

            // {
            //     uint encTheta = (CurrentRay.Norm >> 16) & 0xFFFF;
            //     uint encPhi = CurrentRay.Norm & 0xFFFF;
            //     photon.faceNTheta = f16tof32(encTheta);
            //     photon.faceNPhi = f16tof32(encPhi);
            // }

            uint photonIndex = 0;
            uint photonBucketIndex = 0;

            float rndRoulette = random(94 + i, pixel_index).x;
            bool roulette = rndRoulette <= 0.05f;

            float cellScale = gCausticHashScaleFactor;
            int3 cell = int3(floor(photon.Pos.xyz * cellScale));
            uint bucketIdx = Photonhash(cell) & (mNumBuckets - 1);

            if (roulette || wasReflectedSpecular) {
                InterlockedAdd(gHashCounter[bucketIdx], 1u, photonIndex);
                //Insert photon
                float rnd = random(43 + i, pixel_index).x;
                float probability = 1.f / (photonIndex + 1);
                uint2 texIdx = uint2(bucketIdx / gBucketYExtent, bucketIdx % gBucketYExtent);
                float WSUM = luminance(gHashBucketFlux[texIdx].xyz) * (photonIndex+1) + luminance(photon.Flux.xyz);

                // if (rnd * WSUM <= luminance(photon.Flux.xyz))
                if (rnd <= probability)
                {
                    photon.InitialDirection = octahedral_32(LightDir);
                    gHashBucketPos[texIdx] = photon.Pos;
                    gHashBucketFlux[texIdx] = float4(photon.Flux,1);// * (WSUM / max((photonIndex+1) * luminance(photon.Flux.xyz), 1e-7)) , asfloat(photon.InitialDirection));
                    gHashBucketDir[texIdx] = float4(photon.Dir, asfloat(bucketIdx));

                }
            }      

        }

        const float rrVal = luminance(CurrentRay.throughput);
        const float prob = max(0.f, 1.f - rrVal);
        float rnd = random(43 + i, pixel_index).y;
        // if (rnd < prob) break;
        // else CurrentRay.throughput /= (1.f - prob);

        // if(i == 0) _DebugTex[id.xy] =  TempMat.specTrans == 1;//float4(photon.Flux, 1);//float4(CurrentRay.throughput, 1);
        if(i == 0) wasReflectedSpecular = !reflectedDiffuse;
        wasReflectedSpecular = wasReflectedSpecular && !reflectedDiffuse;
    }
}
Texture2D<float4> ThroughputTex;
Texture2D<float4> ViewDirTex;

bool hitSphere(const float3 center, const float radius, const float3 p)
{
    float3 radiusTest = p - center;
    radiusTest = radiusTest * radiusTest;
    float radiusTestF = radiusTest.x + radiusTest.y + radiusTest.z;
    if (radiusTestF < radius * radius)
        return true;
    return false;
}

float3 photonContribution(float3 Norm, float3 Pos, uint hash)
{
    //get caustic or global photon
    float radius = gCausticRadius;
    uint2 texIdx = uint2(hash / gBucketYExtent, hash % gBucketYExtent);
    float4 photonPos = gHashBucketPos[texIdx];
    float4 photonDir = gHashBucketDir[texIdx];
    float4 photonFlux = gHashBucketFlux[texIdx];
    uint photonCount = gHashCounter[hash];

    //Do face normal test if enabled
    // if(kUsePhotonFaceNormal){
    //     //Sperical to cartesian
    //     float sinTheta = sin(photonFlux.w);
    //     float3 photonFaceN = float3(cos(photonDir.w) * sinTheta, cos(photonFlux.w), sin(photonDir.w) * sinTheta);
    //     photonFaceN = normalize(photonFaceN);
    //     float3 faceN = dot(sd.V, sd.faceN) > 0 ? sd.faceN : -sd.faceN;
    //     //Dot product has to be negative (View dir points to surface)
    //     if(dot(faceN, photonFaceN) < 0.9f)
    //         return float3(0);
    // }
    
    //Radius test
    if (!hitSphere(photonPos.xyz, radius, Pos) || photonCount == 0)
        return 0;
    
    
    float NdotL = dot(Norm, -photonDir.xyz);
    float3 radiance = 0;
    if(NdotL > kMinCosTheta){
        // let bsdf = gScene.materials.getBSDF(sd, lod);
        // float3 f_r = bsdf.eval(sd, -photonDir.xyz,sg) / NdotL;
        radiance = 4.0f * photonFlux.xyz * photonCount;
    }
    return radiance;
}


float3 collectPhotons(float3 Norm, float3 Pos)
{
    float3 radiance = 0;
    
    
    float radius = gCausticRadius;
    float scale = gCausticHashScaleFactor;
    int3 gridCenter = int3(floor(Pos * scale));
    int gridRadius = int(ceil(radius * scale));
    //Loop over whole hash grid

    for (int z = gridCenter.z - gridRadius; z <= gridCenter.z + gridRadius; z++){
        for (int y = gridCenter.y - gridRadius; y <= gridCenter.y + gridRadius; y++){
            for (int x = gridCenter.x - gridRadius; x <= gridCenter.x + gridRadius; x++)
            {
                uint b = Photonhash(int3(x, y, z)) & (mNumBuckets - 1);
                radiance += photonContribution(Norm, Pos, b);        
            }
        }
    }
    return radiance;
}


Texture2D<uint4> PrimaryTriangleInfo;
#pragma kernel kernel_collect
[numthreads(16, 16, 1)]
void kernel_collect(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    int pixel_index = id.x + id.y * screen_width;

     float3 viewVec = -ViewDirTex[id.xy].xyz;
    float4 thp = ThroughputTex[id.xy];
    float3 Pos;
    float3 Norm;
    CalcPosNorm(PrimaryTriangleInfo[id.xy], Pos, Norm);
    float3 radiance = 0;

    float3 causticRadiance = collectPhotons(-Norm, Pos);
    float w = 1.0f / (PI * gCausticRadius * gCausticRadius); //make this a constant
    radiance += w * causticRadiance;
    
    radiance *= thp;

    GlobalColors[pixel_index].Direct = radiance;
    GlobalColors[pixel_index].Indirect = 0;
    GlobalColors[pixel_index].PrimaryNEERay = 0;
    // float3 res = (GetBounceData(GlobalColors[pixel_index].MetRoughIsSpec) == 1) ? (GlobalColors[pixel_index].Data.xyz + pow(unpackRGBE(GlobalColors[pixel_index].PrimaryNEERay),2.2f)) : (((float)PartialRenderingFactor) * ((radiance * 3.0f + GlobalColors[pixel_index].Direct + GlobalColors[pixel_index].Indirect) * GlobalColors[pixel_index].Data.xyz) + pow(unpackRGBE(GlobalColors[pixel_index].PrimaryNEERay),2.2f));

    // Result[id.xy] = float4(res, 1);

}