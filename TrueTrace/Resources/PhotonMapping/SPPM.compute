#define COLOREDGLASS
#define ACCURATECAUSTICS
#define gCausticRadius 0.005f

// #include "UnityCG.cginc"
#include "../GlobalDefines.cginc"

#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "../MainCompute/CommonData.cginc"
#include "../MainCompute/Materials.cginc"
#include "../Utility/Atmosphere/AtmosphereSampling.cginc"

#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif


RWTexture2D<float4> gHashBucketPos;
RWTexture2D<float4> gHashBucketFlux;
RWTexture2D<float4> gHashBucketDir;
RWStructuredBuffer<uint> gHashCounter;

#define gCausticHashScaleFactor (1.0f / gCausticRadius)

#define gBucketYExtent 512
#define kMinCosTheta 1e-6
#define LaunchDimsX 16
#define LaunchDimsY 16

float CDFWIDTH;

#define CDFHEIGHT (CDFWIDTH / 2.0f)

struct AABBBuffData {
    uint3 BBMax;
    uint3 BBMin;
    int3 AveragedCenter;
    uint PhotonCount;
};
RWStructuredBuffer<AABBBuffData> AABBBuff;
int PhotonFrames;

int mNumBuckets;

int2 GetLightOffset(int Index) {
    return int2(floor(Index % ceil(sqrt((float)unitylightcount))) * CDFWIDTH, floor((float)Index / ceil(sqrt((float)unitylightcount))) * CDFHEIGHT);
}

inline uint FloatToUint(float f) {
    uint mask = -((int) (asuint(f) >> 31)) | 0x80000000;
    return asuint(f) ^ mask;
}

inline float UintToFloat(uint u) {
    uint mask = ((u >> 31) - 1) | 0x80000000;
    return asfloat(u ^ mask);
}
#pragma kernel InitKernelA
[numthreads(LaunchDimsX, LaunchDimsY, 1)]
void InitKernelA(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    if(id.x > screen_width || id.y > screen_height) return;
    AABBBuffData ZeroedBuff = {uint3(FloatToUint(-999999),FloatToUint(-999999), FloatToUint(-999999)), uint3(FloatToUint(999999),FloatToUint(999999), FloatToUint(999999)), int3(0,0,0), 0};
    // AABBBuffData ZeroedBuff = {uint3(FloatToUint(6.42),FloatToUint(0.598), FloatToUint(-14.93)), uint3(FloatToUint(6.42),FloatToUint(0.598), FloatToUint(-14.93)), 0};
    AABBBuff[PhotonFrames % 2] = ZeroedBuff;
    gHashBucketPos[id.xy] = 0;
    gHashBucketFlux[id.xy] = 0;
    gHashBucketDir[id.xy] = 0;
}
#pragma kernel InitKernelB
[numthreads(1024, 1, 1)]
void InitKernelB(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    if(id.x > mNumBuckets) return;
    gHashCounter[id.x] = 0;
}

Texture2D<float4> VisTexA;
RWTexture2D<float4> VisTexB;
RWTexture2D<float> CDFXWRITE;
RWTexture2D<float> CDFYWRITE;

#pragma kernel InitKernelC
[numthreads(32, 32, 1)]
void InitKernelC(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    float4 A = VisTexB[id.xy];
    VisTexB[id.xy] = float4((A.x > 0) * A.z, A.y == 0 ? 0 : ((float)A.z / (float)max(AABBBuff[PhotonFrames % 2].PhotonCount, 1)), 0, A.w);
    // VisTexB[id.xy] = float4(A.x > 0, A.y == 0 ? 0 : (1.0f / max(A.y, 1)), 0, A.w);
    // VisTexB[id.xy] = float4(A.x / max(A.w, 1), A.w == 0 ? 0 : (1.0f / max(A.w, 1)), 0, 0);
    // VisTexB[id.xy] = float4(A.x > 0, 0, 0, exp(-(A.w * 1200.0f + 1)));
    CDFXWRITE[id.xy] = 0;
    CDFYWRITE[int2(id.y,1)] = 0;
}

#pragma kernel InitKernelD
[numthreads(32, 32, 1)]
void InitKernelD(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    VisTexB[id.xy] = 0;
    // VisTexB[id.xy] *= 0.5f;//semi temporal mode
}



float3 SampleLIPhoton(int pixel_index, inout float pdf, inout float3 wi) {
    float2 Rand = random(222, pixel_index);
    float2 uv;
    int v, offset;
    {
        v = FindInterval(CDFHEIGHT * ceil(sqrt((float)unitylightcount)), Rand.x, CDFY);

        float du = Rand.x - CDFY[int2(v, 0)];
        float diff = (CDFY[int2(v + 1, 0)] - CDFY[int2(v, 0)]);
        if(diff > 0)
            du /= diff;

        uv.y = ((float)v + du) / (CDFHEIGHT);
    }

    {
        offset = FindInterval(CDFWIDTH * ceil(sqrt((float)unitylightcount)), Rand.y, CDFX, v);
        float du = Rand.y - CDFX[int2(offset, v)];
        float diff = (CDFX[int2(offset + 1, v)] - CDFX[int2(offset, v)]);
        if(diff > 0)
            du /= diff;

        uv.x = ((float)offset + du) / (CDFWIDTH);
    }
    float2 uv2 = fmod(uv , 1.0f);
    wi = -equirectUvToDirection(uv2);

    return (int)VisTexA.SampleLevel(my_linear_clamp_sampler, uv / (float)ceil(sqrt((float)unitylightcount)), 0).w;
}   



void IntersectTriangle(int mesh_id, const int tri_id, const SmallerRay ray, inout RayHit ray_hit, const int MatOffset, const float RandNum) {
    TrianglePos tri = triangle_get_positions(tri_id);

    float3 h = cross(ray.direction, tri.posedge2);
    float  a = dot(tri.posedge1, h);

    float  f = rcp(a);
    float3 s = ray.origin - tri.pos0;
    float  u = f * dot(s, h);

    float3 q = cross(s, tri.posedge1);
    float  v = f * dot(ray.direction, q);

    [branch]if (u >= 0 && v >= 0.0f && u + v <= 1.0f) {
        float t = f * dot(tri.posedge2, q);

        [branch]if (t > 0 && t < ray_hit.t) {
            const TriangleUvs tri2 = triangle_get_positions2(tri_id);
            const int MaterialIndex = (MatOffset + AggTrisA[tri_id].MatDat);
            //major slowdown
            #ifdef AdvancedAlphaMapped
                [branch]if(_IntersectionMaterials[MaterialIndex].MatType == CutoutIndex) {
                    float2 BaseUv = tri2.pos0 * (1.0f - u - v) + tri2.posedge1 * u + tri2.posedge2 * v;
                    if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0) 
                        if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x < _IntersectionMaterials[MaterialIndex].AlphaCutoff) return;
                }
            #endif
            #ifdef FadeMapping
                [branch]if(_IntersectionMaterials[MaterialIndex].MatType == FadeIndex) {
                    float2 BaseUv = tri2.pos0 * (1.0f - u - v) + tri2.posedge1 * u + tri2.posedge2 * v;
                    if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                        if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x - _IntersectionMaterials[MaterialIndex].AlphaCutoff <= RandNum) return;
                }
            #endif
            if(CurBounce == 0 && GetFlag(_IntersectionMaterials[MaterialIndex].Tag, Invisible)) return;
            ray_hit.t = t;
            ray_hit.u = u;
            ray_hit.v = v;
            ray_hit.mesh_id = mesh_id;
            ray_hit.triangle_id = tri_id;
        }
    }
}

inline RayHit IntersectBVH(SmallerRay GlobalRay, int pixel_index) {
    RayHit bestHit = CreateRayHit();
    GlobalRay.direction = (GlobalRay.direction == 0 ? EPSILON : GlobalRay.direction);
    SmallerRay ray = GlobalRay;
    int NodeOffset = 0;
    int TriOffset = 0;
    int MatOffset = 0;
    int mesh_id = -1;

    float RandNum = random(43, pixel_index).x;



  #ifdef HardwareRT
            const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
            UnityRayQuery<rayFlags> q;
            RayDesc myRay;
            myRay.Origin = GlobalRay.origin;
            myRay.Direction = GlobalRay.direction;
            myRay.TMin = 0;
            myRay.TMax = bestHit.t;
            // bestHit.t = FarPlane;
            while(true) {
               q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
                while(q.Proceed()){}

                if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) {
                    bestHit.t = q.CommittedRayT();
                    bestHit.u = q.CommittedTriangleBarycentrics().y;
                    bestHit.v = q.CommittedTriangleBarycentrics().x;
                    bestHit.mesh_id = uint(q.CommittedInstanceID() | (q.CommittedGeometryIndex() << 25));
                    bestHit.triangle_id = q.CommittedPrimitiveIndex();
                    #if defined(AdvancedAlphaMapped) || defined(IgnoreBackfacing) || defined(FadeMapping) || defined(IgnoreGlassMain)
                        int2 Indexes = int2(bestHit.mesh_id & 0x1FFFFFF, bestHit.mesh_id >> 25);
                        int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
                        int tri_id = bestHit.triangle_id + triangleOffset;
                        int mesh_id = MeshOffsets[Indexes.x].y;
                        int MaterialIndex = (_MeshData[mesh_id].MaterialOffset + AggTrisA[tri_id].MatDat);
                    #endif
                    #ifdef AdvancedAlphaMapped
                        if(CurBounce == 0 && GetFlag(_IntersectionMaterials[MaterialIndex].Tag, Invisible)) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                        if(_IntersectionMaterials[MaterialIndex].MatType == CutoutIndex) {
                            float2 BaseUv = TOHALF(AggTrisA[tri_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTrisA[tri_id].texedge1) * bestHit.u + TOHALF(AggTrisA[tri_id].texedge2) * bestHit.v;
                            if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                                if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x < _IntersectionMaterials[MaterialIndex].AlphaCutoff) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                        }
                    #endif
                    #ifdef IgnoreGlassMain
                        if(_IntersectionMaterials[MaterialIndex].specTrans == 1) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                    #endif
                    #ifdef IgnoreBackfacing
                        TrianglePos tri = triangle_get_positions(tri_id);
                        if(_IntersectionMaterials[MaterialIndex].specTrans != 1 && dot(normalize(cross(normalize(tri.posedge1), normalize(tri.posedge2))), mul((float3x3)_MeshData[mesh_id].W2L, ray.direction)) <= 0) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                    #endif
                    #ifdef FadeMapping
                        if(_IntersectionMaterials[MaterialIndex].MatType == FadeIndex) {
                            float2 BaseUv = TOHALF(AggTrisA[tri_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTrisA[tri_id].texedge1) * bestHit.u + TOHALF(AggTrisA[tri_id].texedge2) * bestHit.v;
                            if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                                if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x - _IntersectionMaterials[MaterialIndex].AlphaCutoff <= RandNum) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                        }
                    #endif
                }
                break;
            }

            if(bestHit.mesh_id != 9999999) {
                int2 Indexes = int2(bestHit.mesh_id & 0x1FFFFFF, bestHit.mesh_id >> 25);
                int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
                bestHit.triangle_id += triangleOffset;
                bestHit.mesh_id = MeshOffsets[Indexes.x].y;
            }
        #else

    int Reps = 0;
    uint2 stack[16];
    int stack_size = 0;
    uint2 current_group = 0;
    uint oct_inv4 = ray_get_octant_inv4(ray.direction);
    int tlas_stack_size = -1;
                current_group.y = 0b10000000000000000000000000000000;//(uint)0x80000000;
    uint2 triangle_group = 0;



    [loop]while (Reps < MaxTraversalSamples) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)          

        [branch]if (current_group.y > 0x00FFFFFF) {
            uint child_index_offset = firstbithigh(current_group.y);

            uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
            uint relative_index = countbits(current_group.y & ~(0xffffffff << slot_index));
            uint child_node_index = current_group.x + relative_index;
            const BVHNode8Data TempNode = cwbvh_nodes[child_node_index];

            current_group.y &= ~(1 << child_index_offset);

            if (current_group.y > 0x00FFFFFF) stack[stack_size++] = current_group;

            current_group.x = (TempNode.nodes[1].x) + NodeOffset;
            triangle_group.x = (TempNode.nodes[1].y) + TriOffset;

            uint hitmask = cwbvh_node_intersect(ray, oct_inv4, bestHit.t, TempNode);

            current_group.y = (hitmask & 0xff000000) | ((TempNode.nodes[0].w >> 24) & 0xff);
            triangle_group.y = (hitmask & 0x00ffffff);

            Reps++;
        } else {
            triangle_group = current_group;
            current_group = (uint)0;
        }

        if(triangle_group.y != 0) {
            [branch]if(tlas_stack_size == -1) {
                uint mesh_offset = firstbithigh(triangle_group.y);
                triangle_group.y &= ~(1 << mesh_offset);
                mesh_id = TLASBVH8Indices[triangle_group.x + mesh_offset];
                NodeOffset = _MeshData[mesh_id].NodeOffset;
                TriOffset = _MeshData[mesh_id].TriOffset;

                if (triangle_group.y != 0) stack[stack_size++] = triangle_group;
                if (current_group.y & 0xff000000) stack[stack_size++] = current_group;

                tlas_stack_size = stack_size;

                int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                MatOffset = _MeshData[mesh_id].MaterialOffset;
                ray.direction = (mul((float3x3)_MeshData[mesh_id].W2L, ray.direction));
                ray.origin = (mul(_MeshData[mesh_id].W2L, float4(ray.origin, 1))).xyz;

                oct_inv4 = ray_get_octant_inv4(ray.direction);

                current_group.x = (uint)root_index;
                current_group.y = (uint)0x80000000;
            } else {
                while (triangle_group.y != 0) {
                    uint triangle_index = firstbithigh(triangle_group.y);
                    triangle_group.y &= ~(1 << triangle_index);
                    IntersectTriangle(mesh_id, triangle_group.x + triangle_index, ray, bestHit, MatOffset, RandNum);//Intersect Mesh Triangles
                }
            }
        }
      
        if ((current_group.y & 0xff000000) == 0) {
            if (stack_size == 0) {//thread has finished traversing
                break;
            }

            if (stack_size == tlas_stack_size) {
                NodeOffset = 0;
                TriOffset = 0;
                tlas_stack_size = -1;
                ray = GlobalRay;
                oct_inv4 = ray_get_octant_inv4(ray.direction);
            }
            current_group = stack[--stack_size];
        }
    }
    #endif
    return bestHit;
}













inline void calcFinalColor(inout PhotonRayData ray, MaterialData hitDat, RayHit hit, uint2 id, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float3 surfCol, inout float scatDist) {//main function
    float3 PrevOrigin = ray.origin;
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 USGNorm;//Unsmoothed geometric normal
    float3 norm;
    float3 Geomnorm;
    float3x3 Inverse = transpose((float3x3)_MeshData[hit.mesh_id].W2L);
    bool validBSDFSample;

    float3 throughput = ray.throughput;
    Geomnorm = GetTriangleNormal(hit.triangle_id, float2(hit.u, hit.v), Inverse);
    USGNorm = mul(Inverse, cross(normalize(AggTrisA[hit.triangle_id].posedge1), normalize(AggTrisA[hit.triangle_id].posedge2)));
    float wldScale = rsqrt(dot(USGNorm, USGNorm));
    USGNorm = -mul(wldScale, USGNorm);
    if(dot(USGNorm, Geomnorm) < 0) USGNorm *= -1;
    if(hitDat.MatType == CutoutIndex) USGNorm = Geomnorm;

    bool GotFlipped = dot(ray.direction, USGNorm) > 0.0f;
    if (GotFlipped) {USGNorm *= -1.0f; Geomnorm *= -1.0f;}//Backfacing surface

    norm = Geomnorm;

    if ((hitDat.NormalTex.x > 0 || hitDat.SecondaryNormalTex.x > 0)) {//Handle Normal Maps
        float3 LocalTan = GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = SampleTexture(BaseUv, SampleNormal, hitDat);

        float3 LocalNormIN = float3((hitDat.NormalStrength * Norm - (hitDat.NormalStrength / 2.0f)), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);

        if(hitDat.SecondaryNormalTex.x > 0) {
            float2 DetailNorm = SampleTexture(BaseUv, SampleDetailNormal, hitDat);
            float3 DetailLocalNormIN = float3((hitDat.DetailNormalStrength * DetailNorm - (hitDat.DetailNormalStrength / 2.0f)), 0.0f);
            DetailLocalNormIN.z = 1.0 - 0.5 * dot(DetailLocalNormIN, DetailLocalNormIN);
            LocalNormIN = lerp(LocalNormIN, DetailLocalNormIN, hitDat.SecondaryNormalTexBlend);
        }

        norm = clamp(normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz),-1,1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
        norm = i_octahedral_32(octahedral_32(norm));
    }


    int MaterialLobe = 2;
    float3 bsdfmodifier = 1;
    bool Refracted = false;
    float3 bsdf = 1;
    float pdf = 1;
    [branch] if (hitDat.emission > 0.0f) {
        ray.terminated = true;
        return;
    }
   
    validBSDFSample = SampleDisney(hitDat, ray.direction, GetFlag(hitDat.Tag, Thin), pdf, bsdf, norm, MaterialLobe, pixel_index, Refracted, GotFlipped);
    {
        if (Refracted) {
            Geomnorm *= -1;
            norm *= -1;
            USGNorm *= -1;
            surfCol = hitDat.surfaceColor;
            if(!GotFlipped) scatDist = hitDat.scatterDistance;
            // else scatDist = 999999;
        }
        bsdf *= bsdfmodifier;
        throughput *= bsdf;
    }

    ray.origin = USGNorm * NormalOffset + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of
    throughput = max(throughput, 0);
    ray.diffuseHit = !((MaterialLobe == 3) || (MaterialLobe == 0 && hitDat.roughness < 0.3f));
    ray.Norm = octahedral_32(Geomnorm);
    ray.throughput = throughput;
    if (!validBSDFSample || any(throughput <= 0)) {
        ray.terminated = true;
        return;//If the ray failed, we have no choice but to terminate this path
    }



}
static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0};



inline void FullTrace(inout PhotonRayData GlobRay, inout RayHit bestHit, int pixel_index, int2 id, int i, inout float3 surfCol, inout float scatDist) {
        bestHit = IntersectBVH(CreateRay(GlobRay.origin, GlobRay.direction), pixel_index);
        int MaterialIndex;
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTrisA[bestHit.triangle_id].MatDat;
        if (bestHit.t == FarPlane) {
            GlobRay.terminated = true;
            return;
        }

        float2 BaseUv;
        MaterialData TempMat;
        BaseUv = TOHALF(AggTrisA[bestHit.triangle_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTrisA[bestHit.triangle_id].texedge1) * bestHit.u + TOHALF(AggTrisA[bestHit.triangle_id].texedge2) * bestHit.v;
        TempMat = _Materials[MaterialIndex];

        float3 TempCol = 1;
        if(TempMat.AlbedoTex.x > 0) TempCol = SampleTexture(BaseUv, SampleAlbedo, TempMat);
        TempMat.surfaceColor *= TempCol;

        TempCol = TempMat.surfaceColor;
        Unity_Hue_Degrees_float(TempCol, TempMat.Hue * 500.0f, TempMat.surfaceColor);
        TempMat.surfaceColor *= TempMat.Brightness;
        TempCol = TempMat.surfaceColor;
        Unity_Saturation_float(TempCol, TempMat.Saturation, TempMat.surfaceColor);
        Unity_Contrast_float(TempMat.surfaceColor, TempMat.Contrast);
        TempMat.surfaceColor = saturate(TempMat.surfaceColor);
        TempMat.surfaceColor = lerp(TempMat.surfaceColor, TempMat.BlendColor, TempMat.BlendFactor);

        if (TempMat.specTrans != 1 && TempMat.MetallicTex.x > 0) TempMat.metallic = pow(SampleTexture(BaseUv, SampleMetallic, TempMat), rcp(2.2f));
        if (TempMat.RoughnessTex.x > 0) {
            TempMat.roughness = saturate(pow(SampleTexture(BaseUv, SampleRoughness, TempMat), rcp(2.2f)));
            TempMat.roughness = (GetFlag(TempMat.Tag, InvertSmoothnessTexture) ? (1.0f - TempMat.roughness) : TempMat.roughness);
        }
        TempMat.metallic = saturate(TempMat.metallic);
        if(!all(TempMat.MetallicRemap == float2(0,1))) TempMat.metallic = (TempMat.metallic * (TempMat.MetallicRemap.y - TempMat.MetallicRemap.x)) + TempMat.MetallicRemap.x;
        if(!all(TempMat.RoughnessRemap == float2(0,1))) {
            if(GetFlag(TempMat.Tag, UseSmoothness)) TempMat.roughness = (TempMat.roughness * ((1.0f - TempMat.RoughnessRemap.x) - (1.0f - TempMat.RoughnessRemap.y))) + (1.0f - TempMat.RoughnessRemap.y);
            else TempMat.roughness = (TempMat.roughness * (TempMat.RoughnessRemap.y - TempMat.RoughnessRemap.x)) + TempMat.RoughnessRemap.x;
        }


        TempMat.roughness = max(TempMat.roughness, 0.00001f);
        float3 bsdf = 1;
        float3 norm = 0;
        calcFinalColor(GlobRay, TempMat, bestHit, id.xy, pixel_index, MaterialIndex, BaseUv, surfCol, scatDist);
}




uint Photonhash(int3 cell)
{
    //convert to uint64
    uint64_t key = 0;
    uint64_t cells = cell.x;
    cells &= 0x1FFFFF;
    key |= cells << 42;
    cells = cell.y;
    cells &= 0x1FFFFF;
    key |= cells << 21;
    cells = cell.z;
    cells &= 0x1FFFFF;
    key |= cells;

    key = (~key) + (key << 18);
    key = key ^ (key >> 31);
    key *= 21;
    key = key ^ (key >> 11);
    key = key + (key << 6);
    uint res = uint(key) ^ uint(key >> 22);
    return res;
}

int mPGDDispatchX;
int mMaxDispatchY;

float3 sample_cone(float2 u, float cosTheta)
{
    float z = u.x * (1.f - cosTheta) + cosTheta;
    float r = sqrt(1.f - z*z);
    float phi = 2.0f * PI * u.y;
    return float3(r * cos(phi), z, r * sin(phi));
}


float3 SampleSphericalGaussian(float3 sgaxis, float sharpness, float2 rand)
{
    float lambda = sharpness;
    float cosTheta;

    if (lambda > 1e-4)
    {
        float expTerm = exp(-2.0 * lambda);
        cosTheta = 1.0 + log(1.0 - rand.x * (1.0 - expTerm)) / lambda;
        cosTheta = clamp(cosTheta, -1.0, 1.0); // numerical stability
    }
    else
    {
        // Near-uniform sampling
        cosTheta = 2.0 * rand.x - 1.0;
    }

    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float phi = 2.0 * 3.14159265 * rand.y;

    // Sample direction in local coordinate system where Y is "up"
    float3 localDir = float3(
        sinTheta * cos(phi),
        cosTheta,  // Y is "up" in local space
        sinTheta * sin(phi)
    );

    // Build orthonormal basis around sg.axis
    float3 axis = normalize(sgaxis);
    float3 up = float3(0, 1, 0);
    float3 T = normalize(cross(up, axis));
    float3 B = cross(axis, T);

    if (abs(dot(axis, up)) > 0.999f)
    {
        // axis is nearly aligned with up, so fall back
        return axis * cosTheta + float3(1, 0, 0) * sinTheta * cos(phi) + float3(0, 0, 1) * sinTheta * sin(phi);
    }

    // Rotate local sample to align with sg.axis
    return normalize(
        T * localDir.x +
        axis * localDir.y +
        B * localDir.z
    );
}

float SphericalGaussianPDF(float3 dir, float3 sgaxis, float sharpness)
{
    float lambda = sharpness;
    float cosTheta = dot(normalize(dir), normalize(sgaxis));

    // Avoid division by zero for small lambda
    if (lambda < 1e-4)
        return 1.0 / (4.0 * 3.14159265); // Uniform sphere

    // Compute sinh(lambda) safely
    float expPos = exp(lambda);
    float expNeg = exp(-lambda);
    float sinhLambda = 0.5 * (expPos - expNeg);

    float normalization = lambda / (4.0 * 3.14159265 * sinhLambda);

    return normalization * exp(lambda * cosTheta);
}

#pragma kernel kernel_gen
[numthreads(32, 32, 1)]
void kernel_gen(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    PhotonRayData CurrentRay = {float3(1,1,1), 0, float3(0,0,0), false, float3(0,1,0), false};
    int pixel_index = id.x + id.y * screen_width;
    RandomNumsWrite[id.xy] = uint4(12,0,0,0);
    int Index = clamp(( random(11, pixel_index).x * unitylightcount), 0, unitylightcount - 1);
    float pdf = 0.0f;
        pdf = 1.0f / (4.0f * PI);
    float3 LightDir = 0;
    bool A = false;
        if(AABBBuff[1 - (PhotonFrames % 2)].PhotonCount > 0 && id.x % 2 == 0 && id.y % 2 == 0) {
            A = true;
            float3 Dir2;
            Index = (int)SampleLIPhoton(pixel_index, pdf, Dir2);
            LightDir = normalize(Dir2);// * 122.0f + normalize(float3(random(200, pixel_index), random(201, pixel_index).x) * 0.5f - 0.5f));// * 122.0f + LightDir);
        }
    LightData SelectedLight = _UnityLights[Index];
    float3 LightPos = 0;
    float3 LightInten = 0;
    float SpotAngle = 0;
    float LightArea = 1.0f;
    pdf *= (float)unitylightcount;
    if(SelectedLight.Type == POINTLIGHT) {
        LightPos = SelectedLight.Position;
        if(!A) {
            LightDir = SampleDirectionSphere(random(12, pixel_index).x, random(12, pixel_index).y);
        }
        LightInten = SelectedLight.Radiance;// * 2.0f * PI;
    } else if(SelectedLight.Type == SPOTLIGHT) {
        LightPos = SelectedLight.Position;
        float ConeAngle = -SelectedLight.SpotAngle.y / SelectedLight.SpotAngle.x;
        if(!A) {
            LightDir = sample_cone(random(12, pixel_index), ConeAngle);
            LightDir = ToWorld(GetTangentSpace(SelectedLight.Direction), LightDir);
        }

        pdf = (2.0f * PI * (1.0f - ConeAngle)) / (4.0f * PI);
        LightInten = SelectedLight.Radiance;
    } else if(SelectedLight.Type = DIRECTIONALLIGHT) {
        LightPos = SelectedLight.Direction * 100.0f;
        // LightDir = sample_cone(random(12, pixel_index), 42.0f * (PI / 180.0f));
        pdf = 100.0f / (4.0f * PI);
        if(!A) {
        LightDir = -SelectedLight.Direction;//ToWorld(GetTangentSpace(SelectedLight.Direction), LightDir);
        
            float3 RandVec = float3(random(115, pixel_index), random(116, pixel_index).x);
            // LightDir = ToWorld(GetTangentSpace(-SelectedLight.Direction), normalize(float3(RandVec.x - 0.5f,1,RandVec.y - 0.5f)));// * length(RandVec.xy);

                    float cosPhi = 1;
                    float sinPhi = 1;
                     sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * 100.f;
                    LightDir = normalize(ToWorld(GetTangentSpace2(-SelectedLight.Direction), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy) - LightPos);
                    }else pdf = 100.0f / pdf / (4.0f * PI);
        // if(AABBBuff[1 - (PhotonFrames % 2)].PhotonCount > 0 && id.x % 2 == 0 && id.y % 2 == 0) {
        //     float3 Dir2;
        //     float3 A = SampleLIPhoton(pixel_index, pdf, Dir2);
        //     LightDir = normalize(Dir2 * 122.0f + LightDir);
        //     // LightDir = normalize(Dir2);// * 12.0f + LightDir);
        // }

        LightInten = SelectedLight.Radiance;
    }

    Photon photon = {float4(0,0,0,0), float3(0,0,0), 1.0f, float3(0,0,0), 1.0f};
    float3 lightFlux = LightInten / float(mPGDDispatchX * mMaxDispatchY) * pdf;

    CurrentRay.origin = LightPos + 0.01f * LightDir;
    CurrentRay.direction = LightDir;
    RayHit bestHit;

    bool wasReflectedSpecular = false;
    bool reflectedDiffuse = false;
int i;


    float3 surfCol = 1;
    float scatDist = 999999;
    bool WasLast = false;
    [loop]for(i = 0; i < 7; i++) {
        RandomNumsWrite[id.xy] = uint4(i+1,0,0,0);
        photon.Flux = lightFlux * CurrentRay.throughput;
        FullTrace(CurrentRay, bestHit, pixel_index, id, i, surfCol, scatDist);

        // if(scatDist != 999999) photon.Flux *= exp(-bestHit.t * CalculateExtinction(1.0f - (surfCol), scatDist == 0.0f ? 1.0f : scatDist));
#ifdef COLOREDGLASS
        if(!CurrentRay.diffuseHit && i > 0 && (scatDist != 999999 || WasLast)) {
            CurrentRay.throughput *= exp(-bestHit.t * CalculateExtinction(1.0f - (surfCol), scatDist == 0.0f ? 1.0f : scatDist));
            photon.Flux *= exp(-bestHit.t * CalculateExtinction(1.0f - (surfCol), scatDist == 0.0f ? 1.0f : scatDist));
        }
#endif
            WasLast = scatDist != 999999;


        if(CurrentRay.terminated) break;

        photon.Pos = float4(CurrentRay.origin, 0);
        photon.Dir = CurrentRay.direction;
        reflectedDiffuse = CurrentRay.diffuseHit;

        [branch]if(reflectedDiffuse) {

            // {
            //     uint encTheta = (CurrentRay.Norm >> 16) & 0xFFFF;
            //     uint encPhi = CurrentRay.Norm & 0xFFFF;
            //     photon.faceNTheta = f16tof32(encTheta);
            //     photon.faceNPhi = f16tof32(encPhi);
            // }

            uint photonIndex = 0;
            uint photonBucketIndex = 0;

            float rndRoulette = random(94 + i, pixel_index).x;
            bool roulette = rndRoulette <= 0.05f;

            float cellScale = gCausticHashScaleFactor;
            int3 cell = int3(floor(photon.Pos.xyz * cellScale));
            uint bucketIdx = Photonhash(cell) & (mNumBuckets - 1);

            if (wasReflectedSpecular) {
                InterlockedAdd(gHashCounter[bucketIdx], 1u, photonIndex);
                //Insert photon
                float rnd = random(43 + i, pixel_index).x;
                float probability = 1.f / (photonIndex + 1);
                uint2 texIdx = uint2(bucketIdx / gBucketYExtent, bucketIdx % gBucketYExtent);
                float WSUM = luminance(gHashBucketFlux[texIdx].xyz) * (photonIndex+1) + luminance(photon.Flux.xyz);

                if (rnd * WSUM <= luminance(photon.Flux.xyz))
                // if (rnd <= probability)
                {
                    photon.InitialDirection = octahedral_32(LightDir);
                    gHashBucketPos[texIdx] = photon.Pos;
                    // gHashBucketFlux[texIdx] = float4(( id.x % 2 == 0 && id.y % 2 == 0) ? photon.Flux : 0, 1);//(WSUM / max((photonIndex+1) * luminance(photon.Flux.xyz), 1e-7)));
                    gHashBucketFlux[texIdx] = float4(photon.Flux, (WSUM / max((photonIndex+1) * luminance(photon.Flux.xyz), 1e-7)));
                    gHashBucketDir[texIdx] = float4(photon.Dir, asfloat(bucketIdx));

                }
            }      
            break;

        } else if(i == 0) {
            float4x4 MeshTransformInverse = _MeshData[bestHit.mesh_id].W2L;
            TrianglePos CurTri = triangle_get_positions(bestHit.triangle_id);
            MeshTransformInverse = inverse(MeshTransformInverse);
            float3 a0 = mul(MeshTransformInverse, float4(CurTri.pos0, 1)).xyz;
            float3 a1 = mul(MeshTransformInverse, float4(CurTri.pos0 + CurTri.posedge1, 1)).xyz;
            float3 a2 = mul(MeshTransformInverse, float4(CurTri.pos0 + CurTri.posedge2, 1)).xyz;

            VisTexB[equirectDirectionToUv(LightDir) * float2(CDFWIDTH,CDFHEIGHT) + 0.5f + GetLightOffset(Index)] = float4(VisTexB[equirectDirectionToUv(LightDir) * float2(CDFWIDTH,CDFHEIGHT) + 0.5f + GetLightOffset(Index)].xyz + float3(bestHit.t / clamp(AreaOfTriangle(a0, a1, a2), 0.000001f, 1222.0f), 1, luminance(lightFlux / (SelectedLight.Type == DIRECTIONALLIGHT ? 1.0f : (1)))), Index);
            // for(int j = 0; j < 3; j++) {
            //     InterlockedMax(AABBBuff[PhotonFrames % 2].BBMax[j], FloatToUint(CurrentRay.origin[j]));
            //     InterlockedMin(AABBBuff[PhotonFrames % 2].BBMin[j], FloatToUint(CurrentRay.origin[j]));
            //     InterlockedAdd(AABBBuff[PhotonFrames % 2].AveragedCenter[j], CurrentRay.origin[j] * 1e3f);
            // }
                InterlockedAdd(AABBBuff[PhotonFrames % 2].PhotonCount, 1);
        }

        const float rrVal = luminance(CurrentRay.throughput);
        const float prob = max(0.f, 1.f - rrVal);
        float rnd = random(43 + i, pixel_index).y;
        if (rnd < prob) break;
        else CurrentRay.throughput /= (1.f - prob);

        // if(i == 0) _DebugTex[id.xy] =  TempMat.specTrans == 1;//float4(photon.Flux, 1);//float4(CurrentRay.throughput, 1);
        if(i == 0) wasReflectedSpecular = !reflectedDiffuse;
        wasReflectedSpecular = wasReflectedSpecular && !reflectedDiffuse;
    }
}
Texture2D<float4> ThroughputTex;
Texture2D<float4> ViewDirTex;

bool hitSphere(const float3 center, const float radius, const float3 p)
{
    float3 radiusTest = p - center;
    radiusTest = radiusTest * radiusTest;
    float radiusTestF = radiusTest.x + radiusTest.y + radiusTest.z;
    if (radiusTestF < radius * radius)
        return true;
    return false;
}

float3 photonContribution(float3 Norm, float3 Pos, uint hash, inout int TotPhotCount)
{
    //get caustic or global photon
    uint photonCount = gHashCounter[hash];
    TotPhotCount += photonCount;
    float radius = gCausticRadius;// / ((float)max(min(photonCount-3,5),1));
    uint2 texIdx = uint2(hash / gBucketYExtent, hash % gBucketYExtent);
    float4 photonPos = gHashBucketPos[texIdx];
    float4 photonDir = gHashBucketDir[texIdx];
    float4 photonFlux = gHashBucketFlux[texIdx];

    //Do face normal test if enabled
    // if(kUsePhotonFaceNormal){
    //     //Sperical to cartesian
    //     float sinTheta = sin(photonFlux.w);
    //     float3 photonFaceN = float3(cos(photonDir.w) * sinTheta, cos(photonFlux.w), sin(photonDir.w) * sinTheta);
    //     photonFaceN = normalize(photonFaceN);
    //     float3 faceN = dot(sd.V, sd.faceN) > 0 ? sd.faceN : -sd.faceN;
    //     //Dot product has to be negative (View dir points to surface)
    //     if(dot(faceN, photonFaceN) < 0.9f)
    //         return float3(0);
    // }
    
    //Radius test
    if (!hitSphere(photonPos.xyz, radius, Pos) || photonCount == 0)
        return 0;
    
    
    float NdotL = dot(Norm, -photonDir.xyz);
    float3 radiance = 0;
    if(NdotL > kMinCosTheta){
        // let bsdf = gScene.materials.getBSDF(sd, lod);
        // float3 f_r = bsdf.eval(sd, -photonDir.xyz,sg) / NdotL;
#ifdef ACCURATECAUSTICS
        radiance = rcp(NdotL) * photonFlux.xyz * photonCount * photonFlux.w * ((float)max(min(photonCount-3,5),1));
#else
        radiance = 4.0f * photonFlux.xyz * photonCount * photonFlux.w ;//* ((float)max(min(photonCount-3,5),1));
#endif
    }
    return radiance;
}


float3 collectPhotons(float3 Norm, float3 Pos, inout int TotPhotCount)
{
    float3 radiance = 0;
    
    
    float radius = gCausticRadius;
    float scale = gCausticHashScaleFactor;
    int3 gridCenter = int3(floor(Pos * scale));
    int gridRadius = int(ceil(radius * scale));
    //Loop over whole hash grid

    for (int z = gridCenter.z - gridRadius; z <= gridCenter.z + gridRadius; z++){
        for (int y = gridCenter.y - gridRadius; y <= gridCenter.y + gridRadius; y++){
            for (int x = gridCenter.x - gridRadius; x <= gridCenter.x + gridRadius; x++)
            {
                uint b = Photonhash(int3(x, y, z)) & (mNumBuckets - 1);
                radiance += photonContribution(Norm, Pos, b, TotPhotCount);        
            }
        }
    }
    return radiance;
}


Texture2D<uint4> PrimaryTriangleInfo;
#pragma kernel kernel_collect
[numthreads(16, 16, 1)]
void kernel_collect(uint3 id : SV_DispatchThreadID, int3 GT : SV_GroupID) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    int pixel_index = id.x + id.y * screen_width;

     float3 viewVec = -ViewDirTex[id.xy].xyz;
    float4 thp = ThroughputTex[id.xy];
    float3 Pos;
    float3 Norm;
    CalcPosNorm(PrimaryTriangleInfo[id.xy], Pos, Norm);
    float3 radiance = 0;

    int PhotCount = 0;
    float3 causticRadiance = collectPhotons(-Norm, Pos, PhotCount);
    float w = 1.0f / (PI * gCausticRadius * gCausticRadius); //make this a constant
    radiance += w * causticRadiance;
    
    radiance *= thp;

    // float3 axis = equirectUvToDirection(float2(1.0f, 0.5f));//float3(0,1,0);
    // float sharpness = 12.001f;
    // float3 LightDir = SampleSphericalGaussian(axis, sharpness, random(12, pixel_index));

    // _DebugTex[equirectDirectionToUv(LightDir) * float2(screen_width, screen_height)] = 1;

    GlobalColors[pixel_index].Direct = radiance;
    GlobalColors[pixel_index].Indirect = 0;
    GlobalColors[pixel_index].PrimaryNEERay = 0;
    // float3 res = (GetBounceData(GlobalColors[pixel_index].MetRoughIsSpec) == 1) ? (GlobalColors[pixel_index].Data.xyz + pow(unpackRGBE(GlobalColors[pixel_index].PrimaryNEERay),2.2f)) : (((float)PartialRenderingFactor) * ((radiance * 3.0f + GlobalColors[pixel_index].Direct + GlobalColors[pixel_index].Indirect) * GlobalColors[pixel_index].Data.xyz) + pow(unpackRGBE(GlobalColors[pixel_index].PrimaryNEERay),2.2f));

    // Result[id.xy] = float4(res, 1);

}