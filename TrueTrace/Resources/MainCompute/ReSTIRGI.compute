#include "../GlobalDefines.cginc"

#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "CommonData.cginc"
#include "Materials.cginc"

Texture2D<float2> MotionVectors;


#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
#ifdef ReSTIRAdvancedValidation
inline float VisabilityCheck(SmallerRay ray, float dist) {
#else 
inline bool VisabilityCheck(SmallerRay ray, float dist) {
#endif
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        while(true) {
            q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
            while(q.Proceed()){}
            
            if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) {

                    float u = q.CommittedTriangleBarycentrics().y;
                    float v = q.CommittedTriangleBarycentrics().x;
                    int2 Indexes = int2(q.CommittedInstanceID(), q.CommittedGeometryIndex());
                    int triangle_id = q.CommittedPrimitiveIndex();
                    #if defined(IgnoreBackfacing) || defined(AdvancedAlphaMapped) || defined(IgnoreGlassShadow) || defined(AdvancedBackground)
                        int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
                        triangle_id += triangleOffset;
                        int mesh_id = MeshOffsets[Indexes.x].y;
                        int MaterialIndex = (_MeshData[mesh_id].MaterialOffset + AggTrisA[triangle_id].MatDat);
                        if(GetFlag(_Materials[MaterialIndex].Tag, IsBackground) || GetFlag(_Materials[MaterialIndex].Tag, ShadowCaster))  {myRay.TMin = q.CommittedRayT() + NormalOffset; continue;} 
                    #endif
                    #ifdef AdvancedAlphaMapped
                        if(_Materials[MaterialIndex].MatType == CutoutIndex) {
                            float2 BaseUv = TOHALF(AggTrisA[triangle_id].tex0) * (1.0f - u - v) + TOHALF(AggTrisA[triangle_id].texedge1) * u + TOHALF(AggTrisA[triangle_id].texedge2) * v;
                            if(_Materials[MaterialIndex].AlphaTex.x > 0)
                                if(SampleTexture(BaseUv, SampleAlpha, _Materials[MaterialIndex]).x < _Materials[MaterialIndex].AlphaCutoff) {myRay.TMin = q.CommittedRayT() + NormalOffset; continue;}
                        }
                    #endif
                    #ifdef IgnoreBackfacing
                        TrianglePos tri = triangle_get_positions(triangle_id);
                        if(_Materials[MaterialIndex].specTrans != 1 && dot(normalize(cross(normalize(tri.posedge1), normalize(tri.posedge2))), mul((float3x3)_MeshData[mesh_id].W2L, ray.direction)) <= 0) {myRay.TMin = q.CommittedRayT() + NormalOffset; continue;}
                    #endif
                    #ifdef IgnoreGlassShadow
                        if(_Materials[MaterialIndex].specTrans == 1) {
                            myRay.TMin = q.CommittedRayT() + NormalOffset; 
                            continue;
                        }
                    #endif


        #ifdef ReSTIRAdvancedValidation
                return q.CommittedRayT();
            }
            return dist;
        #else
                return false;
            }
            return true;
        #endif
        }
    #else
#ifdef ReSTIRAdvancedValidation
    Closest_Hit_Compute(ray, dist);
    return dist;
#else
    return VisabilityCheckCompute(ray, dist);
#endif
    #endif
}

#pragma kernel ReSTIRGIKernel


float IndirectBoost;
bool UseReSTIRGITemporal;
bool UseReSTIRGISpatial;
bool DoReSTIRGIConnectionValidation;
int ReSTIRGITemporalMCap;

struct RadianceData
{
    float3 Color;
    float Wsum;
    float M;
    float W;
};

struct RayData2
{
    uint OriginNormal;
    // uint FrameAccum;
    // uint pixel_index;
    // uint Case;
};

struct ReservoirStruct
{
    uint2 MergedCoord;
    
    RadianceData Radiance;
    RayData2 Ray;
};

inline uint PackDirection24bit(float3 Direction)
{
    Direction = Direction * 0.5 + 0.5;
    uint DirectionX = uint(Direction.x * 255.0f + 0.5f) & 0xFF;
    uint DirectionY = uint(Direction.y * 255.0f + 0.5f) & 0xFF;
    uint DirectionZ = uint(Direction.z * 255.0f + 0.5f) & 0xFF;
    
    return (DirectionX << 16) | (DirectionY << 8) | (DirectionZ << 0);
}

inline float3 UnpackDirection24bit(uint DirectionPacked)
{
    float3 Direction;
    Direction.x = float((DirectionPacked >> 16) & 0xFF) / 255.0f;
    Direction.y = float((DirectionPacked >>  8) & 0xFF) / 255.0f;
    Direction.z = float((DirectionPacked >>  0) & 0xFF) / 255.0f;
    Direction = Direction * 2 - 1;

    return Direction;
}

inline uint PackTonemappedColor24bit(float3 Color)
{
    Color = Color * rcp(max(max(Color.r, Color.g), Color.b) + 1.0f);
    uint RadianceR = uint(Color.r * 255.0f + 0.5f) & 0xFF;
    uint RadianceG = uint(Color.g * 255.0f + 0.5f) & 0xFF;
    uint RadianceB = uint(Color.b * 255.0f + 0.5f) & 0xFF;

    return (RadianceR << 16) | (RadianceG << 8)  | (RadianceB << 0);
}

inline float3 UnpackTonemappedColor24bit(uint ColorPacked)
{
    float3 Color;
    Color.r = ((ColorPacked >> 16) & 0xFF) / 255.0f;
    Color.g = ((ColorPacked >>  8) & 0xFF) / 255.0f;
    Color.b = ((ColorPacked >>  0) & 0xFF) / 255.0f;
    
    return Color * rcp(1.0 - max(max(Color.r, Color.g), Color.b)); 
}

inline uint2 PackRadianceData(RadianceData Radiance)
{
    uint W = f32tof16(Radiance.W);      
    uint M = f32tof16(Radiance.M);      
    uint PackedMW = (W << 16) | (M << 0);
    uint PackedColor = packRGBE(Radiance.Color);
    
    return uint2(PackedColor, PackedMW);
}


inline void UnpackRadianceData(uint2 RadianceDataPacked, float3 Diffuse, inout RadianceData Radiance)
{
    Radiance.Color = unpackRGBE(RadianceDataPacked.x);
    Radiance.W = f16tof32(RadianceDataPacked.y >> 16);
    Radiance.M = f16tof32(RadianceDataPacked.y >> 0);
    Radiance.Wsum = Radiance.W * Radiance.M * luminance(Radiance.Color * Diffuse);
}


// ------------------------ RESERVOIRStruct PACKING FUNCTIONS-----------------------


inline uint2 PackRayData(RayData2 Ray)
{

    uint OriginNormalPacked = Ray.OriginNormal;
    // uint FrameCasePacked = (Ray.FrameAccum & 0x00FFFFFF) | (Ray.Case << 24);

    return uint2(OriginNormalPacked, 0);
}





inline bool ReservoirUpdate(uint2 SampleCoord, float3 SampleColor, float SampleW, float SampleM, inout ReservoirStruct Reservoir, float Random, uint OrigNorm)
{
    
    Reservoir.Radiance.Wsum += SampleW;
    Reservoir.Radiance.M += SampleM;
    
    if (Random * Reservoir.Radiance.Wsum <= SampleW)
    {   
        Reservoir.Radiance.Color = SampleColor;
        Reservoir.Ray.OriginNormal = OrigNorm;
        Reservoir.MergedCoord = SampleCoord;
        return true;
    }
    
    return false;
}


inline bool ReservoirUpdate(uint2 SampleCoord, float3 SampleColor, float SampleW, float SampleM, inout RadianceData Reservoir, float Random)
{
    
    Reservoir.Wsum += SampleW;
    Reservoir.M += SampleM;
    
    if (Random * Reservoir.Wsum <= SampleW)
    {   
        Reservoir.Color = SampleColor;
        return true;
    }
    
    return false;
}


// Merges central reservoirStruct with a temporal neighbour (Radiance & Ray datas are exhanged) loaded externally
inline bool ReservoirMergeTemporal(uint2 SampleCoord, uint4 SampleReservoirPacked, uint ArrayIndex, float SampleWeight, float3 Diffuse, float Random, inout ReservoirStruct ReservoirStruct, float ExtraPacker = 1)
{
    RadianceData SampleRadiance;
   
    UnpackRadianceData(SampleReservoirPacked.xy, Diffuse, SampleRadiance);
    SampleRadiance.Wsum = SampleRadiance.W * ExtraPacker * SampleRadiance.M * luminance(SampleRadiance.Color * Diffuse);

    SampleRadiance.Wsum *= SampleWeight;
    SampleRadiance.M *= SampleWeight;
    
    return ReservoirUpdate(SampleCoord, SampleRadiance.Color, SampleRadiance.Wsum, SampleRadiance.M, ReservoirStruct, Random, SampleReservoirPacked.z);
}

// Merges central reservoirStruct with a temporal neighbour (Radiance & Ray datas are exhanged) loaded externally
inline bool ReservoirMergeTemporalNEE(uint2 SampleCoord, uint2 SampleReservoirPacked, uint ArrayIndex, float SampleWeight, float3 Diffuse, float Random, inout RadianceData ReservoirStruct, float ExtraPacker = 1)
{
    RadianceData SampleRadiance;
   
    UnpackRadianceData(SampleReservoirPacked.xy, Diffuse, SampleRadiance);
    SampleRadiance.Wsum = SampleRadiance.W * ExtraPacker * SampleRadiance.M * luminance(SampleRadiance.Color * Diffuse);

    SampleRadiance.Wsum *= SampleWeight;
    SampleRadiance.M *= SampleWeight;
    
    return ReservoirUpdate(SampleCoord, SampleRadiance.Color, SampleRadiance.Wsum, SampleRadiance.M, ReservoirStruct, Random);
}


// Empty RadianceData initialization
inline void RadianceDataInitialize(out RadianceData Radiance)
{
    Radiance.Color = 0;
    Radiance.Wsum = 0;
    Radiance.M = 0;
    Radiance.W = 0;
}

inline void RayDataInitialize(out RayData2 Ray)
{
    Ray.OriginNormal = 0;
    // Ray.FrameAccum = 0;
    // Ray.pixel_index = 0;
    // Ray.Case = 0;
}


// Empty reservoirStruct initialization
inline void ReservoirInitialize(uint2 Coord, out ReservoirStruct ReservoirStruct)
{
    ReservoirStruct.MergedCoord = Coord;
    
    RadianceDataInitialize(ReservoirStruct.Radiance);
    RayDataInitialize(ReservoirStruct.Ray);
}


inline bool ReservoirMergeSpatialNEE(uint2 SampleCoord, uint2 SampleReservoirPacked, float SampleWeight, float3 Diffuse, inout RadianceData ReservoirStruct, float Random, float ExtraPacker = 1)
{
    RadianceData SampleRadiance;
    UnpackRadianceData(SampleReservoirPacked, Diffuse, SampleRadiance);
    SampleRadiance.Wsum = SampleRadiance.W * ExtraPacker * luminance(SampleRadiance.Color * Diffuse);

    return ReservoirUpdate(SampleCoord, SampleRadiance.Color, SampleRadiance.Wsum, SampleRadiance.M, ReservoirStruct, Random);
}

inline bool ReservoirMergeSpatial(uint2 SampleCoord, uint4 SampleReservoirPacked, float SampleWeight, float3 Diffuse, inout ReservoirStruct ReservoirStruct, float Random, float ExtraPacker = 1)
{
    RadianceData SampleRadiance;
    UnpackRadianceData(SampleReservoirPacked, Diffuse, SampleRadiance);
    SampleRadiance.Wsum = SampleRadiance.W * ExtraPacker * luminance(SampleRadiance.Color * Diffuse);

    // SampleRadiance.Wsum *= SampleWeight;
    // SampleRadiance.M *= SampleWeight;
    
    return ReservoirUpdate(SampleCoord, SampleRadiance.Color, SampleRadiance.Wsum, SampleRadiance.M, ReservoirStruct, Random, SampleReservoirPacked.z);
}
int2 permutationSample(int2 samplePos, int2 jitter, uint sampleIndex) {
    int2 result = samplePos;
    uint sampleSeed = (frames_accumulated + sampleIndex) & 3u;
    uint2 sequenceA = uint2(3u - sampleSeed, 1u + sampleSeed);
    uint2 sequenceB = uint2(sequenceA.x ^ sampleSeed, sequenceA.y ^ sampleSeed) & 3u;
    if(sampleIndex > 0) {
        result = (result + jitter) ^ sequenceA;
        result = (result + jitter) ^ sequenceB;
        result -= jitter;
    }
    return result;
}

inline uint UnpackCase(uint4 RayDataPacked)
{
    return RayDataPacked.w >> 24;
}


Texture2D<half2> Gradient;
RWTexture2D<half2> GradientWrite;
#define KernelSize 8
 int RandOffset;   
[numthreads(KernelSize, KernelSize, 1)]
void ReSTIRGIKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    const int pixel_index = id.x + id.y * screen_width;

    const float2 UV = id.xy / float2(screen_width, screen_height);
    SmallerRay CameraRay = CreateCameraRay(id.xy / float2(screen_width, screen_height) * 2.0f - 1.0f);
    if(DoPanorama) {
        float2 jitter = ((random(0, pixel_index) - 0.5));
        if(OIDNGuideWrite) jitter = 0;
        float2 uv = float2((id.xy + jitter) / float2(screen_width, screen_height));
        uv.y = 1.0f - uv.y;
        uv.x = (uv.x * (Segment.y - Segment.x)) + Segment.x;
        uv.x = 1.0f - uv.x;

        CameraRay = CreateRay(mul(CamToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz + NearPlane * normalize(equirectUvToDirection(uv)), normalize(equirectUvToDirection(uv)));
    }


    const float4 GBuffer = ScreenSpaceInfoRead[id.xy];
    const int MatIndex = (asuint(GBuffer.w) << 4) >> 4;
    const uint Case = (asuint(GBuffer.w) << 1) >> 30;
    const float3 GeomNorm = i_octahedral_32(asuint(GBuffer.x));
    const float3 SurfNorm = i_octahedral_32(asuint(GBuffer.y));
    float3 PrimaryHitPosition = LoadSurfaceInfo(id.xy);

    const ColData CenterCol = GlobalColors[pixel_index];
    float3 Data = CenterCol.Data;
    uint4 WorldPos = WorldPosC[id.xy];
    float4 NEEPos = NEEPosA[id.xy];
    MaterialData SurfaceMat = _Materials[MatIndex];
    uint Flag = CenterCol.Flags;
    SurfaceMat.surfaceColor = max(unpackRGBE(Flag), 0.005f);
    uint MetRoughIsSpec = CenterCol.MetRoughIsSpec;
    SurfaceMat.roughness = FromColorSpecPacked(MetRoughIsSpec).y;
    SurfaceMat.metallic = FromColorSpecPacked(MetRoughIsSpec).x;

    ReservoirStruct RunningReservoirB;
    RadianceData RunningReservoirC;
    ReservoirInitialize(id.xy, RunningReservoirB);
    RadianceDataInitialize(RunningReservoirC);
    
    const float3x3 TanMat = build_rotated_ONB(SurfNorm, SurfaceMat.anisotropicRotation);

    float3 bsdf;
    float3 NEEbsdf;
    float pdf;
    float3 TempWorldPos;
    float3 SampleNorm;
    CalcPosNorm(WorldPos, TempWorldPos, SampleNorm);
    bool Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(TempWorldPos - PrimaryHitPosition), SurfNorm, pdf, bsdf, TanMat, pixel_index);
    Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPosA[id.xy].xyz - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf, pixel_index, TanMat);

    RunningReservoirB.Radiance.Color = (CenterCol.Indirect * IndirectBoost + CenterCol.Direct);
    RunningReservoirB.Radiance.Wsum = luminance((CenterCol.Indirect * IndirectBoost + CenterCol.Direct) * bsdf);
    RunningReservoirB.Radiance.W = 1;
    RunningReservoirB.Radiance.M = 1;
    // RunningReservoirB.Ray.Case = Case;
    // RunningReservoirB.Ray.pixel_index = pixel_index;
    RunningReservoirB.Ray.OriginNormal = PackDirection24bit(SampleNorm) | (1 << 30);



    RunningReservoirC.Color = pow(unpackRGBE(CenterCol.PrimaryNEERay),2.2f);
    RunningReservoirC.Wsum = luminance(pow(unpackRGBE(CenterCol.PrimaryNEERay),2.2f) * NEEbsdf);
    RunningReservoirC.W = 1;
    RunningReservoirC.M = 1;
    // RunningReservoirC.Ray.pixel_index = pixel_index;
    // RunningReservoirC.Ray.FrameAccum = frames_accumulated;


     float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, UV, 0).xy;
    int2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
  


    float4 PrevGBuffer = PrevScreenSpaceInfo[prevIndex];

    float ShadowGuidanceWeight = !plane_distance_disocclusion_check(PrimaryHitPosition, LoadSurfaceInfoPrevInCurrent(prevIndex), GeomNorm);// abs(ReservoirCenterOcclusion - ReservoirSampleOcclusion) / max(ReservoirCenterOcclusion, ReservoirSampleOcclusion) < 0.1f;
    // float ShadowGuidanceWeight = exp(-abs(PrevGBuffer.z - GBuffer.z)) > 0.9f;

    ShadowGuidanceWeight *= max(dot(GeomNorm, i_octahedral_32(asuint(PrevGBuffer.x))), 0);

    



        if(PrevGBuffer.z <= 0 || any(prevIndex >= int2(screen_width, screen_height) || prevIndex < 0) || (!((ReservoirB[int3(prevIndex, 0)].z >> 30) & 0x1))) {
            RunningReservoirB.Radiance.W = 1;
            RunningReservoirB.Radiance.M = 1;
            if(!any(prevIndex >= int2(screen_width, screen_height) || prevIndex < 0)) {
                float3 NEEbsdf2;
                Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPosB[prevIndex].xyz - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf2, pixel_index, TanMat);
                bool Merged4 = ReservoirMergeTemporalNEE(id.xy, ReservoirB[int3(prevIndex, 1)], 0, ShadowGuidanceWeight, NEEbsdf2, randomNEE(128, pixel_index).y, RunningReservoirC, 1);
                if(Merged4) NEEPos = NEEPosB[prevIndex];
                Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPos.xyz - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf, pixel_index, TanMat);

            } else {
                RunningReservoirC.W = 1;
                RunningReservoirC.M = 1;                
            }
        } else {
            float3 NEEbsdf2;
            float3 bsdf2;
            Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(CalcPos(WorldPosB[prevIndex]) - PrimaryHitPosition), SurfNorm, pdf, bsdf2, TanMat, pixel_index);
            Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPosB[prevIndex].xyz - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf2, pixel_index, TanMat);

            bool Merged3 = ReservoirMergeTemporal(id.xy, ReservoirB[int3(prevIndex, 0)], 0, ShadowGuidanceWeight, bsdf2, randomNEE(128, pixel_index).x, RunningReservoirB, 1);
            bool Merged4 = ReservoirMergeTemporalNEE(id.xy, ReservoirB[int3(prevIndex, 1)], 0, ShadowGuidanceWeight, NEEbsdf2, randomNEE(128, pixel_index).y, RunningReservoirC, 1);
            if(Merged3) WorldPos = WorldPosB[prevIndex];
            if(Merged4) NEEPos = NEEPosB[prevIndex];
            Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(CalcPos(WorldPos) - PrimaryHitPosition), SurfNorm, pdf, bsdf, TanMat, pixel_index);
            Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPos.xyz - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf, pixel_index, TanMat);
        }



    int MaxM = ReSTIRGITemporalMCap;
    // if(Case == 3) MaxM = min(5, MaxM);
    if (RunningReservoirB.Radiance.M > MaxM) {
        RunningReservoirB.Radiance.Wsum *= MaxM / RunningReservoirB.Radiance.M;
        RunningReservoirB.Radiance.M = MaxM; 
    }

    MaxM /= 2;
    MaxM = max(MaxM, 1);
    if (RunningReservoirC.M > MaxM) {
        RunningReservoirC.Wsum *= MaxM / RunningReservoirC.M;
        RunningReservoirC.M = MaxM; 
    }


    RunningReservoirB.Radiance.W = clamp(RunningReservoirB.Radiance.Wsum / max((RunningReservoirB.Radiance.M) * luminance(RunningReservoirB.Radiance.Color * bsdf), 1e-7), 0, 10000.0f);
    RunningReservoirC.W = clamp(RunningReservoirC.Wsum / max((RunningReservoirC.M) * luminance(RunningReservoirC.Color * NEEbsdf), 1e-7), 0, 10000.0f);



    ReservoirA[int3(id.xy,0)] = uint4(PackRadianceData(RunningReservoirB.Radiance).xy, PackRayData(RunningReservoirB.Ray).xy);//, PackRayData(RunningReservoirB.Ray).xy);
    ReservoirA[int3(id.xy,1)] = uint4(PackRadianceData(RunningReservoirC).xy,0,0);
    WorldPosA[id.xy] = WorldPos;
    NEEPosA[id.xy] = NEEPos;
    #ifdef ReSTIRAdvancedValidation
        if(DoReSTIRGIConnectionValidation) GradientWrite[id.xy] = (any(prevIndex >= int2(screen_width, screen_height) || prevIndex < 0)) ? 1 : Gradient[prevIndex];
    #endif
}

inline float2 vogelDiskSample(int i, int num_samples, float r_offset, float phi_offset) {
    float r = sqrt((float(i) + 0.07f + r_offset*0.93f) / float(num_samples));
    float phi = float(i) * 2.399963229728f + 2.0f * PI * phi_offset;
    float sinc;
    sincos(phi, sinc, phi);
    return r * float2(sinc,phi);
}
int CurPass;
#pragma kernel ReSTIRGISpatial

[numthreads(KernelSize, KernelSize, 1)]
void ReSTIRGISpatial(uint3 id : SV_DispatchThreadID) {
 if(id.x >= screen_width || id.y >= screen_height) return;
    const int pixel_index = id.x + id.y * screen_width;

    const float4 GBuffer = ScreenSpaceInfoRead[id.xy];
    const int MatIndex = (asuint(GBuffer.w) << 4) >> 4;
    const float3 GeomNorm = i_octahedral_32(asuint(GBuffer.x));
    const float3 SurfNorm = i_octahedral_32(asuint(GBuffer.y));
    float3 PrimaryHitPosition = LoadSurfaceInfo(id.xy);
    SmallerRay CameraRay = CreateCameraRay(id.xy / float2(screen_width, screen_height) * 2.0f - 1.0f);
    [branch]if(DoPanorama) {
        float2 jitter = ((random(0, pixel_index) - 0.5));
        if(OIDNGuideWrite) jitter = 0;
        float2 uv = float2((id.xy + jitter) / float2(screen_width, screen_height));
        uv.y = 1.0f - uv.y;
        uv.x = (uv.x * (Segment.y - Segment.x)) + Segment.x;
        uv.x = 1.0f - uv.x;

        CameraRay = CreateRay(mul(CamToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz + NearPlane * normalize(equirectUvToDirection(uv)), normalize(equirectUvToDirection(uv)));
    }
    const ColData CenterCol = GlobalColors[pixel_index];
    const float3 Data = CenterCol.Data;
    uint MetRoughIsSpec = CenterCol.MetRoughIsSpec;
    MaterialData SurfaceMat = _Materials[MatIndex];
    const uint Flag = CenterCol.Flags;
    const uint Case = (asuint(GBuffer.w) << 1) >> 30;
    SurfaceMat.surfaceColor = unpackRGBE(Flag);
    SurfaceMat.roughness = FromColorSpecPacked(MetRoughIsSpec).y;
    SurfaceMat.metallic = FromColorSpecPacked(MetRoughIsSpec).x;
    float4 WorldPos = WorldPosB[id.xy];
    float4 NEEPos = NEEPosB[id.xy];

    ReservoirStruct RunningReservoirB;
    ReservoirStruct RunningReservoirBCannon;
    RadianceData RunningReservoirC;
    RadianceData RunningReservoirCCannon;
    RadianceData RunningReservoirCCopy;
    ReservoirStruct RunningReservoirBCopy;
    ReservoirInitialize(id.xy, RunningReservoirB);
    ReservoirInitialize(id.xy, RunningReservoirBCannon);
    ReservoirInitialize(id.xy, RunningReservoirBCopy);
    RadianceDataInitialize(RunningReservoirC);
    RadianceDataInitialize(RunningReservoirCCannon);
    RadianceDataInitialize(RunningReservoirCCopy);

    float3 CenterRayDir = CalcPos(WorldPos) - PrimaryHitPosition;
    float3 CenterNEERayDir = NEEPos - PrimaryHitPosition;
    float3 bsdf;
    float3 NEEbsdf;
    float pdf;
    const float3x3 TangSpace = build_rotated_ONB(SurfNorm, SurfaceMat.anisotropicRotation);
    bool Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(CenterRayDir), SurfNorm, pdf, bsdf, TangSpace, pixel_index);
    Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(CenterNEERayDir), SurfNorm, pdf, NEEbsdf, pixel_index, TangSpace);
    const float3 CannonBSDF = bsdf;
    const float3 CannonNEEBSDF = NEEbsdf;

    const uint4 PackedCenterResA = ReservoirB[int3(id.xy,0)];
    const uint2 PackedCenterResB = ReservoirB[int3(id.xy,1)];
    UnpackRadianceData(PackedCenterResA.xy, bsdf, RunningReservoirBCannon.Radiance);
    UnpackRadianceData(PackedCenterResB.xy, NEEbsdf, RunningReservoirCCannon);


    #ifdef ReSTIRAdvancedValidation
        float centerValid = Gradient[id.xy].x;
        float centerValidNEE = Gradient[id.xy].y;
    #endif

    const float ReservoirCenterOcclusion = ScreenSpaceInfoRead[id.xy].z;
    float Mc = 1;
    float McNEE = 1;
    float3 CenterNorm = UnpackDirection24bit(PackedCenterResA.z);
    float3 SampleRayDir;
    float3 SampleNorm;
    float3 bsdf2;
    float3 NEEbsdf2;
    int K = 0;
    if(UseReSTIRGISpatial && Case != 3 && !(SurfaceMat.metallic == 1 && SurfaceMat.roughness == 0)) {
        int3 CellTapCoords[6];
        float3 GeomNorms[6];
        [loop]for (int i = 0; i < 6; i++) {        
            float2 RandOffsets = randomNEE(i + 12, pixel_index);
            int2 CellOffset = vogelDiskSample(i, 6, RandOffsets.y, 2.0f * PI * RandOffsets.x) * 42.0f;
            int2 CellTapCoord = id.xy + CellOffset;
            if(CellTapCoord.x < 0 || CellTapCoord.x >= screen_width) CellTapCoord.x = id.x - CellOffset.x;
            if(CellTapCoord.y < 0 || CellTapCoord.y >= screen_height) CellTapCoord.y = id.y - CellOffset.y;
            if(all(CellTapCoord == id.xy)) continue;
            if(asuint(ScreenSpaceInfoRead[CellTapCoord].w) == 0) continue;
#ifdef ReSTIRReflectionRefinement
            if(SurfaceMat.metallic > 0 && ((asuint(ScreenSpaceInfoRead[CellTapCoord].w) << 4) >> 4) != MatIndex) continue;
#endif
            float3 SampleGeomNorm = i_octahedral_32(asuint(ScreenSpaceInfoRead[CellTapCoord].x));
            float NormDiff = max(abs(dot(GeomNorm, SampleGeomNorm)), 0);
            if(NormDiff < 0.9f) continue;
            float ReservoirSampleOcclusion = ScreenSpaceInfoRead[CellTapCoord].z;
            float ShadowGuidanceWeight = !plane_distance_disocclusion_check(PrimaryHitPosition, LoadSurfaceInfo(CellTapCoord), GeomNorm);// abs(ReservoirCenterOcclusion - ReservoirSampleOcclusion) / max(ReservoirCenterOcclusion, ReservoirSampleOcclusion) < 0.1f;
            ShadowGuidanceWeight *= (ReservoirSampleOcclusion > 0 && ReservoirCenterOcclusion > 0);
            if(ShadowGuidanceWeight == 0) continue;
            GeomNorms[K] = SampleGeomNorm;
            CellTapCoords[K++] = int3(CellTapCoord, i);

        }

        [loop]for (int i2 = 0; i2 < K; i2++) {
            int i = CellTapCoords[i2].z;    
            int2 CellTapCoord = CellTapCoords[i2];
            float2 RandOffsets2 = randomNEE(i + 32, pixel_index);

            float3 SampleGeomNorm = GeomNorms[i2];
            float NormDiff = max(abs(dot(GeomNorm, SampleGeomNorm)), 0);
            float ShadowGuidanceWeight = 1;// abs(ReservoirCenterOcclusion - ReservoirSampleOcclusion) / max(ReservoirCenterOcclusion, ReservoirSampleOcclusion) < 0.1f;

            const uint4 PackedReservoirA = ReservoirB[int3(CellTapCoord,0)];
            const uint2 PackedReservoirB = ReservoirB[int3(CellTapCoord,1)];
            uint4 SampleWorldPos = WorldPosB[CellTapCoord];
            float4 SampleNEEPos = NEEPosB[CellTapCoord];
            SampleNorm = UnpackDirection24bit(PackedReservoirA.z);
            // if(!((PackedReservoirA.z >> 30) & 0x1)) continue;
            CalcPosOnly(SampleWorldPos, SampleRayDir);
            SampleRayDir -= PrimaryHitPosition;
            
            float3 SampleNEERayDir = SampleNEEPos - PrimaryHitPosition;
            Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(SampleRayDir), SurfNorm, pdf, bsdf2, TangSpace, pixel_index);
            Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(SampleNEERayDir), SurfNorm, pdf, NEEbsdf2, pixel_index, TangSpace);
            UnpackRadianceData(PackedReservoirA.xy, bsdf2, RunningReservoirBCopy.Radiance);
            UnpackRadianceData(PackedReservoirB.xy, NEEbsdf2, RunningReservoirCCopy);

            float RayDirWeight = 1;
            float RayDirWeight2 = 1;
                

            float Dist = length(SampleRayDir - CenterRayDir);
#ifdef ReSTIRReflectionRefinement
            RayDirWeight = lerp(exp(-120.0f * abs(dot(SampleRayDir, CenterRayDir))), 1, saturate((Case != 0) + SurfaceMat.roughness));
#endif
            [branch]if(Dist < 1.0f) {
                RayDirWeight = lerp(1.0f - exp(-120.0f * abs(dot(SampleRayDir, CenterRayDir))), 1, SurfaceMat.roughness);
                RayDirWeight *= pow(abs(dot(SampleNorm, CenterNorm)), 122.0f);
            }

            Dist = length(SampleNEERayDir - CenterNEERayDir);
            [branch]if(Dist < 1.0f) {
                RayDirWeight2 = lerp(1.0f - exp(-120.0f * abs(dot(SampleNEERayDir, CenterNEERayDir))), 1, SurfaceMat.roughness);
                // RayDirWeight *= pow(abs(dot(-normalize(SampleNEERayDir), -normalize(CenterNEERayDir))), 122.0f);
            }
            #ifdef ReSTIRAdvancedValidation
                [branch]if(DoReSTIRGIConnectionValidation) {
                    float2 Grad = Gradient[CellTapCoord];
                    RayDirWeight *= lerp(0.25f, 1.0f, saturate(exp2(-20.0f * abs(centerValid - Grad.x))));
                    RayDirWeight2 *= lerp(0.25f, 1.0f, saturate(exp2(-20.0f * abs(centerValidNEE - Grad.y))));
                }
            #endif

            // float Mi = 1;
            // float MiNEE = 1;
            // {

                    RayDirWeight *= ShadowGuidanceWeight * NormDiff;
                    RayDirWeight2 *= ShadowGuidanceWeight * NormDiff;

                float fx = RunningReservoirBCopy.Radiance.M * luminance(RunningReservoirBCopy.Radiance.Color * bsdf2);
                float gx = ((RunningReservoirBCannon.Radiance.M / 6.0f) * luminance(RunningReservoirBCannon.Radiance.Color * bsdf2));
                float ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                float Mi = max((fx / gx),0) * RayDirWeight;

                fx = RunningReservoirBCopy.Radiance.M * luminance(RunningReservoirBCannon.Radiance.Color * bsdf2);
                gx = ((RunningReservoirBCannon.Radiance.M / 6.0f) * luminance(RunningReservoirBCannon.Radiance.Color * CannonBSDF));
                ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                    Mc = Mc + (1.0f - max(fx / gx,0) * RayDirWeight);

                    fx = RunningReservoirCCopy.M * luminance(RunningReservoirCCopy.Color * NEEbsdf2);
                    gx = ((RunningReservoirCCannon.M / 6.0f) * luminance(RunningReservoirCCannon.Color * NEEbsdf2));
                ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                    float MiNEE = max(fx / gx,0) * RayDirWeight2;

                    fx = RunningReservoirCCopy.M * luminance(RunningReservoirCCannon.Color * NEEbsdf2);
                    gx = ((RunningReservoirCCannon.M / 6.0f) * luminance(RunningReservoirCCannon.Color * CannonNEEBSDF));
                ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                    McNEE = McNEE + (1.0f - max(fx / gx,0) * RayDirWeight2);
            // }

            bool MergedB = ReservoirMergeSpatial(CellTapCoord, PackedReservoirA, 1, bsdf2, RunningReservoirB, RandOffsets2.x, Mi);
            bool MergedC = ReservoirMergeSpatialNEE(CellTapCoord, PackedReservoirB, 1, NEEbsdf2, RunningReservoirC, RandOffsets2.y, MiNEE);
            [branch]if(MergedB) {
                WorldPos = SampleWorldPos;
                CenterRayDir = SampleRayDir;
                bsdf = bsdf2;
                CenterNorm = SampleNorm;
            }
            [branch]if(MergedC) {
                NEEPos = SampleNEEPos;
                CenterNEERayDir = SampleNEERayDir;
                NEEbsdf = NEEbsdf2;
            }
        }

    }
    bool Merged3 = ReservoirMergeSpatial(id.xy, PackedCenterResA, 1, CannonBSDF, RunningReservoirB, randomNEE(323, pixel_index).x, Mc);
    bool Merged4 = ReservoirMergeSpatialNEE(id.xy, PackedCenterResB, 1, CannonNEEBSDF, RunningReservoirC, randomNEE(323, pixel_index).y, McNEE);
    if(Merged3) WorldPos = WorldPosB[id.xy];
    if(Merged4) NEEPos = NEEPosB[id.xy];

    Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(CalcPos(WorldPos) - PrimaryHitPosition), SurfNorm, pdf, bsdf, TangSpace, pixel_index);
    Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPos - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf, pixel_index, TangSpace);

    RunningReservoirB.Radiance.W = clamp((luminance(RunningReservoirB.Radiance.Color * bsdf) == 0 ? 0 : (1.0f / (luminance(RunningReservoirB.Radiance.Color * bsdf)) * (1.0f / (1.0f + K))) * RunningReservoirB.Radiance.Wsum), 0, 10000.0f);// / max((RunningReservoirB.Radiance.M) * luminance(RunningReservoirB.Radiance.Color * bsdf), 1e-7) ;
    RunningReservoirC.W = clamp((luminance(RunningReservoirC.Color * NEEbsdf) == 0 ? 0 : (1.0f / (luminance(RunningReservoirC.Color * NEEbsdf)) * (1.0f / (1.0f + K))) * RunningReservoirC.Wsum), 0, 10000.0f);//RunningReservoirC.Radiance.Wsum / max((RunningReservoirC.Radiance.M) * luminance(RunningReservoirC.Radiance.Color * NEEbsdf), 1e-7) ;       

    WorldPosA[id.xy] = WorldPos;
    NEEPosA[id.xy] = NEEPos;
    ReservoirA[int3(id.xy,0)] = uint4(PackRadianceData(RunningReservoirB.Radiance).xy, PackRayData(RunningReservoirB.Ray).xy);
    ReservoirA[int3(id.xy,1)] = uint4(PackRadianceData(RunningReservoirC).xy,0,0);

}




#pragma kernel ReSTIRGISpatial2

[numthreads(KernelSize, KernelSize, 1)]
void ReSTIRGISpatial2(uint3 id : SV_DispatchThreadID) {
 if(id.x >= screen_width || id.y >= screen_height) return;
    const int pixel_index = id.x + id.y * screen_width;

    const float4 GBuffer = ScreenSpaceInfoRead[id.xy];
    const int MatIndex = (asuint(GBuffer.w) << 4) >> 4;
    const float3 GeomNorm = i_octahedral_32(asuint(GBuffer.x));
    const float3 SurfNorm = i_octahedral_32(asuint(GBuffer.y));
    float3 PrimaryHitPosition = LoadSurfaceInfo(id.xy);
    SmallerRay CameraRay = CreateCameraRay(id.xy / float2(screen_width, screen_height) * 2.0f - 1.0f);
    [branch]if(DoPanorama) {
        float2 jitter = ((random(0, pixel_index) - 0.5));
        if(OIDNGuideWrite) jitter = 0;
        float2 uv = float2((id.xy + jitter) / float2(screen_width, screen_height));
        uv.y = 1.0f - uv.y;
        uv.x = (uv.x * (Segment.y - Segment.x)) + Segment.x;
        uv.x = 1.0f - uv.x;

        CameraRay = CreateRay(mul(CamToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz + NearPlane * normalize(equirectUvToDirection(uv)), normalize(equirectUvToDirection(uv)));
    }
    const ColData CenterCol = GlobalColors[pixel_index];
    const float3 Data = CenterCol.Data;
    uint MetRoughIsSpec = CenterCol.MetRoughIsSpec;
    MaterialData SurfaceMat = _Materials[MatIndex];
    const uint Flag = CenterCol.Flags;
    const uint Case = (asuint(GBuffer.w) << 1) >> 30;
    SurfaceMat.surfaceColor = unpackRGBE(Flag);
    SurfaceMat.roughness = FromColorSpecPacked(MetRoughIsSpec).y;
    SurfaceMat.metallic = FromColorSpecPacked(MetRoughIsSpec).x;
    float4 WorldPos = WorldPosB[id.xy];
    float4 NEEPos = NEEPosB[id.xy];

    ReservoirStruct RunningReservoirB;
    ReservoirStruct RunningReservoirBCannon;
    RadianceData RunningReservoirC;
    RadianceData RunningReservoirCCannon;
    RadianceData RunningReservoirCCopy;
    ReservoirStruct RunningReservoirBCopy;
    ReservoirInitialize(id.xy, RunningReservoirB);
    ReservoirInitialize(id.xy, RunningReservoirBCannon);
    ReservoirInitialize(id.xy, RunningReservoirBCopy);
    RadianceDataInitialize(RunningReservoirC);
    RadianceDataInitialize(RunningReservoirCCannon);
    RadianceDataInitialize(RunningReservoirCCopy);

    float3 CenterRayDir = CalcPos(WorldPos) - PrimaryHitPosition;
    float3 CenterNEERayDir = NEEPos - PrimaryHitPosition;
    float3 bsdf;
    float3 NEEbsdf;
    float pdf;
    const float3x3 TangSpace = build_rotated_ONB(SurfNorm, SurfaceMat.anisotropicRotation);
    bool Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(CenterRayDir), SurfNorm, pdf, bsdf, TangSpace, pixel_index);
    Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(CenterNEERayDir), SurfNorm, pdf, NEEbsdf, pixel_index, TangSpace);
    
    const float3 CannonBSDF = bsdf;
    const float3 CannonNEEBSDF = NEEbsdf;

    const uint4 PackedCenterResA = ReservoirB[int3(id.xy,0)];
    const uint2 PackedCenterResB = ReservoirB[int3(id.xy,1)];
    UnpackRadianceData(PackedCenterResA.xy, bsdf, RunningReservoirBCannon.Radiance);
    UnpackRadianceData(PackedCenterResB.xy, NEEbsdf, RunningReservoirCCannon);


    #ifdef ReSTIRAdvancedValidation
        float centerValid = Gradient[id.xy].x;
        float centerValidNEE = Gradient[id.xy].y;
    #endif

    const float ReservoirCenterOcclusion = ScreenSpaceInfoRead[id.xy].z;
    float Mc = 1;
    float McNEE = 1;
    float3 CenterNorm = UnpackDirection24bit(PackedCenterResA.z);
    float3 SampleRayDir = 0;
    float3 SampleNorm;
    float3 bsdf2;
    float3 NEEbsdf2;
    int K = 0;
    if(UseReSTIRGISpatial && Case != 3 && !(SurfaceMat.metallic == 1 && SurfaceMat.roughness == 0)) {

        int3 CellTapCoords[5];
        float3 GeomNorms[5];
        [loop]for (int i = 0; i < 5; i++) {        
            float2 RandOffsets = randomNEE(i + 48, pixel_index);
            int2 CellOffset = vogelDiskSample(i, 5, RandOffsets.y, 2.0f * PI * RandOffsets.x) * 20.0f;
            int2 CellTapCoord = id.xy + CellOffset;
            if(CellTapCoord.x < 0 || CellTapCoord.x >= screen_width) CellTapCoord.x = id.x - CellOffset.x;
            if(CellTapCoord.y < 0 || CellTapCoord.y >= screen_height) CellTapCoord.y = id.y - CellOffset.y;
            if(all(CellTapCoord == id.xy)) continue;
            if(asuint(ScreenSpaceInfoRead[CellTapCoord].w) == 0) continue;

#ifdef ReSTIRReflectionRefinement
            if(SurfaceMat.metallic > 0 && ((asuint(ScreenSpaceInfoRead[CellTapCoord].w) << 4) >> 4) != MatIndex) continue;
#endif
            float3 SampleGeomNorm = i_octahedral_32(asuint(ScreenSpaceInfoRead[CellTapCoord].x));
            float NormDiff = max(abs(dot(GeomNorm, SampleGeomNorm)), 0);
            if(NormDiff < 0.9f) continue;
            float ReservoirSampleOcclusion = ScreenSpaceInfoRead[CellTapCoord].z;
            float ShadowGuidanceWeight = !plane_distance_disocclusion_check(PrimaryHitPosition, LoadSurfaceInfo(CellTapCoord), GeomNorm);// abs(ReservoirCenterOcclusion - ReservoirSampleOcclusion) / max(ReservoirCenterOcclusion, ReservoirSampleOcclusion) < 0.1f;
            ShadowGuidanceWeight *= (ReservoirSampleOcclusion > 0 && ReservoirCenterOcclusion > 0);
            if(ShadowGuidanceWeight == 0) continue;
            GeomNorms[K] = SampleGeomNorm;
            CellTapCoords[K++] = int3(CellTapCoord, i);

        }



        [loop]for (int i2 = 0; i2 < K; i2++) {        
          int i = CellTapCoords[i2].z;    
            int2 CellTapCoord = CellTapCoords[i2];
            float2 RandOffsets2 = randomNEE(i + 64, pixel_index);

            float3 SampleGeomNorm = GeomNorms[i2];
            float NormDiff = max(abs(dot(GeomNorm, SampleGeomNorm)), 0);
            float ShadowGuidanceWeight = 1;//!plane_distance_disocclusion_check(PrimaryHitPosition, CellPos[i2], GeomNorm);// abs(ReservoirCenterOcclusion - ReservoirSampleOcclusion) / max(ReservoirCenterOcclusion, ReservoirSampleOcclusion) < 0.1f;

            const uint4 PackedReservoirA = ReservoirB[int3(CellTapCoord,0)];
            const uint2 PackedReservoirB = ReservoirB[int3(CellTapCoord,1)];
            uint4 SampleWorldPos = WorldPosB[CellTapCoord];
            float4 SampleNEEPos = NEEPosB[CellTapCoord];
            SampleNorm = UnpackDirection24bit(PackedReservoirA.z);
            // if(!((PackedReservoirA.z >> 30) & 0x1)) continue;
            CalcPosOnly(SampleWorldPos, SampleRayDir);
            SampleRayDir -= PrimaryHitPosition;
            
            float3 SampleNEERayDir = SampleNEEPos - PrimaryHitPosition;
            Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(SampleRayDir), SurfNorm, pdf, bsdf2, TangSpace, pixel_index);
            Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(SampleNEERayDir), SurfNorm, pdf, NEEbsdf2, pixel_index, TangSpace);
            UnpackRadianceData(PackedReservoirA.xy, bsdf2, RunningReservoirBCopy.Radiance);
            UnpackRadianceData(PackedReservoirB.xy, NEEbsdf2, RunningReservoirCCopy);

            float RayDirWeight = 1;
            float RayDirWeight2 = 1;
                

            float Dist = length(SampleRayDir - CenterRayDir);
#ifdef ReSTIRReflectionRefinement
            RayDirWeight = lerp(exp(-120.0f * abs(dot(SampleRayDir, CenterRayDir))), 1, saturate((Case != 0) + SurfaceMat.roughness));
#endif
            [branch]if(Dist < 1.0f) {
                RayDirWeight = lerp(1.0f - exp(-120.0f * abs(dot(SampleRayDir, CenterRayDir))), 1, SurfaceMat.roughness);
                RayDirWeight *= pow(abs(dot(SampleNorm, CenterNorm)), 122.0f);
            }

            Dist = length(SampleNEERayDir - CenterNEERayDir);
            [branch]if(Dist < 1.0f) {
                RayDirWeight2 = lerp(1.0f - exp(-120.0f * abs(dot(SampleNEERayDir, CenterNEERayDir))), 1, SurfaceMat.roughness);
                // RayDirWeight *= pow(abs(dot(-normalize(SampleNEERayDir), -normalize(CenterNEERayDir))), 122.0f);
            }
            #ifdef ReSTIRAdvancedValidation
                if(DoReSTIRGIConnectionValidation) {
                    float2 Grad = Gradient[CellTapCoord];
                    RayDirWeight *= lerp(0.25f, 1.0f, saturate(exp2(-20.0f * abs(centerValid - Grad.x))));
                    RayDirWeight2 *= lerp(0.25f, 1.0f, saturate(exp2(-20.0f * abs(centerValidNEE - Grad.y))));
                }
            #endif

            // float Mi = 1;
            // float MiNEE = 1;
            // {

                RayDirWeight *= ShadowGuidanceWeight * NormDiff;
                RayDirWeight2 *= ShadowGuidanceWeight * NormDiff;

                float fx = RunningReservoirBCopy.Radiance.M * luminance(RunningReservoirBCopy.Radiance.Color * bsdf2);
                float gx = ((RunningReservoirBCannon.Radiance.M / 5.0f) * luminance(RunningReservoirBCannon.Radiance.Color * bsdf2));
                float ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                float Mi = max((fx / gx),0) * RayDirWeight;

                fx = RunningReservoirBCopy.Radiance.M * luminance(RunningReservoirBCannon.Radiance.Color * bsdf2);
                gx = ((RunningReservoirBCannon.Radiance.M / 5.0f) * luminance(RunningReservoirBCannon.Radiance.Color * CannonBSDF));
                ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                Mc = Mc + (1.0f - max((fx / gx),0) * RayDirWeight);




                fx = RunningReservoirCCopy.M * luminance(RunningReservoirCCopy.Color * NEEbsdf2);
                gx = ((RunningReservoirCCannon.M / 5.0f) * luminance(RunningReservoirCCannon.Color * NEEbsdf2));
                ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                float MiNEE = max(fx / gx,0) * RayDirWeight2;

                fx = RunningReservoirCCopy.M * luminance(RunningReservoirCCannon.Color * NEEbsdf2);
                gx = ((RunningReservoirCCannon.M / 5.0f) * luminance(RunningReservoirCCannon.Color * CannonNEEBSDF));
                ratio = pow(min(fx / gx, gx / fx), 3.0f);
                gx *= ratio;
                gx += fx;
                McNEE = McNEE + (1.0f - max(fx / gx,0) * RayDirWeight2);

            // }

            bool MergedB = ReservoirMergeSpatial(CellTapCoord, PackedReservoirA, 1, bsdf2, RunningReservoirB, RandOffsets2.x, Mi);
            bool MergedC = ReservoirMergeSpatialNEE(CellTapCoord, PackedReservoirB, 1, NEEbsdf2, RunningReservoirC, RandOffsets2.y, MiNEE);
            [branch]if(MergedB) {
                WorldPos = SampleWorldPos;
                CenterRayDir = SampleRayDir;
                bsdf = bsdf2;
                CenterNorm = SampleNorm;
            }
            [branch]if(MergedC) {
                NEEPos = SampleNEEPos;
                CenterNEERayDir = SampleNEERayDir;
                NEEbsdf = NEEbsdf2;
            }
        }

    }
    bool Merged3 = ReservoirMergeSpatial(id.xy, PackedCenterResA, 1, CannonBSDF, RunningReservoirB, randomNEE(324, pixel_index).x, Mc);
    bool Merged4 = ReservoirMergeSpatialNEE(id.xy, PackedCenterResB, 1, CannonNEEBSDF, RunningReservoirC, randomNEE(324, pixel_index).y, McNEE);
    if(Merged3) WorldPos = WorldPosB[id.xy];
    if(Merged4) NEEPos = NEEPosB[id.xy];






    [branch]if (DoReSTIRGIConnectionValidation) {
        float2 DistDist = 1;
        if(SurfaceMat.specTrans == 0 && SurfaceMat.diffTrans == 0) {
            PrimaryHitPosition += GeomNorm * NormalOffset;
            float Distance = length(PrimaryHitPosition - NEEPos.xyz) - 0.025f;
            SmallerRay ray = CreateRay(PrimaryHitPosition, normalize(NEEPos.xyz - PrimaryHitPosition));
            if (luminance(RunningReservoirC.Color) != 0) {
                bool ValidSpot = true;
                int AggTriIndex = asint(NEEPos.w);
                if(AggTriIndex >= 0) {
                    LightData Light = _UnityLights[AggTriIndex];
                    float3 MiscInfo = float3(Light.Softness * 120.0f + 1, Light.SpotAngle);
                    if(Light.Type == SPOTLIGHT) {
                        RunningReservoirC.Color *= saturate(saturate(dot(ray.direction, -Light.Direction)) * MiscInfo.y + MiscInfo.z);
                            float3 LocalLight = ToLocal(GetTangentSpace(Light.Direction), -ray.direction) * 0.5f + 0.5f;
                            float2 AlignedUV = AlignUV(LocalLight.xz, float4(1,1,0,0), _UnityLights[AggTriIndex].IESTex);
                            if(AlignedUV.x != -1) RunningReservoirC.Color *= _IESAtlas.SampleLevel(my_linear_clamp_sampler, AlignedUV, 0);

                    } else if(Light.Type == AREALIGHTQUAD) {
                        RunningReservoirC.Color *= pow(saturate(dot(ray.direction, -Light.Direction)), MiscInfo.x);
                    } 
                    // else if(Light.Softness == 0 && Light.Type == DIRECTIONALLIGHT) {
                    //     Distance = 1000.0f;
                    //     ray = CreateRay(PrimaryHitPosition, Light.Direction);
                    // }
                }


            #ifdef ReSTIRAdvancedValidation
                float TargDist = VisabilityCheck(ray, Distance);
                if (TargDist != Distance || dot(ray.direction, GeomNorm) <= 0) {
                    DistDist.y = exp(-abs(Distance - TargDist));
            #else
                if(!VisabilityCheck(ray, Distance) || dot(ray.direction, GeomNorm) <= 0) {
            #endif
                    RunningReservoirC.Wsum = 0;
                    RunningReservoirC.M = 0;
                    McNEE = 1;
                }
            }
            #ifdef ExtraSampleValidation
                Distance = length(PrimaryHitPosition - CalcPos(WorldPos)) - 0.025f;
                ray = CreateRay(PrimaryHitPosition, normalize(CalcPos(WorldPos) - PrimaryHitPosition));
                
                if(luminance(RunningReservoirB.Radiance.Color) != 0) {
                #ifdef ReSTIRAdvancedValidation
                    float TargDist = VisabilityCheck(ray, Distance);
                    if (TargDist != Distance || dot(ray.direction, GeomNorm) <= 0) {
                        DistDist.x = exp(-abs(Distance - TargDist));
                #else
                    if(!VisabilityCheck(ray, Distance) || dot(ray.direction, GeomNorm) <= 0) {
                #endif
                        RunningReservoirB.Radiance.Wsum = 0; 
                        RunningReservoirB.Radiance.M = 0; 
                        Mc = 1;
                    }
                }
            #endif
            PrimaryHitPosition -= GeomNorm * NormalOffset;
        }

        #ifdef ReSTIRAdvancedValidation
            GradientWrite[id.xy] = DistDist;
        #endif
    }

    Valid2 = ReconstructBsdf2(SurfaceMat, CameraRay.direction, normalize(CalcPos(WorldPos) - PrimaryHitPosition), SurfNorm, pdf, bsdf, TangSpace, pixel_index);
    Valid2 = EvaluateBsdf2(SurfaceMat, CameraRay.direction, normalize(NEEPos - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf, pixel_index, TangSpace);

    RunningReservoirB.Radiance.W = clamp((luminance(RunningReservoirB.Radiance.Color * bsdf) == 0 ? 0 : (1.0f / (luminance(RunningReservoirB.Radiance.Color * bsdf)) * (1.0f / (1.0f + K))) * RunningReservoirB.Radiance.Wsum),0,1000.0f);// / max((RunningReservoirB.Radiance.M) * luminance(RunningReservoirB.Radiance.Color * bsdf), 1e-7) ;
    RunningReservoirC.W = clamp((luminance(RunningReservoirC.Color * NEEbsdf) == 0 ? 0 : (1.0f / (luminance(RunningReservoirC.Color * NEEbsdf)) * (1.0f / (1.0f + K))) * RunningReservoirC.Wsum),0,1000.0f);//RunningReservoirC.Radiance.Wsum / max((RunningReservoirC.Radiance.M) * luminance(RunningReservoirC.Radiance.Color * NEEbsdf), 1e-7) ;       
    Valid2 = EvaluateBsdf(SurfaceMat, CameraRay.direction, normalize(NEEPos - PrimaryHitPosition), SurfNorm, pdf, NEEbsdf, pixel_index);
    RunningReservoirB.Radiance.W *= RunningReservoirB.Radiance.W < 100.0f;
    RunningReservoirC.W *= RunningReservoirC.W < 100.0f;

    GlobalColors[pixel_index].PrimaryNEERay = packRGBE(pow(RunningReservoirC.Color * RunningReservoirC.W * NEEbsdf,rcp(2.2f)));

    GlobalColors[pixel_index].Indirect = 0;
    GlobalColors[pixel_index].Direct = RunningReservoirB.Radiance.Color * RunningReservoirB.Radiance.W;
    if(GetBounceData(GlobalColors[pixel_index].MetRoughIsSpec) != 1) {
        SmallerRay ray = CreateRay(PrimaryHitPosition, normalize(CalcPos(WorldPos) - PrimaryHitPosition));
        if(GetFlag(SurfaceMat.Tag, Thin) && dot(GeomNorm, ray.direction) < 0 && Case == 2) bsdf *= sqrt(exp(-CalculateExtinction(SurfaceMat.transmittanceColor, SurfaceMat.scatterDistance == 0.0f ? 1.0f : SurfaceMat.scatterDistance)));
        if(Case != 3) GlobalColors[pixel_index].Data.xyz = bsdf;
    }
}