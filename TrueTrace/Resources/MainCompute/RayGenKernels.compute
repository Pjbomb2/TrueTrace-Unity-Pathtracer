#include "../GlobalDefines.cginc"
#include "CommonData.cginc"
#ifndef DX11
    #pragma use_dxc
#endif

#ifdef HDRP
Texture2DArray<float2> MotionVectors;
Texture2DArray<float3> NormalTex;
Texture2DArray<float> Depth;
#else
Texture2D<float2> MotionVectors;
Texture2D<float3> NormalTex;
Texture2D<float> Depth;
#endif

#pragma kernel GenerateASVGF 

static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,-1};
const static RayHit tempray = CreateRayHit();

[numthreads(256, 1, 1)]
void GenerateASVGF(uint3 id : SV_DispatchThreadID) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;
    RayData globray = {Rays[pixel_index].origin + NearPlane * Rays[pixel_index].direction, pixel_index, Rays[pixel_index].direction, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
    GlobalColors[pixel_index] = InitCol;
    WorldPosA[id.xy] = float4(0,0,0, 0);
    NEEPosA[id.xy] = float4(0,0,0, 0);

    #ifdef RadianceCache
        CacheBuffer[pixel_index].pathLength = 0;
        CacheBuffer[pixel_index].CurrentIlluminance = 0;
        CacheBuffer[pixel_index].throughput = EncodeRGB(float3(1,1,1));
    #endif
}

#pragma kernel Generate
[numthreads(256, 1, 1)]
void Generate(uint3 id : SV_DispatchThreadID) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;
    float2 jitter = ((random(0, pixel_index) - 0.5));
    float2 uv = float2((id.xy + (UseReCur ? 0 : jitter)) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    #ifdef RadianceCache
        CacheBuffer[pixel_index].pathLength = 0;
        CacheBuffer[pixel_index].CurrentIlluminance = 0;
        CacheBuffer[pixel_index].throughput = EncodeRGB(float3(1,1,1));
    #endif
    SmallerRay ray = CreateCameraRay(uv, pixel_index);
    RayData globray = {ray.origin + NearPlane * ray.direction, pixel_index, ray.direction, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
    GlobalColors[pixel_index] = InitCol;
}



#pragma kernel GIReTraceKernel
[numthreads(16, 16, 1)]
void GIReTraceKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {
    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

    float2 uv = float2((id.xy) / float2(screen_width, screen_height));
    SmallerRay ray = CreateCameraRay(uv * 2.0f - 1.0f, pixel_index);
    RandomNumsWrite[id.xy] = float4(frames_accumulated, pixel_index, 0, 0);

    #ifdef RadianceCache
        CacheBuffer[pixel_index].pathLength = 0;
        CacheBuffer[pixel_index].CurrentIlluminance = 0;
        CacheBuffer[pixel_index].throughput = EncodeRGB(float3(1,1,1));
    #endif
    if(curframe % ReSTIRGIUpdateRate == pixel_index % ReSTIRGIUpdateRate) {
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(id.xy,0)].xy;
        #else
            float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, uv, 0).xy;
        #endif
        int2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
        if (RandomNums[prevIndex].z == 0 && ReservoirA[prevIndex].z != 3 && prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height && PrevGlobalColorsA[prevIndex.x + prevIndex.y * screen_width].throughput.z != 0) {
            RandomNumsWrite[id.xy] = float4(PrevGlobalColorsA[prevIndex.x + prevIndex.y * screen_width].throughput.yx, 1 + ReservoirA[prevIndex].z,  PrevGlobalColorsA[prevIndex.x + prevIndex.y * screen_width].throughput.z);
        }
    }
    
    RayData globray = {ray.origin + NearPlane * ray.direction, pixel_index, ray.direction, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
    GlobalColors[pixel_index] = InitCol;
    WorldPosA[id.xy] = float4(0,0,0, 0);
    NEEPosA[id.xy] = float4(0,0,0, 0);
}



int LightMapTriCount;

    struct LightMapTriData
    {
        float3 pos0;
        float3 posedge1;
        float3 posedge2;
        float2 LMUV0;
        float2 LMUV1;
        float2 LMUV2;
        uint3 Norms;
    };

StructuredBuffer<LightMapTriData> LightMapTris;

float CalcArea(float2 p1, float2 p2, float2 p3)
{
    float2 v1 = p1 - p3;
    float2 v2 = p2 - p3;
    return (v1.x * v2.y - v1.y * v2.x) / 2.0f;
}

float3 UvTo3D(float2 uv, float3 v1, float3 v2, float3 v3, float2 t1, float2 t2, float2 t3) {

    float Area = CalcArea(t1, t2, t3);
    if(Area == 0) return 0;

    float a1 = CalcArea(t2, t3, uv) / Area;
    // if(a1 < 0) return 0;
    float a2 = CalcArea(t3, t1, uv) / Area;
    // if(a2 < 0) return 0;
    float a3 = CalcArea(t1, t2, uv) / Area;
    // if(a3 < 0) return 0;

    return float3(a1, a2, a3);//a1 * v1 + a2 * v2 + a3 * v3;

}

float2 sample_disc(float u1, float u2) {
    float a = 2.0f * u1 - 1.0f;
    float b = 2.0f * u2 - 1.0f;
    if (a == 0.0f) a = 0.00001;
    if (b == 0.0f) b = 0.00001;

    float phi, r;
    if (a * a > b * b) {
        r = a;
        phi = (0.25f * PI) * (b / a);
    }
    else {
        r = b;
        phi = (0.25f * PI) * (a / b) + (0.5f * PI);
    }

    float sin_phi, cos_phi;
    sincos(phi, sin_phi, cos_phi);

    return float2(r * cos_phi, r * sin_phi);
}

float3 sample_cosine_weighted_direction(float u1, float u2) {
    float2 d = sample_disc(u1, u2);
    return float3(d.x, sqrt(abs(1.0f - dot(d, d))), d.y);
}

float3 sample(inout float pdf, uint pixel_index) {//Diffuse
    float2 rando = random(1, pixel_index);
    float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
    pdf = omega_o.y * ONE_OVER_PI;
    return omega_o;
}

RWTexture2D<float4> WorldIndex;

#pragma kernel LightMapGen
[numthreads(16, 16, 1)]
void LightMapGen(uint3 id : SV_DispatchThreadID) {

    if(WorldIndex[id.xy].w == -1) return;
    LightMapTriData Tri = LightMapTris[WorldIndex[id.xy].w];


    float3 Normal = cross(normalize(Tri.posedge1), normalize(Tri.posedge2));
    float wldScale = rsqrt(dot(Normal, Normal));
    int pixel_index = id.x + id.y * screen_width;
    Normal = -normalize(mul(wldScale, normalize(Normal)));

            
            float3 world = WorldIndex[id.xy];
            if(all(world == 0)) return;
            float3 ActualNormal = normalize(world.x * i_octahedral_32(Tri.Norms.x) + world.y * (i_octahedral_32(Tri.Norms.y) - i_octahedral_32(Tri.Norms.x)) + world.z * (i_octahedral_32(Tri.Norms.z) - i_octahedral_32(Tri.Norms.x)));
            if(dot(Normal, ActualNormal) < 0) Normal *= -1;
            // Normal = ActualNormal;
            world = world.x * Tri.pos0 + world.y * (Tri.pos0 + Tri.posedge1) + world.z * (Tri.pos0 + Tri.posedge2);
            float3 RandVec = float3(random(3, pixel_index), random(4, pixel_index).x);
            sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
            float sinPhi, cosPhi;
            sincos(1, sinPhi, cosPhi);
            RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * 0.00f;
            float pdf;
            float3 IncommingRay = -normalize(mul(sample(pdf, pixel_index), GetTangentSpace(-Normal)));
            float3 NewWorldPos = world;// + Normal * NormalOffset;// - ToWorld(GetTangentSpace2(-Normal), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
            NewWorldPos += Normal * NormalOffset;
            NewWorldPos -= IncommingRay * 0.0001f;
            IncommingRay = normalize(world - NewWorldPos);
            NewWorldPos += ToWorld(GetTangentSpace2(-normalize(Normal + float3(random(5, pixel_index), random(6, pixel_index).x) * 0.001f)), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy) * 0.1f;
            RayData globray = {NewWorldPos, pixel_index, IncommingRay, 0, 0,0,asuint(FarPlane),0};
            int RayCount = 0;
            InterlockedAdd(BufferSizes[0].tracerays, 1, RayCount);
            GlobalRays[RayCount] = globray;

         

        }
    










#pragma kernel GenClear
[numthreads(16, 16, 1)]
void GenClear(uint3 id : SV_DispatchThreadID) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

    GlobalColors[pixel_index] = InitCol;

}


#pragma kernel LightMapGen2
[numthreads(256, 1, 1)]
void LightMapGen2(uint3 id : SV_DispatchThreadID) {

    if (id.x > LightMapTriCount) return;
    LightMapTriData Tri = LightMapTris[id.x];


    float2 UVMax = max(max(Tri.LMUV0, Tri.LMUV1), Tri.LMUV2);
    float2 UVMin = min(min(Tri.LMUV0, Tri.LMUV1), Tri.LMUV2);

    float LightMapWidthMin1 = screen_width - 1;
    float LightMapHeightMin1 = screen_height - 1;
    int minX = floor(UVMin.x * LightMapWidthMin1);
    int minY = floor(UVMin.y * LightMapHeightMin1);
    int maxX = ceil(UVMax.x * LightMapWidthMin1);
    int maxY = ceil(UVMax.y * LightMapHeightMin1);

    float3 Normal = cross(normalize(Tri.posedge1), normalize(Tri.posedge2));
    float wldScale = rsqrt(dot(Normal, Normal));
    Normal = -normalize(mul(wldScale, Normal) + float3(random(7, id.x), random(8, id.x).x) * 0.01f);

    for(int x = minX; x <= maxX; x++) {
        for(int y = minY; y <= maxY; y++) {
            float xx = min(x, maxX - 1) / (float)LightMapWidthMin1;
            float yy = min(y, maxY - 1) / (float)LightMapHeightMin1;
            
            float3 world = UvTo3D(float2(xx, yy), Tri.pos0, Tri.pos0 + Tri.posedge1, Tri.pos0 + Tri.posedge2, Tri.LMUV0, Tri.LMUV1, Tri.LMUV2);
            if(all(world == 0)) continue;
            WorldIndex[int2(x, y)] = float4(world, id.x);

         

        }
    }
}

    groupshared bool ActiveData[256];
    groupshared uint TotalCount[8];
    #pragma kernel CacheResolve
    [numthreads(256, 1, 1)]
    void CacheResolve(uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {
    #ifdef RadianceCache
        HashEntriesBuffer[id.x].z = 0;
        HashKeyValue HashValue = HashEntriesBuffer[id.x];
        bool Valid = !(id.x > CacheCapacity || (HashValue.x == 0 && HashValue.y == 0));
        int GroupIndex = GT.x / BucketCount;
        ActiveData[GT.x] = Valid;
        TotalCount[GroupIndex] = 0;
        GroupMemoryBarrierWithGroupSync();
        uint4 SummedVoxel = 0;
        if(ActiveData[GT.x]) {
            uint4 VoxelCurr = VoxelDataBufferA.Load4(id.x * 16);
            uint4 VoxelPrev = VoxelDataBufferB.Load4(id.x * 16);
            SummedVoxel = VoxelCurr + VoxelPrev;
            uint VoxelSampleCount = SummedVoxel.w & ((1u << 20) - 1);

            if ((VoxelSampleCount < MaxSampleCount) && any(CamPos - PrevCamPos) && (VoxelCurr.w != 0)) {
                HashKeyValue SidelinedHashKey = GetReprojectedHash(HashValue);

                uint cacheEntry = 0xFFFFFFFF;
                if (HashGridFind(SidelinedHashKey, cacheEntry)) {
                    uint4 SidelinedVoxelPrev = VoxelDataBufferB.Load4(cacheEntry * 16);
                    uint SidelinedVoxelSampleCount = SidelinedVoxelPrev.w & ((1u << 20) - 1);
                    if (SidelinedVoxelSampleCount > 8) {
                        SummedVoxel.xyz += SidelinedVoxelPrev.xyz;
                        VoxelSampleCount += SidelinedVoxelSampleCount;
                    }
                }
            }

            if (VoxelSampleCount > MaxSampleCount) {
                SummedVoxel.xyz *= (float)MaxSampleCount / VoxelSampleCount;
                VoxelSampleCount = MaxSampleCount;
            }

            uint FrameCounter = (VoxelPrev.w >> 20) & ((1u << 12) - 1);
            SummedVoxel.w = VoxelSampleCount;

            if ((VoxelCurr.w & ((1u << 20) - 1)) == 0) {
                ++FrameCounter;
                SummedVoxel.w |= ((FrameCounter & ((1u << 12) - 1)) << 20);
            }

            if (FrameCounter > MaxSampleCount)
                SummedVoxel = 0;

            if(SummedVoxel.w == 0) ActiveData[GT.x] = false;
            else InterlockedAdd(TotalCount[GroupIndex], 1);
        }

        GroupMemoryBarrierWithGroupSync();
        // if(!Valid) return;

        if(id.x % BucketCount >= TotalCount[GroupIndex]) {
            VoxelDataBufferA.Store4(id.x * 16, (uint4)0);
                
            uint Offset = 0;
            if(ActiveData[GT.x]) {
                uint Prefix = 0;
                for(int i = GroupIndex * BucketCount + TotalCount[GroupIndex] + 1; i < (GroupIndex + 1) * BucketCount; i++)
                    if(ActiveData[i]) Prefix++;

                uint Empty = 0;
                while(Empty < TotalCount[GroupIndex]) {
                    if(!ActiveData[Offset + GroupIndex * BucketCount]) {
                        if (Empty == Prefix) {
                            Offset += (id.x / BucketCount) * BucketCount;
                            VoxelDataBufferA.Store4(Offset * 16, SummedVoxel);
                            break;
                        }
                        Empty++;
                    }
                    Offset++;
                }
            }
            HashEntriesBuffer[id.x].z = Offset ? Offset : 0xFFFFFFFF;
        } else if(ActiveData[GT.x]) {
            VoxelDataBufferA.Store4(id.x * 16, SummedVoxel);
        } else {
            VoxelDataBufferA.Store4(id.x * 16, (uint4)0);
            
        }
    #endif
    }


    #pragma kernel ScreenCopy
    [numthreads(256, 1, 1)]
    void ScreenCopy(uint3 id : SV_DispatchThreadID) {
    #ifdef RadianceCache
        uint copyOffset = HashEntriesBuffer[id.x].z;
        if (copyOffset == 0 || id.x > CacheCapacity) return;
        if (copyOffset == 0xFFFFFFFF) HashEntriesBuffer[id.x] = (HashKeyValue)0;
        else if(copyOffset != 0) {
            HashKeyValue HashValue = uint3(HashEntriesBuffer[id.x].xy,0);
            HashEntriesBuffer[id.x] = (HashKeyValue)0;
            HashEntriesBuffer[copyOffset] = HashValue;
        }
        HashEntriesBuffer[id.x].z = 0;
    #endif
    }


    #pragma kernel ScreenClear
    [numthreads(256, 1, 1)]
    void ScreenClear(uint3 id : SV_DispatchThreadID) {
    #ifdef RadianceCache
        VoxelDataBufferA.Store4(id.x * 16, asuint(0));
        HashEntriesBuffer[id.x] = uint3(HashEntriesBufferB[id.x].xy,0);
    #endif
    }