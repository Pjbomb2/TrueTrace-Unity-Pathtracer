#pragma use_dxc
#include "CommonData.cginc"
#include "Materials.cginc"

// #define EnableRayDebug

#ifdef HDRP
Texture2DArray<float2> MotionVectors;
Texture2DArray<float3> NormalTex;
Texture2DArray<float> Depth;
#else
Texture2D<float2> MotionVectors;
Texture2D<float3> NormalTex;
Texture2D<float> Depth;
#endif

#pragma kernel kernel_shade

#ifdef EnableRayDebug
    RWStructuredBuffer<float3> DebugTraces;
#endif

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;


SamplerState my_point_clamp_sampler;

Texture2D<float2> _NormalAtlas;
SamplerState sampler_NormalAtlas;

Texture2D<float4> _EmissiveAtlas;
SamplerState sampler_EmissiveAtlas;

int BackgroundType;
float3 BackgroundColor;
float BackgroundIntensity;

//These are here purely for the Atrous
#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
bool VisabilityCheck(Ray ray, float dist) {
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
        while(q.Proceed()){}

        if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) return false;
        else return true;
    #else
    return VisabilityCheckCompute(ray, dist);
    #endif
}

float2 sample_disc(float u1, float u2) {
    float a = 2.0f * u1 - 1.0f;
    float b = 2.0f * u2 - 1.0f;
    if (a == 0.0f) a = 0.00001;
    if (b == 0.0f) b = 0.00001;

    float phi, r;
    if (a * a > b * b) {
        r = a;
        phi = (0.25f * PI) * (b / a);
    }
    else {
        r = b;
        phi = (0.25f * PI) * (a / b) + (0.5f * PI);
    }

    float sin_phi, cos_phi;
    sincos(phi, sin_phi, cos_phi);

    return float2(r * cos_phi, r * sin_phi);
}

float3 sample_cosine_weighted_direction(float u1, float u2) {
    float2 d = sample_disc(u1, u2);
    return float3(d.x, d.y, sqrt(abs(1.0f - dot(d, d))));
}

float3 sample(inout float pdf, uint pixel_index) {//Diffuse
    float2 rando = random(5, pixel_index);
    float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
    pdf = omega_o.z * ONE_OVER_PI;
    return omega_o;
}

float3 sample(inout float pdf, int rand, uint pixel_index) {//Diffuse
    float2 rando = random(rand, pixel_index);
    float3 omega_o = sample_cosine_weighted_direction(rando.x, rando.y);
    pdf = omega_o.z * ONE_OVER_PI;
    return omega_o;
}

float3x3 GetTangentSpace(float3 normal) {
    // Choose a helper floattor for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);

    // Generate floattors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = cross(normal, tangent);

    return float3x3(tangent, binormal, normal);
}



inline float3 local_to_world(const float3 Dir, const float3 tangent, const float3 binormal, const float3 normal) {
    return float3(
        tangent.x * Dir.x + binormal.x * Dir.y + normal.x * Dir.z,
        tangent.y * Dir.x + binormal.y * Dir.y + normal.y * Dir.z,
        tangent.z * Dir.x + binormal.z * Dir.y + normal.z * Dir.z
        );
}

float3 sample_henyey_greenstein(const float3 omega, float g, float u1, float u2) {
    float cos_theta;
    if (abs(g) < 1e-3f) {
        // Isotropic case
        cos_theta = 1.0f - 2.0f * u1;
    }
    else {
        float sqr_term = (1.0f - g * g) / (1.0f + g - 2.0f * g * u1);
        cos_theta = -(1.0f + g * g - sqr_term * sqr_term) / (2.0f * g);
    }
    float sin_theta = sqrt(max(1.0f - cos_theta * cos_theta, 0.0f));

    float phi = (PI * 2.0f) * u2;
    float sin_phi, cos_phi;
    sincos(phi, sin_phi, cos_phi);

    float3 direction = float3(
        sin_theta * cos_phi,
        sin_theta * sin_phi,
        cos_theta
        );

    float3 v1, v2;
    orthonormal_basis(omega, v1, v2);

    return local_to_world(direction, v1, v2, omega);
}

bool VolumetricScatter(inout float3 throughput, RayHit hit, inout Ray ray, inout float3 Pos, MaterialData hitDat, uint pixel_index) {
    float3 SigmaS = hitDat.surfaceColor;
    float3 SigmaA = hitDat.transmittanceColor;

    bool medium_can_scatter = (SigmaS.x + SigmaS.y + SigmaS.z) > 0.0f;

    if (medium_can_scatter) {
        float2 rand_scatter = random(3, pixel_index);
        float2 rand_phase = random(5, pixel_index);

        float3 sigma_t = SigmaA + SigmaS;

        float throughput_sum = throughput.x + throughput.y + throughput.z;
        float3 wavelength_pdf = throughput / throughput_sum;

        float sigma_t_used_for_sampling;
        if (rand_scatter.x * throughput_sum < throughput.x) {
            sigma_t_used_for_sampling = sigma_t.x;
        }
        else if (rand_scatter.x * throughput_sum < throughput.x + throughput.y) {
            sigma_t_used_for_sampling = sigma_t.y;
        }
        else {
            sigma_t_used_for_sampling = sigma_t.z;
        }

        float scatter_distance = -log(rand_scatter.y) / sigma_t_used_for_sampling;
        float dist = min(scatter_distance, hit.t);
        float3 transmittance = float3(
            exp(-sigma_t.x * dist),
            exp(-sigma_t.y * dist),
            exp(-sigma_t.z * dist)
            );

        if (scatter_distance < hit.t) {
            float3 pdf = wavelength_pdf * sigma_t * transmittance;
            throughput *= SigmaS * transmittance / (pdf.x + pdf.y + pdf.z);

            float3 direction_out = sample_henyey_greenstein(-ray.direction, hitDat.roughness, rand_phase.x, rand_phase.y);

            float3 ray_origin = ray.origin;
            ray.origin = ray_origin + scatter_distance * ray.direction;
            Pos = ray.origin;
            ray.direction = direction_out;
            return true;
        }
        else {
            float3 pdf = wavelength_pdf * transmittance;
            throughput *= transmittance / (pdf.x + pdf.y + pdf.z);
            return false;
        }
    }
    return false;
}






inline float luminance(const float r, const float g, const float b) {
    return 0.299f * r + 0.587f * g + 0.114f * b;
}


void sampleEquiAngular(float u, float maxDistance, float3 rOrigin, float3 rDirection, float3 lightPos, inout float dist, inout float pdf)
{
    // get coord of closest point to light along (infinite) ray
    float delta = clamp(dot(lightPos - rOrigin, rDirection), 0.0, 1.0);

    // get distance this point is from light
    float D = distance(rOrigin + delta * rDirection, lightPos);

    // get angle of endpoints
    float thetaA = atan((0.0 - delta) / D);
    float thetaB = atan((maxDistance - delta) / D);

    // take sample
    float t = D * tan(lerp(thetaA, thetaB, u));
    dist = delta + t;
    pdf = D / ((thetaB - thetaA) * (D * D + t * t));
}


float AreaOfTriangle(float3 pt1, float3 pt2, float3 pt3) {
    float a = distance(pt1, pt2);
    float b = distance(pt2, pt3);
    float c = distance(pt3, pt1);
    float s = (a + b + c) / 2.0f;
    return sqrt(s * (s - a) * (s - b) * (s - c));
}


static const float sigma_s = 0.09, sigma_a = 0.06, sigma_t = sigma_s + sigma_a;

inline float3 sampleHG(float g, float e1, float e2) {
    //double s=2.0*e1-1.0, f = (1.0-g*g)/(1.0+g*s), cost = 0.5*(1.0/g)*(1.0+g*g-f*f), sint = sqrt(1.0-cost*cost);
    float s = 1.0 - 2.0 * e1, cost = (s + 2.0 * g * g * g * (-1.0 + e1) * e1 + g * g * s + 2.0 * g * (1.0 - e1 + e1 * e1)) / ((1.0 + g * s) * (1.0 + g * s)), sint = sqrt(1.0 - cost * cost);
    return float3(cos(2.0 * PI * e2) * sint, sin(2.0 * PI * e2) * sint, cost);
}

inline float sampleSegment(float epsilon, float sigma, float smax) {
    return -log(1.0 - epsilon * (1.0 - exp(-sigma * smax))) / sigma;
}


inline void generateOrthoBasis(inout float3 u, inout float3 v, float3 w) {
    float3 coVec = w;
    if (abs(w.x) <= abs(w.y)) {
        if (abs(w.x) <= abs(w.z)) coVec = float3(0, -w.z, w.y);
        else coVec = float3(-w.y, w.x, 0);
    }
    else if (abs(w.y) <= abs(w.z)) {
        coVec = float3(-w.z, 0, w.x);
    }
    else coVec = float3(-w.y, w.x, 0);
    coVec *= 1 / sqrt(dot(coVec, coVec));
    u = w % coVec,
        v = w % u;
}

inline float scatter(const Ray r, inout float3 dir, inout float dist, float tin, float tout, float3x3 TanNorm, uint pixel_index) {
    dist = sampleSegment(random(23, pixel_index).x, sigma_s, tout - tin);
    //Vec dir = sampleSphere(XORShift::frand(), XORShift::frand()); //Sample a direction ~ uniform phase function
    dir = sampleHG(-0.5, random(95, pixel_index).x, random(95, pixel_index).y); //Sample a direction ~ Henyey-Greenstein's phase function
    float3 u, v = 0;
    // GetTangentSpace
    // generateOrthoBasis(u, v, r.direction);
    dir = ToWorld(TanNorm, dir);
    return (1.0 - exp(-sigma_s * (tout - tin)));
}





float A;
bool ChangedExposure;
int RISCount;

int SelectUnityLight(int pixel_index, out float lightWeight, float3 Norm, float3 Position, float3 RayDir, MaterialData hitmat) {
    lightWeight = 1;
    if (unitylightcount == 1) return 0;
    float2 Rand = random(0, pixel_index);
    if(RISCount == 0)   return clamp(floor(Rand.y * unitylightcount), 0, unitylightcount - 1);
    int MinIndex = 0;
    float wsum = 0;
    int M = 0;
    float MinP_Hat = 0;
    for(int i = 0; i < RISCount; i++) {
        Rand = random(i, pixel_index);
        int Index = clamp((Rand.x * unitylightcount), 0, unitylightcount - 1);
        LightData light = _UnityLights[Index];
        float3 Pos = light.Type == 1 ? (light.Direction * 120000.0f + Position) : light.Position;
        float3 to_light = Pos - Position;
        float LengthSquared = dot(to_light, to_light);
        to_light /= sqrt(LengthSquared);
        float3 bsdf_value;
        float bsdf_pdf;
        bool A = EvaluateBsdf(hitmat, RayDir, to_light, Norm, bsdf_pdf, bsdf_value, pixel_index);
        // bool A = evaldiffuse(to_light, dot(to_light, Norm), bsdf_value, bsdf_pdf);
        float p_hat = max(luminance(bsdf_value * light.Radiance) / ((light.Type == 1) ? 1 : LengthSquared) * ((light.Type == 2) ? saturate(saturate(dot(to_light, -light.Direction)) * light.SpotAngle.x + light.SpotAngle.y) : 1),0);
        wsum += p_hat;
        M++;
        if(Rand.y < p_hat / wsum) {
            MinIndex = Index;
            MinP_Hat = p_hat;
        }

    }
    lightWeight = wsum / max((M + 1) *MinP_Hat, 0.000001f);
    return MinIndex;
}

float2 msign( float2 v )
{
    return float2( (v.x>=0.0) ? 1.0 : -1.0, 
                 (v.y>=0.0) ? 1.0 : -1.0 );
}

uint octahedral_32( in float3 nor )
{
    nor.xy /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );
    nor.xy  = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*msign(nor.xy);
    //return packSnorm2x16(nor.xy);
    uint2 d = uint2(round(32767.5 + nor.xy*32767.5));  return d.x|(d.y<<16u);
}


int2 StochasticBilinear(float2 st, float u) {
    int s = floor(st[0]), t = floor(st[1]);
    float ds = st[0] - floor(st[0]);
    float dt = st[1] - floor(st[1]);
    if (u < ds) {
    ++s;
    u /= ds;
    } else
    u = (u - ds) / (1 - ds);
    if (u < dt) {
    ++t;
    u /= dt;
    } else
    u = (u - dt) / (1 - dt);
    return float2(s, t);
}

int NormalSize;
int EmissiveSize;

bool UseReCur;

void calcFinalColor(inout Ray ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 Uv, float2 NormalUV, bool IsEmissiveTex, RayData RayDat, int prevIndex, bool HitHeightmap, const uint pixel_index, int PixIndex, int MaterialIndex, inout float4 AlbedoTexData) {//main function
    bool cb = (int(Uv.x)/2 + int(Uv.y)/2 + frames_accumulated)%2==0;
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 PrevOrigin = ray.origin;
    const uint index = hit.triangle_id;
    const int Index = Uv.x + Uv.y * screen_width;
    float3 Geomnorm;
    [branch] if (TerrainExists && HitHeightmap) {
        Geomnorm.x = (GetHeight(pos + float3(0.01f, 0, 0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0.01f, 0, 0), Terrains[hit.triangle_id]));
        Geomnorm.y = (GetHeight(pos + float3(0, 0.01f, 0), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0, 0.01f, 0), Terrains[hit.triangle_id]));
        Geomnorm.z = (GetHeight(pos + float3(0, 0, 0.01f), Terrains[hit.triangle_id]) - GetHeight(pos - float3(0, 0, 0.01f), Terrains[hit.triangle_id]));
        Geomnorm = normalize(Geomnorm);
    }
    else {
        float scalex = length(mul(_MeshData[hit.mesh_id].Inverse, float4(1,0,0,0)));
        float scaley = length(mul(_MeshData[hit.mesh_id].Inverse, float4(0,1,0,0)));
        float scalez = length(mul(_MeshData[hit.mesh_id].Inverse, float4(0,0,1,0)));
        float3 Normsx = i_octahedral_32(AggTris[index].norms.x);
        Geomnorm = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(normalize(pow(rcp(float3(scalex, scaley, scalez)),2) * (Normsx + hit.u * (i_octahedral_32(AggTris[index].norms.y) - Normsx) + hit.v * (i_octahedral_32(AggTris[index].norms.z) - Normsx))), 0.0f)).xyz);
    }

    const float3 PrevThroughput = Color.throughput;
    ray.origin = pos;
    // _DebugTex[Uv] = float4(hit.u, hit.v, 0, 1);
    bool GotFlipped = false;
    [branch] if (dot(ray.direction, Geomnorm) >= 0.0f) {
        Geomnorm *= -1;
        GotFlipped = true;
    }
    float3 norm = Geomnorm;
    [branch] if (NormalUV.x != -1) {//Handle Normal Maps
        float3 Tansx = i_octahedral_32(AggTris[index].tans.x);
        float3 LocalTan = normalize(mul(_MeshData[hit.mesh_id].Inverse, float4(Tansx + hit.u * (i_octahedral_32(AggTris[index].tans.y) - Tansx) + hit.v * (i_octahedral_32(AggTris[index].tans.z) - Tansx), 0.0f)).xyz);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = _NormalAtlas[StochasticBilinear(NormalUV * NormalSize, random(54, pixel_index).x)];
        float2 InputNormal;
        InputNormal = Norm.rg;

        float3 LocalNormIN = float3((2.0f * InputNormal.xy - 1.0f), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);
        norm = normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz);
        norm = clamp(norm, -1, 1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
    }
    [branch] if (UseReSTIRGI && CurBounce == 0) {//Initialize Buffer
        CurrentReservoirGI[Index].W = Pack2To1(0,0);
        CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1(0, 0);
        CurrentReservoirGI[Index].HistoricFrameThisCase = Pack2To1(RandomNums[Uv.xy].x, 0);
        CurrentReservoirGI[Index].SecondaryHitPosition = float3(-10,0,0);
        CurrentReservoirGI[Index].HistoricID = RandomNums[Uv.xy].y;
        ScreenSpaceData TempMatModifier = {packUnormArb(float3(1,0,0)), 0, packUnormArb(float3(1,0,0)), packUnormArb(float3(1,0,0)), 0,0,0,0, float3(10,0,0), 1, 0};
                ScreenSpaceInfo[PixIndex] = TempMatModifier;
    }

    [branch] if (hitDat.emmissive > 0.0f) {//if we hit a light, this ray is done
        #ifdef EnableRayDebug
            float HorizInterval = screen_width / 25;
            float VertInterval = screen_height / 25;
            int x = floor(Uv.x / HorizInterval);
            int y = floor(Uv.y / VertInterval);
            if(Uv.x == x * HorizInterval && Uv.y == y * VertInterval) {
                DebugTraces[CurBounce + (x + y * 25) * 24] = pos;
            }
        #endif
        if (!UseNEE || IsEmissiveTex) {
            if (CurBounce == 0) {
                Color.Direct = hitDat.emmissive * hitDat.surfaceColor;

                AlbedoTexData = float4(hitDat.emmissive * hitDat.surfaceColor, 0);
                CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1(luminance(hitDat.emmissive * hitDat.surfaceColor) * 1000.0f, 0);
            }
            else if (CurBounce == 1) {
                Color.Direct += hitDat.surfaceColor * (hitDat.emmissive);

                CurrentReservoirGI[Index].SecondaryHitPosition = pos;
                CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1((Unpack1To2(CurrentReservoirGI[Index].LuminanceIncommingM).y / 1000.0f + luminance(hitDat.surfaceColor * hitDat.emmissive)) * 1000.0f, 0);
            }
            else {
                Color.Indirect += Color.throughput * hitDat.emmissive * hitDat.surfaceColor;
                CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1((Unpack1To2(CurrentReservoirGI[Index].LuminanceIncommingM).y / 1000.0f + luminance(Color.throughput * hitDat.surfaceColor * hitDat.emmissive)) * 1000.0f, 0);
            }
        }
        else {
            float3 a0 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0, 1)).xyz;
            float3 a1 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge1, 1)).xyz;
            float3 a2 = mul(_MeshData[hit.mesh_id].Inverse, float4(AggTris[index].pos0 + AggTris[index].posedge2, 1)).xyz;

            float a = AreaOfTriangle(a0, a1, a2);
            float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
            float light_pdf = 1.0f / (SA * LightMeshCount) * ((_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) * (a / _MeshData[hit.mesh_id].LightPDF);
            float w = power_heuristic(max(RayDat.last_pdf,0), light_pdf);
            if (CurBounce == 0) {
                Color.Direct = hitDat.emmissive * hitDat.surfaceColor;
                AlbedoTexData = float4(hitDat.emmissive * hitDat.surfaceColor, 0);
                CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1(luminance(hitDat.emmissive * hitDat.surfaceColor) * 1000.0f, 0);
            }
            else if (CurBounce == 1) {
                Color.Direct += (hitDat.surfaceColor * hitDat.emmissive) * w;
                CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1((Unpack1To2(CurrentReservoirGI[Index].LuminanceIncommingM).y / 1000.0f + luminance(hitDat.surfaceColor * hitDat.emmissive * w)) * 1000.0f, 0);
                CurrentReservoirGI[Index].SecondaryHitPosition = pos;
            }
            else {
                Color.Indirect += Color.throughput * hitDat.surfaceColor * hitDat.emmissive * w;
                CurrentReservoirGI[Index].LuminanceIncommingM = Pack2To1((Unpack1To2(CurrentReservoirGI[Index].LuminanceIncommingM).y / 1000.0f + luminance(Color.throughput * hitDat.surfaceColor * hitDat.emmissive * w)) * 1000.0f, 0);
            }
        }
        return;
    }
    float3 throughput = Color.throughput;

    float3 tempraydir = float3(0.0f, 0.0f, 0.0f);
    bool valid = true;
    float pdf = 0.0f;

    float3 omega_i = mul(GetTangentSpace(norm), -ray.direction);

    {
        float3 wo = ToLocal(GetTangentSpace2(norm), -ray.direction);
        float ni = wo.y > 0.0f ? 1.0f : hitDat.ior;
        float nt = wo.y > 0.0f ? hitDat.ior : 1.0f;
        hitDat.relativeIOR = ni / nt;
    }

    int Case = 0;
        BsdfSample Thissample = initbsdf();
        bool2 tempvalid;
        if(UseReSTIRGI && ReSTIRGIUpdateRate != 0 && CurBounce == 0 && RandomNums[Uv].z == 1) {
            float RayDir = ray.direction;
            float3 bsdf_value;
            float fpdf;
            valid = ReconstructBsdf(hitDat, RayDir, normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * NormalOffset)), norm, fpdf, bsdf_value, Unpack1To2(PreviousReservoirGI[prevIndex].HistoricFrameThisCase).x, GetTangentSpace2(norm), pixel_index);
            pdf = fpdf;
            ray.direction = normalize(PreviousReservoirGI[prevIndex].SecondaryHitPosition - (pos + Geomnorm * NormalOffset));
            throughput *= max(bsdf_value, 0.000001f);
            Case = Unpack1To2(PreviousReservoirGI[prevIndex].HistoricFrameThisCase).x;

            } else {
        [branch] switch (hitDat.MatType) {//Switch between different materials
            case DisneyIndex://Disney BSDF
                tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case, pixel_index);
                valid = tempvalid.x;
                ray.direction = Thissample.wi;
                pdf = Thissample.forwardPdfW;
                throughput *= max(Thissample.reflectance, 0.000001f);
                if (CurBounce == 0 && (Case == 0 || Case == 3)) Color.IsSpecular = (hitDat.roughness < 0.01f) ? 0 : 1;
                if (CurBounce == 0) {
                    uint A = (hitDat.metallic) * 0xFFFF;
                    uint B = (hitDat.roughness) * 0xFFFF;
                    uint ABPacked = (A << 16) | (B & 0xFFFF);
                    Color.pad = asfloat(ABPacked);
                }
                if (CurBounce == 0 && Case == 3) {
                    uint A = 1 * 0xFFFF;
                    uint B = 0.39f * 0xFFFF;
                    Color.IsSpecular = 2;
                    if(tempvalid.y) {
                        B = 0.5f * 0xFFFF;
                    } else Color.IsSpecular = 3;
                    uint ABPacked = (A << 16) | (B & 0xFFFF);
                    Color.pad = asfloat(ABPacked);
                }
                // valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);

                if (tempvalid.y) {
                    Geomnorm *= -1; norm *= -1;
                } 
                else {
                    if (AlbedoTexData.w <= 0 && Case == 3) {
                        uint A = 1 * 0xFFFF;
                        uint B = 0.39f * 0xFFFF;
                        Color.IsSpecular = 3;
                        uint ABPacked = (A << 16) | (B & 0xFFFF);
                        Color.pad = asfloat(ABPacked);
                    }   
                }
            break;
            case CutoutIndex://mask material
                Thissample = initbsdf();
                tempvalid = SampleDisney(hitDat, -ray.direction, hitDat.Thin == 1, Thissample, GetTangentSpace2(norm), Case, pixel_index);
                valid = tempvalid.x;
                ray.direction = Thissample.wi;
                pdf = Thissample.forwardPdfW;
                throughput *= max(Thissample.reflectance, 0.000001f);
                if (CurBounce == 0 && Case == 0) Color.IsSpecular = 1;
                if (CurBounce == 0) {
                    uint A = hitDat.metallic * 0xFFFF;
                    uint B = hitDat.roughness * 0xFFFF;
                    uint ABPacked = (A << 16) | (B & 0xFFFF);
                    Color.pad = asfloat(ABPacked);
                }
                // valid = valid && all(Thissample.reflectance < 0 || Thissample.reflectance > 0 || Thissample.reflectance == 0) && all(Thissample.forwardPdfW <= 1);

                if (tempvalid.y) {
                    Geomnorm *= -1; norm *= -1;
                }
            break;
            case VolumetricIndex://"Volumetric" material
                if (GotFlipped) {
                    if (VolumetricScatter(throughput, hit, ray, pos, hitDat, pixel_index)) {
                        norm = -norm;
                        Geomnorm = -Geomnorm;
                    }
                }
                else {
                    ray.direction = ray.direction;
                    norm = -norm;
                    Geomnorm = -Geomnorm;
                }
            break;
            case VideoIndex:
                ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
                valid = pdf > 0;
                throughput *= hitDat.surfaceColor;
            break;
            default:
                ray.direction = normalize(mul(sample(pdf, pixel_index), GetTangentSpace(norm)));
                valid = pdf > 0;
                throughput *= hitDat.surfaceColor;
            break;
        }
    }
    ray.origin = Geomnorm * NormalOffset + ray.origin;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of
    #ifdef EnableRayDebug
        float HorizInterval = screen_width / 25;
        float VertInterval = screen_height / 25;
        int x = floor(Uv.x / HorizInterval);
        int y = floor(Uv.y / VertInterval);
        if(Uv.x == x * HorizInterval && Uv.y == y * VertInterval) {
            DebugTraces[CurBounce + (x + y * 25) * 24] = PrevOrigin;
            DebugTraces[CurBounce + (x + y * 25) * 24 + 1] = ray.origin;
        }
    #endif
    #ifdef PSR
        [branch] if (UseReSTIRGI && CurBounce == AlbedoTexData.w) CurrentReservoirGI[Index].SecondaryHitPosition = pos;
    #else
        [branch] if (UseReSTIRGI && CurBounce == 1) CurrentReservoirGI[Index].SecondaryHitPosition = pos;
    #endif
    if(UseAlteredPipeline) {
        [branch] if (CurBounce == 0 || AlbedoTexData.w == -1) {//Setting textures for denosier to use
            CurrentReservoirGI[PixIndex].PrimaryNormal = packUnormArb(norm);
            ScreenSpaceData TempMatModifier = {packUnormArb(ray.direction), hitDat.roughness, packUnormArb(Geomnorm), packUnormArb(norm), max(hitDat.surfaceColor, 0.00001f),hitDat.metallic, pos, ((CurBounce == 0) ? hit.t : (ScreenSpaceInfo[PixIndex].t + hit.t)), MaterialIndex}; 
                ScreenSpaceInfo[PixIndex] = TempMatModifier;    
            AlbedoTexData = float4(max(hitDat.surfaceColor, 0.00001f), 1);
            if (CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(hitDat.surfaceColor, 0.00001f));
            throughput = 1;//max(hitDat.surfaceColor,0.00001f);
        }
    } else {
        [branch] if (CurBounce == 0 || AlbedoTexData.w == -1) {//Setting textures for denosier to use
            CurrentReservoirGI[PixIndex].PrimaryNormal = packUnormArb(Geomnorm);
            #ifdef PSR
                ScreenSpaceData TempMatModifier = {packUnormArb(ray.direction), hitDat.roughness, packUnormArb(Geomnorm), packUnormArb(norm), (CurBounce == 0 || Color.IsSpecular == 2) ? max(hitDat.surfaceColor, 0.005f) : (ScreenSpaceInfo[PixIndex].Albedo * max(hitDat.surfaceColor, 0.005f)),hitDat.metallic, pos, ((CurBounce == 0) ? hit.t : (ScreenSpaceInfo[PixIndex].t + hit.t)), MaterialIndex}; 
                ScreenSpaceInfo[PixIndex] = TempMatModifier;     
                // if(UseReCur) AlbedoTexData = float4(TempMatModifier.Albedo, (Case.x == 3 || (Case.x == 0 && hitDat.roughness < 0.01f && hitDat.metallic == 1 && CurBounce == 0)) ? -1 : (CurBounce + 1));
                AlbedoTexData = float4(((CurBounce == 0) ? max(throughput, 0.005f) : (max(throughput, 0.005f) * AlbedoTexData.xyz)), (Case.x == 3 || (Case.x == 0 && hitDat.roughness < 0.01f && hitDat.metallic == 1 && CurBounce == 0)) ? -1 : (CurBounce + 1));  
                if(CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(hitDat.surfaceColor, 0.005f));    
                throughput = 1;  
                CurrentReservoirGI[Index].HistoricFrameThisCase = Pack2To1(Unpack1To2(CurrentReservoirGI[Index].HistoricFrameThisCase).y, Case);
            #else
                ScreenSpaceData TempMatModifier = {packUnormArb(ray.direction), hitDat.roughness, packUnormArb(Geomnorm), packUnormArb(norm), max(hitDat.surfaceColor, 0.00001f),hitDat.metallic, pos, hit.t, MaterialIndex};
                ScreenSpaceInfo[PixIndex] = TempMatModifier;
                AlbedoTexData = float4(max(throughput, 0.00001f), 1);
                if (CurBounce == 0) CurrentReservoirGI[Index].BaseColor = packRGBE(max(throughput, 0.00001f));
                CurrentReservoirGI[Index].HistoricFrameThisCase = Pack2To1(Unpack1To2(CurrentReservoirGI[Index].HistoricFrameThisCase).y, Case);
                throughput = 1;
            #endif
        }   
    }


        [branch] if ((UseNEE) && CurBounce < MaxBounce) {//Next event estimation
        float3 pos2;
        float3 LightNorm;
        int triindex;
        bool IsAboveHorizon = true;
        bool IsDirectional = false;
        float LightPDF = 0.0f;
        bool UseUnityLight;
        int TriCount = 0;
        int MeshIndex = 0;
        float2 CurUv = 0;
        float Attenuation = 1.0f;
        bool IsSpecialized = false;
        float LightWeight = 1;
                UseUnityLight = (unitylightcount != 0) ? (LightMeshCount != 0) ? (random(11, pixel_index).x <= (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF))) : true : false;//Choose whether to sample unity lights or mesh lights based off which is more powerful
                if (UseUnityLight) {
                    triindex = SelectUnityLight(pixel_index, LightWeight, norm, pos, PrevDirection, hitDat);
                    LightData Light = _UnityLights[triindex];
                    [branch] switch (Light.Type) {
                    default:
                        pos2 = Light.Position;
                        LightNorm = normalize(ray.origin - pos2);
                        break;
                    case 1:
                        pos2 = ray.origin + Light.Direction;
                        LightNorm = -Light.Direction;
                        IsAboveHorizon = (LightNorm.y <= 0.0f);
                        IsDirectional = true;
                        break;
                    case 2:
                        pos2 = Light.Position;
                        LightNorm = Light.Direction;
                        IsAboveHorizon = false;
                        IsSpecialized = true;
                        break;
                    case 3:
                        IsSpecialized = true;
                        float3 randVector = (float3(random(43, pixel_index).x * Light.SpotAngle.x, random(43, pixel_index).y * Light.SpotAngle.y, 0)) - float3(Light.SpotAngle.x, Light.SpotAngle.y, 0) / 2;
                        float3 oldRand = randVector;
                        Light.ZAxisRotation *= PI / 180.0f;
                        randVector = float3(oldRand.x * cos(Light.ZAxisRotation) - oldRand.y * sin(Light.ZAxisRotation), oldRand.y * cos(Light.ZAxisRotation) + oldRand.x * sin(Light.ZAxisRotation), 0);
                        float3 tangent0 = cross(Light.Direction, float3(0, 1, 0));
                        if (dot(tangent0, tangent0) < 0.001f) tangent0 = cross(Light.Direction, float3(1, 0, 0));
                        tangent0 = normalize(tangent0);
                        float3 tangent1 = normalize(cross(Light.Direction, tangent0));
                        float3x3 rotationmatrix = { tangent0, tangent1, Light.Direction };
                        float3 Length = length(randVector);
                        pos2 = Light.Position + mul(normalize(randVector), rotationmatrix) * Length;// - float3(Light.SpotAngle.x, 0, Light.SpotAngle.y) / 2;
                        LightNorm = Light.Direction;
                        break;
                    }
                } else {
                    MeshIndex = SelectLightMesh(pixel_index);
                    triindex = SelectLight(MeshIndex, false, pixel_index);
                    TrianglePos CurTri = triangle_get_positions(LightTriangles[triindex].TriangleIndex + _MeshData[_LightMeshes[MeshIndex].OrigionalMesh].TriOffset);
                    float2 rand_triangle = random(24, pixel_index);
                    CurUv = sample_triangle(rand_triangle.x, rand_triangle.y);
                    pos2 = mul(_LightMeshes[MeshIndex].Inverse, float4(CurTri.pos0 + CurUv.x * CurTri.posedge1 + CurUv.y * CurTri.posedge2, 1.0f)).xyz;
                    float3 LightNormsx = i_octahedral_32(AggTris[LightTriangles[triindex].TriangleIndex + _MeshData[_LightMeshes[MeshIndex].OrigionalMesh].TriOffset].norms.x);
                    LightNorm = normalize(mul(_LightMeshes[MeshIndex].Inverse, float4(LightNormsx + CurUv.x * (i_octahedral_32(AggTris[LightTriangles[triindex].TriangleIndex + _MeshData[_LightMeshes[MeshIndex].OrigionalMesh].TriOffset].norms.y) - LightNormsx) + CurUv.y * (i_octahedral_32(AggTris[LightTriangles[triindex].TriangleIndex + _MeshData[_LightMeshes[MeshIndex].OrigionalMesh].TriOffset].norms.z) - LightNormsx), 0.0f)).xyz);
                    TriCount = (_LightMeshes[MeshIndex].IndexEnd - _LightMeshes[MeshIndex].StartIndex);
                }
            if (IsDirectional) {
                float3 DirectionAdjustment = (float3(random(23, pixel_index), random(62, pixel_index).x) - 0.5f) * _UnityLights[triindex].SpotAngle.x * 0.01f;
                pos2 += DirectionAdjustment;
            }
            float3 to_light = pos2 - ray.origin;

            float distance_to_light_squared = dot(to_light, to_light);
            float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

            to_light = to_light / distance_to_light;
            Attenuation = (IsSpecialized) ? saturate(dot(to_light, -LightNorm)) : 1;
            if (!IsDirectional && !IsAboveHorizon) {
                Attenuation = saturate(Attenuation * _UnityLights[triindex].SpotAngle.x + _UnityLights[triindex].SpotAngle.y);
                IsAboveHorizon = true;
            }

            bool validbsdf = false;
            float3 bsdf_value = 0.0f;
            float bsdf_pdf = 0.0f;
            float throwaway = 0;

            float cos_theta_light = abs(dot(to_light, LightNorm));
            float cos_theta_hit = dot(to_light, norm);
            [branch] switch (hitDat.MatType) {//Switch between different materials
                default:
                    validbsdf = evaldiffuse(to_light, cos_theta_hit, bsdf_value, bsdf_pdf);
                    bsdf_value *= hitDat.surfaceColor;
                break;
                case DisneyIndex:
                    bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
                    validbsdf = bsdf_pdf > 0;
                break;
                case CutoutIndex:
                    bsdf_value = EvaluateDisney(hitDat, -PrevDirection, to_light, hitDat.Thin == 1, bsdf_pdf, throwaway, GetTangentSpace2(norm), pixel_index);// DisneyEval(mat, -PrevDirection, norm, to_light, bsdf_pdf, hitDat);
                    validbsdf = bsdf_pdf > 0;
                break;
                case VolumetricIndex:
                    validbsdf = true;
                break;
            }

            float LightCos = abs(dot(to_light, LightNorm));
            float SurfaceCos = dot(to_light, norm);
            if (SurfaceCos > 0 && LightWeight < 10000.0f) {
                float3 Radiance;
                float NEE_pdf;
                float3 Illum;
                float RadianceIncomming;
                    if (UseUnityLight) {
                        float3 transmittance = 1;
                        if (IsDirectional) {
                            float3 Radiance = GetSkyRadiance(ray.origin, to_light, 0, SunDir, transmittance);
                        }
                        RadianceIncomming = luminance(_UnityLights[triindex].Radiance);
                        Radiance = _UnityLights[triindex].Radiance * transmittance;
                        NEE_pdf = distance_to_light_squared * LightCos / (unitylightcount) * (_UnityLights[unitylightcount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                        Illum = PrevThroughput * (Radiance * bsdf_value) / NEE_pdf * Attenuation * LightWeight;// / max(hitDat.surfaceColor, 0.0000001f);
                    }
                    else {
                        float SA = LightCos * LightTriangles[triindex].area / distance_to_light_squared;
                        NEE_pdf = (1.0f / (LightMeshCount * SA)) * (LightTriangles[triindex].pdf / _LightMeshes[MeshIndex].pdf) * (_LightMeshes[LightMeshCount - 1].CDF / (_UnityLights[unitylightcount - 1].CDF + _LightMeshes[LightMeshCount - 1].CDF));
                        Radiance = LightTriangles[triindex].radiance;
                        int MaterialIndex = LightTriangles[triindex].MatIndex + _LightMeshes[MeshIndex].MatOffset;
                        if (_Materials[MaterialIndex].MatType == VideoIndex || _Materials[MaterialIndex].EmissiveTex.x > 0) {
                            float2 BaseUv = LightTriangles[triindex].UV1 * (1.0f - CurUv.x - CurUv.y) + LightTriangles[triindex].UV2 * CurUv.x + LightTriangles[triindex].UV3 * CurUv.y;
                            if (_Materials[MaterialIndex].MatType == VideoIndex) {
                                Radiance *= VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0).xyz;
                            }
                            else {
                                float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
                                Radiance *= _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0).xyz * _EmissiveAtlas.SampleLevel(sampler_EmissiveAtlas, EmissionUV, 0).w;
                            }
                        }
                        RadianceIncomming = luminance(Radiance);
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = PrevThroughput * (Radiance * bsdf_value) / NEE_pdf * Attenuation * NEEMISWeight;// / max(hitDat.surfaceColor, 0.0000001f);
                    }
                if (CurBounce == 0) CurrentReservoirGI[Index].NEEPosition = (IsDirectional) ? (ray.origin + to_light * 10000.0f) : pos2;

                bool DoNEERR = !UseRussianRoulette;
                float maxillum = max(max(Illum.x, Illum.y), Illum.z) * A;
                if ((DoNEERR || maxillum > random(9, pixel_index).y)) {//NEE russian roulette, massively improves performance while giivng the same result
                    uint index3;//Congrats we shoot a shadow ray for NEE

                    InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
                    ShadowRaysBuffer[index3].origin = ray.origin;
                    ShadowRaysBuffer[index3].direction = to_light;
                    ShadowRaysBuffer[index3].t = (IsDirectional) ? 10000.0f : distance_to_light - 0.00001f;//2.0f * EPSILON;
                    ShadowRaysBuffer[index3].illumination = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum)));// / (CurBounce == 0 && TempAlbedoTex[Uv].xyz != 0.00001f ? TempAlbedoTex[Uv].xyz : 1);// * max(hitDat.surfaceColor,0.0000001f);
                    ShadowRaysBuffer[index3].RadianceIncomming = Illum * ((DoNEERR) ? 1 : rcp(saturate(maxillum))) * ((!UseAlteredPipeline) ? (((bsdf_value == 0) ? 1 : rcp(bsdf_value))) : (((hitDat.surfaceColor == 0) ? 1 : rcp(hitDat.surfaceColor))));
                    ShadowRaysBuffer[index3].PixelIndex = Uv.y * screen_width + Uv.x;
                    ShadowRaysBuffer[index3].LuminanceIncomming = luminance(Radiance);
                    ShadowRaysBuffer[index3].PrevPixelIndex = prevIndex;
                    ShadowRaysBuffer[index3].PrimaryNEERay = (CurBounce != AlbedoTexData.w - 1);
                }
            }

    }

        if (!valid) return;//If the ray failed, we have no choice but to terminate this path

    if (UseRussianRoulette && AlbedoTexData.w != -1 && CurBounce > 0) {
        float3 AdjustedCol = throughput * (AlbedoTexData.xyz);
        float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
        if (random(2, pixel_index).x > p)//Simple Russian Roulette
            return;
        throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
    }
    if (any(throughput > 10000.0f)) return;
    Color.throughput = throughput * (((cb && CurBounce == 0 && DoCheckerboarding) || (DoCheckerboarding && UseASVGF && RandomNums[Uv].w == 1 && CurBounce == 0)) ? 2.0f : 1);

    if (cb || !DoCheckerboarding || (UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[Uv].z == 1)) {
        uint index2;//Congrats, the ray will continue its path
        InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
        GlobalRays1[index2].origin = ray.origin;
        GlobalRays1[index2].direction = ray.direction;
        GlobalRays1[index2].PixelIndex = Uv.x + Uv.y * screen_width;
        GlobalRays1[index2].PrevIndex = prevIndex;
        GlobalRays1[index2].last_pdf = pdf;
        set(index2, hit);
    }
}

Texture2D<float4> TerrainAlphaMap;
SamplerState sampler_TerrainAlphaMap;
int MaterialCount;


[numthreads(64, 1, 1)]
void kernel_shade(uint3 id : SV_DispatchThreadID) {

    int index = id.x;
    if (index >= BufferSizes[CurBounce].tracerays) {
        return;
    }
    int PixIndex = GlobalRays1[index].PixelIndex;
    uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
    const uint pixel_index = PixIndex;//TempUv is the origional screen coordinates of the ray
    float4 AlbedoTexData = TempAlbedoTex[TempUv];
    Ray ray;
    RayHit bestHit = get(index);
    ray.origin = GlobalRays1[index].origin;
    ray.direction = GlobalRays1[index].direction;
    ray.direction_inv = float3(0.0f, 0.0f, 0.0f);//We dont need to calculate this, but we do need to give it some value or Unity complains

    #ifdef HardwareRT
        int2 Indexes = Unpack1To2(bestHit.mesh_id);
        int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.y].x + Indexes.x];
        bestHit.triangle_id += triangleOffset;
        bestHit.mesh_id = MeshOffsets[Indexes.y].y;
    #endif
    ColData Color = GlobalColors[PixIndex];
    if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
        float3 Sun, SkyBoxCol, Radiance, transmittance, Direct = 0;
        [branch]switch(BackgroundType) {
            case 0:
                Direct = 1;
                transmittance = 0;
                Sun = 0;
                Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance);// * normalize(float3(114975.3,71305.86,65311.04));
                Radiance = saturate(pow((1 - exp(-Radiance * 15.0f)),1.0f));
                SkyBoxCol = saturate(Radiance);// * Direct + trans2;
                if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) {
                    Sun = clamp((Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f)))) / 100.0f, 0, 10.0f);
                }
                if (all(SkyBoxCol > 0 || SkyBoxCol < 0 || SkyBoxCol == 0)) {
                    if (CurBounce == 0) {//Seperated into direct and indirect channels
                        Color.Direct = Color.throughput * ((SkyBoxCol)+Sun);// * transmittance2 + direct;
                    }
                    else if (CurBounce == 1) {
                        Color.Direct += Color.throughput * (SkyBoxCol)+Sun;
                        CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;
                    }
                    else {
                        Color.Indirect += Color.throughput * (SkyBoxCol)+Sun;
                    }
                }
            break;
            case 1:
                if (CurBounce == 0) {//Seperated into direct and indirect channels
                    Color.Direct = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f, acos(ray.direction.y) / -PI), CurBounce == 0 ? 0 : 4).xyz;
                }
                else if (CurBounce == 1) {
                    Color.Direct += _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f, acos(ray.direction.y) / -PI), CurBounce == 0 ? 0 : 4).xyz * BackgroundIntensity;
                    CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;
                }
                else {
                    Color.Indirect += Color.throughput * _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f, acos(ray.direction.y) / -PI), CurBounce == 0 ? 0 : 4).xyz * BackgroundIntensity;
                }
            break;
            case 2:
                if (CurBounce == 0) {//Seperated into direct and indirect channels
                    Color.Direct = BackgroundColor;
                }
                else if (CurBounce == 1) {
                    Color.Direct += BackgroundColor * BackgroundIntensity;
                    CurrentReservoirGI[TempUv.x + TempUv.y * screen_width].SecondaryHitPosition = ray.origin + ray.direction * 12.0f;
                }
                else {
                    Color.Indirect += Color.throughput * BackgroundColor * BackgroundIntensity;
                }
            break;
        }
        if (CurBounce == 0) {
            TempAlbedoTex[TempUv] = float4(Color.Direct,0);
        }
        GlobalColors[PixIndex] = Color;
        return;
    }


    float2 BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
    int MatOffset = 0;
    bool HitTerrain = false;
    if (TerrainExists && (GlobalRays1[index].HitVoxel == 2)) {
        BaseUv = float2(bestHit.u, bestHit.v);
        float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, float2(bestHit.u, bestHit.v) * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);

        MatOffset = Mats.y + Mats.z * 2 + Mats.a * 3;
        HitTerrain = true;
    }

    int MaterialIndex = (HitTerrain) ? (MaterialCount + MatOffset + Terrains[bestHit.triangle_id].MatOffset) : (_MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat);
    MaterialData TempMat = _Materials[MaterialIndex];
    if (HitTerrain) BaseUv = BaseUv * TempMat.surfaceColor.xy + TempMat.transmittanceColor.xy;

    float2 Uv = fmod((BaseUv * TempMat.AlbedoTexScale.xy + TempMat.AlbedoTexScale.zw) + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].AlbedoTex.xy - _Materials[MaterialIndex].AlbedoTex.zw) + _Materials[MaterialIndex].AlbedoTex.zw;
    float2 NormalUV = (_Materials[MaterialIndex].NormalTex.x > 0) ? fmod((BaseUv * TempMat.NormalTexScale.xy + TempMat.NormalTexScale.zw) + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].NormalTex.xy - _Materials[MaterialIndex].NormalTex.zw) + _Materials[MaterialIndex].NormalTex.zw : float2(-1, -1);
    float4 BaseCol = (TempMat.MatType == VideoIndex) ? VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0) : (TempMat.AlbedoTex.x > 0) ? (_TextureAtlas[StochasticBilinear(Uv * AtlasSize, random(54, pixel_index).x)] * ((!HitTerrain) ? float4(TempMat.surfaceColor, 1.0f) : 1)) : float4(TempMat.surfaceColor, 1.0f);
    TempMat.surfaceColor = max(min(BaseCol.xyz * BaseCol.w,1),0.005f);
    TempMat.roughness = max(TempMat.roughness, 0.00001f);
    int prevIndex = GlobalRays1[index].PrevIndex;


    if (TempMat.MetallicTex.x > 0 && TempMat.specTrans != 1) {
        float2 MetallicUV = fmod((BaseUv * TempMat.MetallicTexScale.xy + TempMat.MetallicTexScale.zw) + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].MetallicTex.xy - _Materials[MaterialIndex].MetallicTex.zw) + _Materials[MaterialIndex].MetallicTex.zw;
        TempMat.metallic = MetallicTex.SampleLevel(my_point_clamp_sampler, StochasticBilinear(MetallicUV * AtlasSize, random(54, pixel_index).x) / AtlasSize, max(CurBounce, 0));
    }
    if (TempMat.RoughnessTex.x > 0) {
        float2 RoughnessUV = fmod((BaseUv * TempMat.RoughnessTexScale.xy + TempMat.RoughnessTexScale.zw) + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].RoughnessTex.xy - _Materials[MaterialIndex].RoughnessTex.zw) + _Materials[MaterialIndex].RoughnessTex.zw;
        TempMat.roughness = saturate(RoughnessTex.SampleLevel(my_point_clamp_sampler, StochasticBilinear(RoughnessUV * AtlasSize, random(54, pixel_index).x) / AtlasSize, max(CurBounce, 0)));
    }
    // if(TempMat.metallic != 0) TempMat.roughness = 1;//max(CurBounce / (float)MaxBounce,0);

    if(AlbedoTexData.w != -1) TempMat.roughness = min(TempMat.roughness + max(CurBounce / (float)MaxBounce,0),1);
    bool IsEmissiveTex = false;
    if (TempMat.EmissiveTex.x > 0) {
        float2 EmissionUV = fmod(BaseUv + 100.0f, float2(1.0f, 1.0f)) * (_Materials[MaterialIndex].EmissiveTex.xy - _Materials[MaterialIndex].EmissiveTex.zw) + _Materials[MaterialIndex].EmissiveTex.zw;
        float3 EmissCol = _Materials[MaterialIndex].EmissionColor;
        bool IsMask = !(EmissCol.x == 0 && EmissCol.y == 0 && EmissCol.z == 0);
        float4 EmissTexture = _EmissiveAtlas[StochasticBilinear(EmissionUV * EmissiveSize, random(54, pixel_index).x)];
        if (!IsMask) EmissCol = EmissTexture.xyz * EmissTexture.w;
        else EmissCol *= EmissTexture.xyz * EmissTexture.w;
        if (dot(EmissCol, EmissCol) > 0.001f) {
            IsEmissiveTex = true;
            TempMat.surfaceColor = EmissCol;// * (IsMask ? TempMat.surfaceColor : TempMat.surfaceColor);
        }
        else {
            TempMat.emmissive = 0;
        }
    }
    else if (_Materials[MaterialIndex].EmissionColor.x != 0 || _Materials[MaterialIndex].EmissionColor.y != 0 || _Materials[MaterialIndex].EmissionColor.z != 0) {
        TempMat.surfaceColor += _Materials[MaterialIndex].EmissionColor * TempMat.surfaceColor;
    }
    if(UseReSTIRGI && CurBounce == 0 && TempMat.emmissive == 0 && ReSTIRGIUpdateRate != 0 && RandomNums[TempUv.xy].z == 1) {
        TempMat.surfaceColor = unpackRGBE(PreviousReservoirGI[prevIndex].BaseColor);  
    }
    float PrevAlbedoTex = AlbedoTexData.x;
    calcFinalColor(ray, Color, TempMat, bestHit, TempUv, NormalUV, IsEmissiveTex || (TempMat.MatType == VideoIndex), GlobalRays1[index], GlobalRays1[index].PrevIndex, GlobalRays1[index].HitVoxel == 2, pixel_index, PixIndex, MaterialIndex, AlbedoTexData);
    TempAlbedoTex[TempUv] = AlbedoTexData;
    GlobalColors[PixIndex] = Color;
}



#pragma kernel kernel_finalize


bool UseAtrous;
float IndirectBoost;

#ifdef HDRP
    Texture2DArray<float4> DiffuseGBuffer;
    Texture2DArray<float4> SpecularGBuffer;
#else
    Texture2D<float4> DiffuseGBuffer;
    Texture2D<float4> SpecularGBuffer;
#endif


Texture2D<float> Curr;
[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance

    if (id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;

    if (UseReSTIRGI) PrevDepthTex[id.xy] = ScreenSpaceInfo[final_pixel_index].t;

    if(UseReSTIRGI && ReSTIRGIUpdateRate != 0 && Unpack1To2(CurrentReservoirGI[final_pixel_index].HistoricFrameThisCase).y == 0) {
        for(int i = -1; i <= 1; i++) {
            for(int j = -1; j <= 1; j++) {
                // if(abs(j) == 1 && abs(i) == 1) continue;
                int2 Index = int2(id.x + i,id.y + j);
                CurrentReservoirGI[Index.x + Index.y * screen_width].LuminanceIncommingM = Pack2To1(Unpack1To2(CurrentReservoirGI[Index.x + Index.y * screen_width].LuminanceIncommingM).y, min(1,Unpack1To2(CurrentReservoirGI[Index.x + Index.y * screen_width].LuminanceIncommingM).x));
            }   
        }
    }
    float3 GBufferCol = 1;
    if(DiffRes) {
        float2 UV = id.xy / float2(screen_width, screen_height);
        #ifdef HDRP
            float3 SpecularAlbedo = 0;//Albedo2[int3(ipos,0)].xyz;
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        #else
            float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        #endif
    }
    float3 res = (TempAlbedoTex[id.xy].w == 0) ? TempAlbedoTex[id.xy].xyz : (((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * TempAlbedoTex[id.xy].xyz + unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay)) / GBufferCol);
    if (!all(res < 100000)) res = 0;
    Result[id.xy] = float4(res, 1.0f);
}









#pragma kernel GIReTraceKernel


[numthreads(12, 12, 1)]
void GIReTraceKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

    float2 uv = float2((id.xy) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    Ray ray = CreateCameraRay(uv, pixel_index);

    RandomNumsWrite[id.xy] = float4(curframe, pixel_index, 0, 0);
    if(curframe % ReSTIRGIUpdateRate == pixel_index % ReSTIRGIUpdateRate) {
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(id.xy,0)].xy;
        #else
            float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id.xy) / float2(screen_width, screen_height) , 0).xy;
        #endif
        uint2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
        if (prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
            RandomNumsWrite[id.xy] = float4(Unpack1To2(CurrentReservoirGI[prevIndex.x + prevIndex.y * screen_width].HistoricFrameThisCase).y, CurrentReservoirGI[prevIndex.x + prevIndex.y * screen_width].HistoricID, 1, 1);
        }
    }
    Rays[pixel_index].origin = ray.origin;
    Rays[pixel_index].direction = ray.direction;


}


#pragma kernel TransferKernel


[numthreads(1, 1, 1)]
void TransferKernel(uint3 id : SV_DispatchThreadID) {

    BufferData[0] = uint3(ceil(BufferSizes[CurBounce].tracerays / 64.0f), 1, 1);

}

#pragma kernel DepthCopyKernel

inline Ray CreateCameraRay(float2 uv) {
    // Transform the camera origin to world space
    float3 origin = mul(unity_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(unity_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

[numthreads(32, 32, 1)]
void DepthCopyKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x > screen_width || id.y > screen_height) return;
    float2 Uv = id.xy / float2(screen_width, screen_height);
    Ray ray = CreateCameraRay(Uv * 2.0f - 1.0f);
    #ifdef HDRP
        CorrectedDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth[int3(id.xy,0)].x));
    #else
        CorrectedDepthTex[id.xy] = length(ray.direction / dot(ray.direction, Forward) * LinearEyeDepth(Depth.SampleLevel(my_linear_clamp_sampler, Uv, 0).x));   
    #endif
}