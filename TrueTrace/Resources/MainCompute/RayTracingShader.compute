// #include "UnityCG.cginc"
#include "../GlobalDefines.cginc"

#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "CommonData.cginc"
#include "Materials.cginc"
#include "../Utility/Atmosphere/AtmosphereSampling.cginc"

#ifdef HDRP
    Texture2DArray<float2> MotionVectors;
#else
    Texture2D<float2> MotionVectors;
#endif



#pragma kernel kernel_shade

int BackgroundType;
int SecondaryBackgroundType;
float3 BackgroundColor;
float IndirectBoost;
float3 SecondaryBackgroundColor;
float BackgroundIntensity;
float SecondaryBackgroundIntensity;
bool ImprovedPrimaryHit;
bool ClayMode;
bool UseTransmittanceInNEE;
float OIDNBlendRatio;
//These are here purely for the Atrous
#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
bool VisabilityCheck(SmallerRay ray, float dist) {
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
        while(q.Proceed()){}

        if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) return false;
        else return true;
    #else
    return VisabilityCheckCompute(ray, dist);
    #endif
}


float FogDensity;
float3 FogColor;

float3 SampleHomo(SmallerRay ray, float maxT, int pixel_index, inout float t, inout float pdf) {
    float3 SigmaT = FogDensity * FogScale;
    float3 SigmaS = SigmaT * FogColor;
    float3 SigmaA = SigmaT - SigmaS;
    uint channel = min(floor(random(33, pixel_index).x * 3), 2);
    t = -log(1 - random(33, pixel_index).y) / SigmaT[channel];
    bool m_internal = t < maxT;
    t = min(t, maxT);
    float3 Tr = exp(-t * SigmaT);


    if(m_internal) {
        SigmaT *= Tr;
        pdf = (SigmaT.x + SigmaT.y + SigmaT.z) / 3.0f; 
    } else {
        pdf = (Tr.x + Tr.y + Tr.z) / 3.0f;
    }
    return m_internal ? SigmaS * Tr / pdf : (Tr / pdf);
}

void sampleEquiAngular( float u, float maxDistance, float3 rOrigin, float3 rDirection, float3 lightPos, inout float dist, inout float pdf )
{
    // get coord of closest point to light along (infinite) ray
    float delta = clamp(dot(lightPos - rOrigin, rDirection), 0.0, 1.0);
    
    // get distance this point is from light
    float D = distance(rOrigin + delta * rDirection, lightPos);

    // get angle of endpoints
    float thetaA = atan((0.0 - delta) / D);
    float thetaB = atan((maxDistance - delta) / D);

    // take sample
    float t = D * tan( lerp(thetaA, thetaB, u) );
    dist = delta + t;
    pdf = D / ( (thetaB - thetaA) * (D * D + t * t) );
}

#ifdef RadianceCache
inline void calcFinalColor(SmallerRay ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 id, const float last_pdf, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float4 PrevScreenData, inout PropogatedCacheData CacheInstance) {//main function
#else
inline void calcFinalColor(SmallerRay ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 id, const float last_pdf, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float4 PrevScreenData) {//main function
#endif
    #ifdef Fog
        float3 SigmaT = FogDensity * FogScale;
        float3 SigmaS = SigmaT * FogColor;
        float3 SigmaA = SigmaT - SigmaS;
    #endif
    bool CB = true;//!DoPartialRendering;
    // if(CurBounce == 0) {
    //     CB = (int(id.x)/2 + int(id.y)/2 + curframe)%2==0;
    //     if(UseASVGF || (UseReSTIRGI && ReSTIRGIUpdateRate != 0)) {
    //         if(RandomNums[id].z != 0 || RandomNums[id].w != 0) CB = true;
    //     }
    // }
    float3 PrevOrigin = ray.origin;
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 Geomnorm;
    float3 USGNorm;//Unsmoothed geometric normal
    float3 norm;
    float3x3 Inverse = transpose((float3x3)_MeshData[hit.mesh_id].W2L);
    float pdf = 0.0f;
    bool validBSDFSample;

    float3 throughput = Color.throughput;
    [branch] if (TerrainExists && hit.mesh_id == 9999999) {
        Geomnorm = GetHeightmapNormal(pos, hit.triangle_id);
        USGNorm = Geomnorm;
    } else {
        Geomnorm = GetTriangleNormal(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        USGNorm = mul(Inverse, cross(normalize(AggTris[hit.triangle_id].posedge1), normalize(AggTris[hit.triangle_id].posedge2)));
        float wldScale = rsqrt(dot(USGNorm, USGNorm));
        USGNorm = -mul(wldScale, USGNorm);
        if(dot(USGNorm, Geomnorm) < 0) USGNorm *= -1;
        if(hitDat.MatType == CutoutIndex) USGNorm = Geomnorm;
    }

    bool GotFlipped = dot(ray.direction, USGNorm) > 0.0f;
    if (GotFlipped) {USGNorm *= -1.0f; Geomnorm *= -1.0f;}//Backfacing surface

    Geomnorm = i_octahedral_32(octahedral_32(Geomnorm));
    norm = Geomnorm;

#ifdef UseTextureLOD
    if (CurBounce == 0 && !ClayMode && (hitDat.NormalTex.x > 0 || hitDat.SecondaryNormalTex.x > 0)) {//Handle Normal Maps
#else
    if (!ClayMode && (hitDat.NormalTex.x > 0 || hitDat.SecondaryNormalTex.x > 0)) {//Handle Normal Maps
#endif
        float3 LocalTan = GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = SampleTexture(BaseUv, SampleNormal, hitDat);

        float3 LocalNormIN = float3((hitDat.NormalStrength * Norm - (hitDat.NormalStrength / 2.0f)), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);

        if(hitDat.SecondaryNormalTex.x > 0) {
            float2 DetailNorm = SampleTexture(BaseUv, SampleDetailNormal, hitDat);
            float3 DetailLocalNormIN = float3((hitDat.DetailNormalStrength * DetailNorm - (hitDat.DetailNormalStrength / 2.0f)), 0.0f);
            DetailLocalNormIN.z = 1.0 - 0.5 * dot(DetailLocalNormIN, DetailLocalNormIN);
            LocalNormIN = lerp(LocalNormIN, DetailLocalNormIN, hitDat.SecondaryNormalTexBlend);
        }

        norm = clamp(normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz),-1,1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
        norm = i_octahedral_32(octahedral_32(norm));
    }
    if(CurBounce == 0 && UseASVGF && !(hitDat.metallic == 1 && hitDat.roughness < 0.05f) && hitDat.specTrans != 1 && RandomNums[id].w == 1) {
        Geomnorm = i_octahedral_32(asuint(PrevScreenData.x));
        norm = i_octahedral_32(asuint(PrevScreenData.y));
    }
        // if(CurBounce == 0) _DebugTex[id.xy] = float4(GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse) * 0.5f + 0.5f, 1.0f);


    {
        [branch]if(hitDat.MatCapTex.x > 0 && hitDat.MatCapMask.x > 0) {
            float3 worldViewUp = normalize(float3(0, 1, 0) - ray.direction * dot(ray.direction, float3(0, 1, 0)));
            float3 worldViewRight = normalize(cross(ray.direction, worldViewUp));
            
            float2 matcapUV = float2(dot(worldViewRight, norm), dot(worldViewUp, norm)) * 0.5f + 0.5;

            float4 matcap = SampleTexture(matcapUV, SampleMatCap, hitDat);
            hitDat.surfaceColor = lerp(hitDat.surfaceColor, matcap.xyz, SampleTexture(BaseUv, SampleMatCapMask, hitDat).x);
        }
    }

    float3 bsdf = 1;
    float3 bsdfmodifier = 1;
    #ifdef Fog
        bool DidScatter = false;
        float VolumeBSDF;
        float newT = hit.t;
        bool Refracted = false;
        int MaterialLobe = 2;
        throughput *= SampleHomo(ray, hit.t, pixel_index, newT, VolumeBSDF);
        // BsdfSample Thissample = initbsdf();
        if(newT == hit.t) {
    #endif
    [branch] if (hitDat.emission > 0.0f) {//if we hit a light, this ray is done
#ifdef Fog
        hitDat.emission *= exp(-hit.t * SigmaT);
#endif
        #ifdef WhiteLights
            hitDat.surfaceColor = 0.5f;
        #endif
        float3 EmissCol = hitDat.surfaceColor * hitDat.emission * LEMEnergyScale;
        if (!UseNEE) {
            if (CurBounce <= 1) Color.Direct += EmissCol;
            #ifndef RadianceCache
                if(CurBounce > 1) Color.Indirect += Color.throughput * EmissCol;
            #else
            else {
                if(!((CacheInstance.pathLength >> 7) & 0x1)) Color.Indirect += Color.throughput * EmissCol;
                else CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + EmissCol);
            }
            #endif
        } else {
            float3 a1 = mul((float3x3)inverse(_MeshData[hit.mesh_id].W2L), AggTris[hit.triangle_id].posedge1).xyz;
            float3 a2 = mul((float3x3)inverse(_MeshData[hit.mesh_id].W2L), AggTris[hit.triangle_id].posedge2).xyz;
            float a = AreaOfTriangle(float3(0,0,0), a1, a2);
            float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
            float light_pdf = 1.0f / (SA * LightMeshCount);
            #if defined(LBVH) && !defined(FasterLightSampling)
                #ifdef DoubleBufferSGTree
                    [branch]if(UseASVGF && RandomNums[uint2(pixel_index % screen_width, pixel_index / screen_width)].w == 1) CalcLightPDF(light_pdf, ray.origin, pos, ray.direction, pixel_index, hit.mesh_id, 1.0, -ray.direction, 0.0f, SGTreePrev, _MeshDataPrev);
                    else CalcLightPDF(light_pdf, ray.origin, pos, ray.direction, pixel_index, hit.mesh_id, 1.0, -ray.direction, 0.0f, SGTree, _MeshData);
                #else
                    CalcLightPDF(light_pdf, ray.origin, pos, ray.direction, pixel_index, hit.mesh_id, 1.0, -ray.direction, 0.0f, SGTree, _MeshData);
                #endif
            #else
                light_pdf *= rcp(_MeshData[hit.mesh_id].LightTriCount);
            #endif
            float w = power_heuristic(max(last_pdf,0), light_pdf);
            if (CurBounce == 0) Color.Direct += EmissCol;
            #ifdef UseBRDFLights
                else if (CurBounce == 1) Color.Direct += EmissCol * w;
                #ifndef RadianceCache
                    else Color.Indirect += Color.throughput * EmissCol * w;
                #else
                else {
                    if(!((CacheInstance.pathLength >> 7) & 0x1)) Color.Indirect += Color.throughput * EmissCol * w;
                    else CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + EmissCol * w);
                }
                #endif
            #endif
        }
        if((UseASVGF || UseReSTIRGI) && CurBounce == 0 && !(id.x == screen_width / 2 && id.y == screen_height / 2)) PrevScreenData.z = -10000.0f;
        if(luminance(EmissCol) > 2.0f) {
            if(CurBounce == 0) {
                Color.Data = EmissCol;
                Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0x7C000000)) |  ((1) << 26);  
                Color.Flags = packRGBE(EmissCol);
            }
            #ifdef RadianceCache
                else  {
                    if(!AddHitToCache(CacheInstance, PrevOrigin, random(324, pixel_index).x)) return;
                    CacheInstance.CurrentIlluminance = 0;   
                }
            #endif
            return;
        }
    }
   
    [branch]if(ClayMode) {
        // if(hitDat.specTrans == 0)
        hitDat.surfaceColor = ClayColor;
        hitDat.metallic = 0;
        hitDat.clearcoat = 0;
        hitDat.sheen = 0;
        hitDat.Specular = 0;
    }

    if(hitDat.ColorBleed != 1 && (Color.MetRoughIsSpec >> 31)) {
        float lum = lum2(hitDat.surfaceColor);
        hitDat.surfaceColor = ((lum * 255.0f) + (hitDat.ColorBleed *((hitDat.surfaceColor * 255.0f) - (lum * 255.0f)))) / 255.0f;
    }
    
    int MaterialLobe = 2;
    bool Refracted = false;
    // [branch] if(CurBounce == 0 && UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id].z != 0) {
    //     #ifdef HDRP
    //         float2 MotionVector = MotionVectors[int3(id,0)].xy;
    //     #else
    //        float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id) / float2(screen_width, screen_height) , 0).xy;
    //     #endif
    //     uint2 prevIndexDoub = int2(floor(((float2(id) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));

    //     ray.direction = normalize(CalcPos(WorldPosB[prevIndexDoub]) - (pos + USGNorm * NormalOffset));
    //     MaterialLobe = RandomNums[id].z - 1;
    //     validBSDFSample = ReconstructBsdf(hitDat, PrevDirection, ray.direction, norm, pdf, bsdf, GetTangentSpace(norm), pixel_index, MaterialLobe);
    // } else 
    validBSDFSample = SampleDisney(hitDat, ray.direction, GetFlag(hitDat.Tag, Thin), pdf, bsdf, norm, MaterialLobe, pixel_index, Refracted, GotFlipped);
    {
        if (CurBounce == 0) {
            float Metallic = saturate(hitDat.metallic + ((!UseASVGF || UseReSTIRGI) ? 0 : hitDat.Specular));
            if (MaterialLobe == 3) Color.MetRoughIsSpec = ToColorSpecPackedAdd(float3(0, Refracted ? 0.6f : 0.39f, 2 + !Refracted), Color.MetRoughIsSpec);
            else Color.MetRoughIsSpec = ToColorSpecPackedAdd(float3(Metallic, hitDat.roughness, MaterialLobe), Color.MetRoughIsSpec);
        }

        if (Refracted) {
            Geomnorm *= -1;
            norm *= -1;
            USGNorm *= -1;
        } else if (GetBounceData(Color.MetRoughIsSpec) <= 1 && MaterialLobe == 3) {
            Color.MetRoughIsSpec = ToColorSpecPackedAdd(float3(0, 0, 3), Color.MetRoughIsSpec);
        }
        if (MaterialLobe != 3 && !(MaterialLobe == 0 && hitDat.roughness < 0.2f)) {
            Color.MetRoughIsSpec |= 1 << 31;
        }
        Color.InWaterDistance += hit.t;
        if(!GetFlag(hitDat.Tag, Thin)) {
            int WaterStageFlag = (Color.MetRoughIsSpec & 0x3800000) >> 23;
            if(GotFlipped) {
                if((MaterialLobe == 2 && Refracted) || MaterialLobe == 3 || (WaterStageFlag == 2 || WaterStageFlag == 4)) {
                    bsdf *= exp(-Color.InWaterDistance * CalculateExtinction((MaterialLobe == 2 && Refracted) ? (hitDat.transmittanceColor) : (1.0f - (bsdf * hitDat.surfaceColor)), hitDat.scatterDistance == 0.0f ? 1.0f : hitDat.scatterDistance));
                    //MAY WANNA CHANGE THE MATLOBE == 2 TO MATLOBE == 3 AS WELL^^
                    bsdfmodifier = bsdf;
                    if(!(WaterStageFlag == 2 || WaterStageFlag == 4)) WaterStageFlag = 3 + !Refracted;
                    Color.InWaterDistance = 0;
                }
            }
            if((Refracted)) {
                Color.InWaterDistance = 0;
                if(GotFlipped) WaterStageFlag == 2;
                else WaterStageFlag = 1;
            }

            Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0x3800000)) | (WaterStageFlag << 23);
        }

        // bsdf *= bsdfmodifier;
        throughput *= bsdf;
    }
    #ifdef Fog
        } else {
            validBSDFSample = true;
            pos = ray.origin + ray.direction * (newT * 0.99f);
            ray.direction = normalize(SampleDirectionSphere(random(75, pixel_index).x, random(75, pixel_index).y));
            pdf = 1.0f / (PI * 4.0f);
            norm = ray.direction;
            ray.origin = pos;
            hitDat.surfaceColor = FogColor;
            hitDat.metallic = 0;
            hitDat.roughness = 1;
            DidScatter = true;
        }
        pdf *= VolumeBSDF;
    #endif


    ray.origin = USGNorm * NormalOffset + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of
    throughput = max(throughput, 0);
    [branch] if (CurBounce == 0 || GetBounceData(Color.MetRoughIsSpec) == 0) {//Setting textures for denosier to use
        #ifdef TrueBlack
            Color.Flags = packRGBE((CurBounce == 0) ? hitDat.surfaceColor : (unpackRGBE(Color.Flags) * hitDat.surfaceColor));
            Color.Data = float3((CurBounce == 0) ? throughput : (throughput * Color.Data.xyz));
        #else
            Color.Flags = packRGBE((CurBounce == 0) ? max(hitDat.surfaceColor, 0.005f) : (unpackRGBE(Color.Flags) * max(hitDat.surfaceColor, 0.005f)));
            Color.Data = float3((CurBounce == 0) ? max(throughput, 0.006f) : (max(throughput, 0.005f) * Color.Data.xyz));
        #endif
        PrevScreenData = float4(asfloat(octahedral_32(((hitDat.diffTrans != 0 || CurBounce == 0) && Refracted) ? -Geomnorm : Geomnorm)), asfloat(octahedral_32(((hitDat.diffTrans != 0 || CurBounce == 0) && Refracted) ? -norm : norm)),PrevScreenData.z + hit.t, asfloat((CurBounce == 0 ? ((uint)(MaterialIndex << 4) >> 4) : ((asuint(PrevScreenData.w) << 4) >> 4)) | ((CurBounce != 0 ? ((asuint(PrevScreenData.w) << 1) >> 30) :  (uint)MaterialLobe) << 29) | (Refracted << 31))); 
        Color.MetRoughIsSpec = ((Color.MetRoughIsSpec & ~(0x7C000000)) | (((CurBounce < 30 && UseASVGF && ((MaterialLobe == 3 && hitDat.roughness < 0.25f) || (hitDat.metallic == 1 && MaterialLobe == 0 && hitDat.roughness < 0.01f && CurBounce == 0))) ? 0 : (CurBounce + 2)) << 26)) | (Refracted << 22);  
        throughput = 1;  
    }   
    #ifdef RadianceCache
        #if DebugView == DVRadCache
            if(CurBounce == 0) _DebugTex[id.xy] = float4(ray.origin, asfloat(octahedral_32(norm)));
        #endif
        if(CurBounce > 0 && (CacheInstance.pathLength >> 5) & 0x1) {
            float3 res2 = 0;
            #ifdef AdvancedRadCacheAlt
            if((hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(326, pixel_index).x))) {// && (hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(326, pixel_index).x))) {
            #else
            if((all(Color.Indirect == 0) || CurBounce < 3) && (hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(326, pixel_index).x))) {// && (hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(326, pixel_index).x))) {
            #endif
                if(RetrieveCacheRadiance(CacheInstance, ray.origin, Refracted ? -norm : norm, res2)) {
                    // CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + Color.Data * throughput * res2);//fabled "infinite bounce" - VERY hard to weight properly
                    Color.Indirect += (Color.throughput) * res2 * bsdfmodifier;
                    #ifdef HighSpeedRadCache
                        if(!all(Color.Indirect == 0)) {
                            if(!((int(id.x)/2 + int(id.y)/2 + curframe)%7==0)) return;
                            else throughput *= 7;
                        }
                    #endif
                }
            } else {
                #ifdef HighSpeedRadCache
                    if(!((int(id.x)/2 + int(id.y)/2 + curframe)%7==0)) return;
                #endif
            }
            CacheInstance.pathLength |= (1u << 6);
        } else if((!(MaterialLobe == 0 && hitDat.roughness < 0.2f) && MaterialLobe != 3)) CacheInstance.pathLength |= (1u << 5);

        if(CurBounce > 0) {
            if((CacheInstance.pathLength >> 6) & 0x1) {
                CacheInstance.pathLength |= (1u << 7);
                // if((UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id.xy].z != 0)) CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) / (float)(ReSTIRGIUpdateRate - 1));
                if(!AddHitToCache(CacheInstance, PrevOrigin, random(324, pixel_index).y)) return;
                CacheInstance.CurrentIlluminance = 0;
            }
        }

        CacheInstance.Norm = octahedral_32(Refracted ? -norm : norm);
    #endif
    if (!validBSDFSample) return;//If the ray failed, we have no choice but to terminate this path
    pos = ray.origin;
      [branch] if ((UseNEE) && CurBounce < MaxBounce && (SecondaryBackgroundType == 1 || unitylightcount + LightMeshCount != 0)) {//Next event estimation
        float3 LightNorm;
        float3 LightPosition;
        int LightFormat = TRILIGHT;
        float3 Radiance;
        float RunningWeight = 1;
        float area = 1;
        float3 MiscInfo = 0;
        int AggTriIndex = 0;
        int SelectedLightGroup = 0;//0 = primitive, 1 = point, spot, etc., 2 = skybox
        int selectionoptions = 0;
        int selections[3] = {0,0,0};
        if(LightMeshCount != 0 && LEMEnergyScale != 0) selections[selectionoptions++] = 0;
        if(unitylightcount != 0) selections[selectionoptions++] = 1;
        if(SecondaryBackgroundType == 1) selections[selectionoptions++] = 2;
        RunningWeight = selectionoptions;
        SelectedLightGroup = selections[min(floor(random(114, pixel_index).x * (float)selectionoptions), selectionoptions - 1)];

        if (SelectedLightGroup == 1) {//we only really need to precompute this, right? maybe we can do a similar optimization as ReSTIR DI?
            AggTriIndex = SelectUnityLight(pixel_index, RunningWeight, norm, pos, PrevDirection);
            LightData Light = _UnityLights[AggTriIndex];
            float sinPhi, cosPhi;
            LightPosition = Light.Position;
            LightNorm = Light.Direction;
            LightFormat = Light.Type;
            Radiance = Light.Radiance / PI;
            float3 RandVec = float3(random(115, pixel_index), random(116, pixel_index).x);
            MiscInfo = float3(Light.Softness * 120.0f + 1, Light.SpotAngle);
            if(LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) {
                sincos(Light.ZAxisRotation, sinPhi, cosPhi);
            }
            [branch] switch (LightFormat) {
                case POINTLIGHT:
                    LightNorm = normalize(pos - LightPosition);
                    LightPosition += normalize(RandVec - 0.5f) * random(116, pixel_index).y * Light.Softness * 0.1f;//Soft Shadows
                break;
                case DIRECTIONALLIGHT:
                    LightPosition = pos + LightNorm;
                    LightNorm = -LightNorm;
                     sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * Light.Softness* 0.01f;
                    if(Light.Softness* 0.01f > 0.001f) {
                        LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    }
                    if(UseTransmittanceInNEE) Radiance *= GetSkyTransmittance(pos, -LightNorm, 0, -LightNorm);
                break;
                case SPOTLIGHT:
                    Radiance *= ((1.0f - MiscInfo.z * 0.0174533) + (MiscInfo.y * 0.0174533 - MiscInfo.z * 0.0174533) / 2.0f);
                    LightPosition += normalize(RandVec - 0.5f) * random(116, pixel_index).y * Light.Softness * 0.1f;//Soft Shadows
                break;
                case AREALIGHTQUAD:
                    RandVec.xy = RandVec.xy * Light.SpotAngle - Light.SpotAngle / 2.0f;
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy);
                    LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    area = (Light.SpotAngle.x * Light.SpotAngle.y);
                    if(hitDat.MatType == 3) Radiance = 0;
                    Radiance *= PI;
                break;
                case AREALIGHTDISK:
                    sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * Light.SpotAngle.x;
                    LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    area = PI * Light.SpotAngle.x * Light.SpotAngle.x;
                break;
            }
            // float newt = hit.t;
            // float newPDF = 1;
            // sampleEquiAngular(random(321, pixel_index).x, hit.t, PrevOrigin, PrevDirection, LightPosition, newt, newPDF);
            // if(hit.t != newt) {
            //     pos = PrevOrigin + PrevDirection * newt;
            //     norm = normalize(LightPosition - pos);
            // }
            //     // RunningWeight *= newPDF;


        } else if(SelectedLightGroup == 0) {
            #ifdef LBVH
                int MeshIndex;
                float4x4 MeshTransformInverse;
            #else
                int MeshIndex = SelectLightMeshSmart(pixel_index, RunningWeight, pos);
                float4x4 MeshTransformInverse = _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].W2L;
            #endif
            float ax, ay;
            CalculateAnisotropicParams(hitDat.roughness, hitDat.anisotropic, ax, ay);
            AggTriIndex = SelectLight(pixel_index, MeshIndex, RunningWeight, norm, pos, MeshTransformInverse, Radiance, LightPosition, float2(ax, ay), -PrevDirection, (saturate(hitDat.metallic + hitDat.Specular + hitDat.clearcoat)));
            #ifdef LBVH
                MeshTransformInverse = _MeshData[MeshIndex].W2L;
            #endif
            Radiance *= LEMEnergyScale;
            TrianglePos CurTri = triangle_get_positions(AggTriIndex);
            MeshTransformInverse = inverse(MeshTransformInverse);
            float3 a0 = mul(MeshTransformInverse, float4(CurTri.pos0, 1)).xyz;
            float3 a1 = mul(MeshTransformInverse, float4(CurTri.pos0 + CurTri.posedge1, 1)).xyz;
            float3 a2 = mul(MeshTransformInverse, float4(CurTri.pos0 + CurTri.posedge2, 1)).xyz;
            area = AreaOfTriangle(a0, a1, a2);
            LightPosition = mul(MeshTransformInverse, float4(LightPosition,1));
            LightNorm = normalize(mul((float3x3)MeshTransformInverse, normalize(cross(CurTri.posedge1, CurTri.posedge2))).xyz);
        } else {
            LightFormat = DIRECTIONALLIGHT;
            AggTriIndex = 0;
            Radiance = SampleLI(pixel_index, RunningWeight, LightNorm) * SecondaryBackgroundIntensity;
            LightPosition = pos - LightNorm;
        }


        if(AggTriIndex != -1) {
            float3 to_light = LightPosition - pos;

            float distance_to_light_squared = dot(to_light, to_light);
            float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

            to_light = to_light / distance_to_light;

            if(LightFormat == SPOTLIGHT) {
                float3 LocalLight = ToLocal(GetTangentSpace(LightNorm), -to_light) * 0.5f + 0.5f;
                float2 AlignedUV = AlignUV(LocalLight.xz, float4(1,1,0,0), _UnityLights[AggTriIndex].IESTex);
                if(AlignedUV.x != -1) Radiance *= _IESAtlas.SampleLevel(my_point_clamp_sampler, AlignedUV, 0);
            }
            
            float SurfaceCos = dot(to_light, norm);//YES KEEP THIS, IT NOT ONLY IMPROVES PERFORMANCE BUT IT ALSO HELPS KEEPS THINGS LESS BIASED AS OTHERWISE THE NORMAL OFFSET CAN RESULT IN WRONG VISABILITY!
        #ifdef IgnoreBackfacing
            if(SurfaceCos > 0 && (dot(to_light, LightNorm) > 0 || LightFormat != TRILIGHT)) {
        #else
            if(SurfaceCos > 0) {
        #endif
                float bsdf_pdf = 0.0f;
                float3 bsdf_value = 0.0f;
                float3 bsdf_diffuse = 0;
                #ifndef RadianceCache
                    if((UseReSTIRGI && CurBounce == 0) || (UseASVGF && (CurBounce == GetBounceData(Color.MetRoughIsSpec) - 2 && CurBounce > 0))) hitDat.surfaceColor = 1.0f;
                #endif
                bool validbsdfNEE;
                #ifdef RadianceCache
                    // if(CurBounce != 0) {
                        // if(hitDat.roughness > 0.6f || CurBounce == 0) validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_diffuse, pixel_index);
                        validbsdfNEE = EvaluateBsdf2(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_diffuse, pixel_index);
                        // bsdf_value /= bsdf_pdf;
                    //} else 
                    bsdf_pdf = 0;
                    validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_value, pixel_index);
                #else
                    validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_value, pixel_index);
                #endif
                #ifndef RadianceCache
                    if((UseASVGF && (CurBounce == GetBounceData(Color.MetRoughIsSpec) - 2 && CurBounce > 0))) bsdf_value *= Color.Data.xyz;
                #endif

                if (validbsdfNEE) {
                    float NEE_pdf;
                    float3 Illum;
                    [branch]if (SelectedLightGroup == 1) {
                        NEE_pdf = 1.0f / (abs(dot(to_light, LightNorm)) * area / distance_to_light_squared);
                        Illum = (Radiance * bsdf_value) / NEE_pdf * RunningWeight;
                        bsdf_diffuse = (Radiance * bsdf_diffuse) / NEE_pdf * RunningWeight;
                    } else if(SelectedLightGroup == 0) {        
                        NEE_pdf = (1.0f / ((abs(dot(to_light, LightNorm)) * area) / distance_to_light_squared)) / RunningWeight;
                        #ifndef LBVH
                            NEE_pdf /= LightMeshCount;
                        #endif
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = (Radiance * bsdf_value) / NEE_pdf;
                        bsdf_diffuse = (Radiance * bsdf_diffuse) / NEE_pdf;
                        #ifdef UseBRDFLights
                            Illum *= NEEMISWeight;
                            bsdf_diffuse *= NEEMISWeight;
                        #endif
                    } else {
                        NEE_pdf = HDRIParams.x * HDRIParams.y * equirectDirectionPdf(to_light) * (luminance(Radiance) / TotSum[0]);
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = (Radiance * bsdf_value) / NEE_pdf * RunningWeight * NEEMISWeight;
                        bsdf_diffuse = (Radiance * bsdf_diffuse) / NEE_pdf * RunningWeight * NEEMISWeight;
                    }
                    #ifndef RadianceCache
                    #endif
                        Illum *= Color.throughput * bsdfmodifier;
                        bsdf_diffuse *= Color.throughput * bsdfmodifier;

                    if(LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) {
                        Illum *= pow(saturate(dot(to_light, -LightNorm)), MiscInfo.x);
                        bsdf_diffuse *= pow(saturate(dot(to_light, -LightNorm)), MiscInfo.x);
                    }
                    if (LightFormat == SPOTLIGHT) {
                        bsdf_diffuse *= saturate(saturate(dot(to_light, -LightNorm)) * MiscInfo.y + MiscInfo.z);
                        Illum *= saturate(saturate(dot(to_light, -LightNorm)) * MiscInfo.y + MiscInfo.z);
                    }
#ifdef Fog
                    Illum *= exp(-((LightFormat == DIRECTIONALLIGHT ? 1.0f : distance_to_light - 0.01f) + newT) * SigmaT);
#endif
                    float maxillum = max(max(Illum.x, Illum.y), Illum.z);
                    if(DoExposure) maxillum *= Exposure[0];
                    if(!UseRussianRoulette || (CurBounce == 0 && ImprovedPrimaryHit)) maxillum = 1;
                    Illum *= rcp(saturate(maxillum));
                    bsdf_diffuse *= rcp(saturate(maxillum));
                        #ifdef RadianceCache
                            if(!UseASVGF && CurBounce > 1 && (((CacheInstance.pathLength >> 5) & 0x1) && !((CacheInstance.pathLength >> 6) & 0x1))) {
                                Illum *= Color.Data.xyz;
                                // bsdf_diffuse *= Color.Data.xyz;
                            }
                        #endif
                    if(luminance(Illum) != 0 && maxillum > random(117, pixel_index).y) {//NEE russian roulette, massively improves performance while giivng the same result
                        uint index3;
                        #ifdef RadianceCache
                            bool TempTemp = !(((CacheInstance.pathLength >> 5) & 0x1) && !((CacheInstance.pathLength >> 6) & 0x1));
                            if(UseReSTIRGI && !TempTemp && CurBounce == 0) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    
                        #else
                            bool TempTemp = (CurBounce != GetBounceData(Color.MetRoughIsSpec) - 2);
                            if(UseReSTIRGI && CurBounce == 0) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    
                        #endif            
                        ShadowRayData ShadRay = {pos, 
                                                        packRGBE(bsdf_diffuse), 
                                                        to_light, 
                                                        (LightFormat == DIRECTIONALLIGHT ? 10000.0f : distance_to_light - ShadowDistanceFudgeFactor) * (TempTemp ? 1 : -1),
                                                        Illum, 
                                                        pixel_index};
                        if(abs(ShadRay.t) > 0.001f) {
                            InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
                            ShadowRaysBuffer[index3] = ShadRay;
                        }
                    }
                }
            }
        }
    }



    if (CurBounce > 0 && UseRussianRoulette && GetBounceData(Color.MetRoughIsSpec) != 0) {
        float3 AdjustedCol = throughput * (ImprovedPrimaryHit ? 1.0f : Color.Data.xyz);
        float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
        if (random(118, pixel_index).x > p)//Simple Russian Roulette
            return;
        throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
        #ifdef RadianceCache
            #ifdef AdvancedRadCacheAlt
                float3 bsdf2 = 1;
                float bsdfpdf2 = 1;
                if(!EvaluateBsdf2(hitDat, PrevDirection, ray.direction, norm, bsdfpdf2, bsdf2, pixel_index)) bsdf2 = 0;
                CacheInstance.samples[0].x = EncodeRGB(clamp(bsdf2 * rcp(p),0,2));
            #else
                CacheInstance.samples[0].x = EncodeRGB(clamp(bsdf * rcp(p),0,2));
            #endif
        #endif
    } else {
        #ifdef RadianceCache
            #ifdef AdvancedRadCacheAlt
                float3 bsdf2 = 1;
                float bsdfpdf2 = 1;
                if(!EvaluateBsdf2(hitDat, PrevDirection, ray.direction, norm, bsdfpdf2, bsdf2, pixel_index)) bsdf2 = 0;
                CacheInstance.samples[0].x = EncodeRGB(clamp(bsdf2,0,2));
            #else
                CacheInstance.samples[0].x = EncodeRGB(clamp(bsdf,0,2));
            #endif
        #endif
    }
    Color.throughput = throughput;

    if(CB) {
        uint index2;//Congrats, the ray will continue its path
        InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
        const RayData GlobalRay = {ray.origin, pixel_index, ray.direction, pdf,set2(hit)};
        [branch]if(CurBounce % 2 == 0) index2 += screen_width * screen_height;
        GlobalRays[index2] = GlobalRay;
    }
}
static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0};

float3 PrimaryBackgroundTintColor;
float PrimaryBackgroundTint;
float PrimaryBackgroundContrast;

#ifdef DX11
[numthreads(64, 1, 1)]
#else
[numthreads(32, 1, 1)]
#endif
void kernel_shade(uint3 id : SV_DispatchThreadID) {

    if (CurBounce != 0 && (id.x >= BufferSizes[CurBounce - 1].tracerays)) return;
    [branch]if(CurBounce % 2 == 1) id.x += screen_width * screen_height;
    const RayData GlobRay = GlobalRays[id.x];
    uint pixel_index = GlobRay.PixelIndex;
    id.xy = uint2(pixel_index % screen_width, pixel_index / screen_width);
    SmallerRay ray;
    RayHit bestHit = get2(GlobRay.hits);
    ray.origin = GlobRay.origin;
    ray.direction = GlobRay.direction;
    if(CurBounce == 0 && UseReSTIRGI) ScreenSpaceInfo[id.xy].w = asfloat(0);

    #ifdef HardwareRT
        if(bestHit.mesh_id != 9999999) {
            int2 Indexes = int2(bestHit.mesh_id & 0x0000FFFF, bestHit.mesh_id >> 16);
            int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
            bestHit.triangle_id += triangleOffset;
            bestHit.mesh_id = MeshOffsets[Indexes.x].y;
        }
    #endif
    ColData Color = InitCol;
    if(CurBounce > 0) Color = GlobalColors[pixel_index];
    #ifdef RadianceCache
        else {
            CacheBuffer[pixel_index].pathLength = 0;
            CacheBuffer[pixel_index].CurrentIlluminance = 0;
        }
    #endif


    #if DebugView != -1
        #if DebugView == DVDepthView
            if(CurBounce == 0) _DebugTex[id.xy] = bestHit.t / DepthDivisor;
        #endif
    #endif

int MaterialIndex;
#ifdef AdvancedBackground
    bool BackgroundCheck = false;
    if(bestHit.t != FarPlane && !(TerrainExists && (bestHit.mesh_id == 9999999))) {
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat;
        if(GetFlag(_Materials[MaterialIndex].Tag, IsBackground) && (Color.MetRoughIsSpec >> 31)) BackgroundCheck = true;
    }
    if (bestHit.t == FarPlane || BackgroundCheck) {//if ray goes into the void, sample skybox
#else
    if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
#endif
        float3 Radiance, transmittance, debug = 0;
        float Stars;
        float2 uv;
        float mis = 1;
        float3 rayorig2 = ray.origin;
        rayorig2.y += bottom_radius;
        bool DoSecondary = !(Color.MetRoughIsSpec >> 31);
        float Intensity = DoSecondary ? BackgroundIntensity : SecondaryBackgroundIntensity;
        float TrueDeSat = DoSecondary ? SkyDesaturate : SecondarySkyDesaturate;
        if(CurBounce != 0 && IndirectBoost < 1) Intensity *= rcp(IndirectBoost);
        float3 Sun = 0;
        // float4 curprojectedrefl = mul(viewprojection, float4(ray.origin + SunDir * FarPlane, 1));
        // float2 reflprojection = ((curprojectedrefl.xy / curprojectedrefl.w));
        [branch]switch(DoSecondary ? BackgroundType : SecondaryBackgroundType) {
            case 0:
                Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance, debug);
                Radiance += debug;
                Radiance = pow(1.0f - exp(-Radiance / 1.0f * 10.0f), 1.0f);
                if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) {
                    Sun = clamp((Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f)))) / (CurBounce == 0 ? 10.0f : 100.0f), 0, CurBounce == 0 ? 1000.0f : 10.0f);
                }
                Radiance += Sun;
                Stars = stars(ray.origin, ray.direction, toSpherical(ray.direction.xzy).yz, 0) * (1.0f - tanh_approx(0));
                Stars *= max(12.0f * pow(1.0f - saturate(pow(RayleighPhaseFunction(dot(ray.direction, SunDir)) * MiePhaseFunction(0.8f, dot(ray.direction, SunDir)),0.1f)),2.0f) * transmittance * -dot(rayorig2, SunDir) / length(rayorig2), 0);
                Stars = pow(saturate(Stars), 2.0f);
                if(GetBounceData(Color.MetRoughIsSpec) <= 1) Radiance += Stars;

                if (all(Radiance < 10000.0f)) {
                    Radiance = DeSat(Radiance, 1.0f - TrueDeSat);
                    if(DoSecondary) {
                        Unity_Contrast_float(Radiance, PrimaryBackgroundContrast);
                        Radiance = lerp(Radiance, PrimaryBackgroundTintColor, PrimaryBackgroundTint);
                    }
                    Radiance *= Intensity;
                    if (CurBounce == 0) Color.Direct = Color.throughput * Radiance;
                    else if (CurBounce == 1) Color.Indirect += Color.throughput * Radiance;
                    #ifdef RadianceCache
                        else if(!((CacheBuffer[pixel_index].pathLength >> 7) & 0x1) || (((Color.MetRoughIsSpec & 0x3800000) >> 23) >= 3)) Color.Indirect += Color.throughput * DeSat(Radiance, 1.0f - TrueDeSat) * Intensity;
                        else  {
                            AddMissToCache(CacheBuffer[pixel_index], Radiance);
                        }
                    #else
                        else Color.Indirect += Color.throughput * Radiance;
                    #endif
                }
            break;
            case 1:
                uv = equirectDirectionToUv(ray.direction);
                uv = fmod(uv * HDRIScale + HDRILongLat / 360.0f, 1.0f);
                if(UseNEE && CurBounce > 0)
                    mis = power_heuristic(GlobRay.last_pdf, HDRIParams.x * HDRIParams.y * equirectDirectionPdf(ray.direction) * (luminance(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz) / TotSum[0]));
                Radiance = DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz,1.0f - TrueDeSat);
                if(DoSecondary) {
                    Unity_Contrast_float(Radiance, PrimaryBackgroundContrast);
                    Radiance = lerp(Radiance, PrimaryBackgroundTintColor, PrimaryBackgroundTint);
                }
                Radiance *= Intensity;
                if (CurBounce == 0) Color.Direct = Radiance;
                else if (CurBounce == 1) Color.Direct += Radiance * mis;
                else Color.Direct += Color.throughput * Radiance * mis;
                #ifdef RadianceCache
                    AddMissToCache(CacheBuffer[pixel_index], Radiance * mis);
                #endif
            break;
            case 2:
                Radiance = DeSat((DoSecondary ? BackgroundColor : SecondaryBackgroundColor), 1.0f - TrueDeSat);
                if(DoSecondary) {
                    Unity_Contrast_float(Radiance, PrimaryBackgroundContrast);
                    Radiance = lerp(Radiance, PrimaryBackgroundTintColor, PrimaryBackgroundTint);
                }
                Radiance *= Intensity;
                if (CurBounce == 0) Color.Direct = Radiance;
                else if (CurBounce == 1) Color.Direct += Radiance;
                else Color.Indirect += Color.throughput * Radiance;
                #ifdef RadianceCache
                    AddMissToCache(CacheBuffer[pixel_index],  Radiance);
                #endif
            break;
        }
        if(CurBounce == 0) {
            Color.Data = float3(Color.Direct);
            Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0x7C000000)) |  ((1) << 26);  
            Color.Flags = packRGBE(Color.Direct);
        }
        if(GetBounceData(Color.MetRoughIsSpec) == 0) {
            ScreenSpaceInfo[id.xy] = float4(ScreenSpaceInfo[id.xy].xyz, asfloat((asuint(ScreenSpaceInfo[id.xy].w) << 1) >> 1));//PrevScreenData.z + hit.t, asfloat((CurBounce == 0 ? ((uint)(MaterialIndex << 2) >> 2) : ((asuint(PrevScreenData.w) << 3) >> 3)) | ((CurBounce != 0 ? ((asuint(PrevScreenData.w) << 1) >> 30) :  (uint)MaterialLobe) << 29) | (Refracted << 31))); 
            Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0x7C000000)) |  ((2) << 26);  

        }
        GlobalColors[pixel_index] = Color;
        if(UseReSTIRGI && CurBounce == 1 && GetBounceData(Color.MetRoughIsSpec) == 0) {
            ScreenSpaceInfo[id.xy] = float4(ScreenSpaceInfo[id.xy].xyz, asfloat(packRGBE(max(Color.throughput, 0.005f)))); 
        }
        return;
    }



    float2 BaseUv;
    bool HitTerrain = false;
    MaterialData TempMat;
    [branch]if (TerrainExists && (bestHit.mesh_id == 9999999)) {//if hit terrain
        BaseUv = float2(bestHit.u, bestHit.v);
        float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, BaseUv * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);
        int x = 0;
        float minmat = Mats.x;
        if(minmat < Mats.y) {
            minmat = Mats.y;
            x = 1;
        }
        if(minmat < Mats.z) {
            minmat = Mats.z;
            x = 2;
        }
        if(minmat < Mats.a) {
            minmat = Mats.a;
            x = 3;
        }

        minmat = 0;
        float3 BaseCol = 0;
        MaterialIndex = MaterialCount + Terrains[bestHit.triangle_id].MatOffset;
        if(Mats.x > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex]) * Mats.x;
        if(Mats.y > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex + 1]) * Mats.y;
        if(Mats.z > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex + 2]) * Mats.z;
        if(Mats.w > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex + 3]) * Mats.w;
        MaterialIndex += x;
        TempMat = _Materials[MaterialIndex];
        BaseUv = BaseUv * TempMat.surfaceColor.xy + TempMat.transmittanceColor.xy;
        TempMat.surfaceColor = BaseCol;
        HitTerrain = true;
    } else {
        BaseUv = TOHALF(AggTris[bestHit.triangle_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTris[bestHit.triangle_id].texedge1) * bestHit.u + TOHALF(AggTris[bestHit.triangle_id].texedge2) * bestHit.v;
#ifndef AdvancedBackground
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat;
#endif
        TempMat = _Materials[MaterialIndex];

        float3 TempCol = 1;
        if(TempMat.AlbedoTex.x > 0) TempCol = SampleTexture(BaseUv, SampleAlbedo, TempMat);
        if(TempMat.SecondaryAlbedoTex.x > 0) {
            float AlbMaskVal = TempMat.AlbedoBlendFactor;
            if(TempMat.SecondaryAlbedoMask.x > 0) {
                AlbMaskVal = SampleTexture(BaseUv, SampleSecondaryAlbedoMask, TempMat).x;
            }
            float3 SecondaryVal = SampleTexture(BaseUv, SampleSecondaryAlbedo, TempMat).xyz;
            switch(GetFlagStretch(TempMat.Tag, 1, 3)) {
                case 0:
                    TempCol = lerp(TempCol, SecondaryVal, AlbMaskVal);
                break;
                case 1:
                    if(AlbMaskVal > 0.5f || !(TempMat.SecondaryAlbedoMask.x > 0))
                        TempCol += SecondaryVal;
                break;
                case 2:
                    if(AlbMaskVal > 0.5f || !(TempMat.SecondaryAlbedoMask.x > 0))
                        TempCol *= SecondaryVal;
                break;
            }
        }
        if(GetFlag(TempMat.Tag, VertexColors)) TempCol *= unpackRGBE(AggTris[bestHit.triangle_id].VertColA) * (1.0f - bestHit.u - bestHit.v) + unpackRGBE(AggTris[bestHit.triangle_id].VertColB) * bestHit.u + unpackRGBE(AggTris[bestHit.triangle_id].VertColC) * bestHit.v;
        TempMat.surfaceColor *= TempCol;

        TempCol = TempMat.surfaceColor;
        #ifndef DX11
            Unity_Hue_Degrees_float(TempCol, TempMat.Hue * 500.0f, TempMat.surfaceColor);
        #endif
        TempMat.surfaceColor *= TempMat.Brightness;
        TempCol = TempMat.surfaceColor;
        Unity_Saturation_float(TempCol, TempMat.Saturation, TempMat.surfaceColor);
        Unity_Contrast_float(TempMat.surfaceColor, TempMat.Contrast);
        TempMat.surfaceColor = saturate(TempMat.surfaceColor);
        TempMat.surfaceColor = lerp(TempMat.surfaceColor, TempMat.BlendColor, TempMat.BlendFactor);
    }

    #if DebugView != -1
        #if DebugView == DVMatID
            if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(MaterialIndex);
        #elif DebugView == DVMeshID
            if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(bestHit.mesh_id);
        #elif DebugView == DVTriID
            if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(bestHit.triangle_id);
        #elif DebugView == DVAlbID
            if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(TempMat.AlbedoTex.x);
        #elif DebugView == DVDepthView
            // if(CurBounce == 0) _DebugTex[id.xy] = bestHit.t / DepthDivisor;
        #endif
    #endif


    if (TempMat.specTrans != 1 && TempMat.MetallicTex.x > 0) TempMat.metallic = pow(SampleTexture(BaseUv, SampleMetallic, TempMat), rcp(2.2f));
    if (TempMat.RoughnessTex.x > 0) {
        TempMat.roughness = saturate(pow(SampleTexture(BaseUv, SampleRoughness, TempMat), rcp(2.2f)));
        TempMat.roughness = (GetFlag(TempMat.Tag, InvertSmoothnessTexture) ? (1.0f - TempMat.roughness) : TempMat.roughness);
    }
    TempMat.metallic = saturate(TempMat.metallic);
    if(!all(TempMat.MetallicRemap == float2(0,1))) TempMat.metallic = (TempMat.metallic * (TempMat.MetallicRemap.y - TempMat.MetallicRemap.x)) + TempMat.MetallicRemap.x;
    if(!all(TempMat.RoughnessRemap == float2(0,1))) {
        if(GetFlag(TempMat.Tag, UseSmoothness)) TempMat.roughness = (TempMat.roughness * ((1.0f - TempMat.RoughnessRemap.x) - (1.0f - TempMat.RoughnessRemap.y))) + (1.0f - TempMat.RoughnessRemap.y);
        else TempMat.roughness = (TempMat.roughness * (TempMat.RoughnessRemap.y - TempMat.RoughnessRemap.x)) + TempMat.RoughnessRemap.x;
    }

    TempMat.roughness = max(TempMat.roughness, 0.00001f);
    #ifndef TrueBlack
        TempMat.surfaceColor = max(TempMat.surfaceColor, 0.005f);
    #endif

    #ifndef WhiteLights
        if(TempMat.emission > 0) {
            if (TempMat.EmissiveTex.x > 0) {
                float3 EmissCol = lerp(TempMat.EmissionColor, TempMat.surfaceColor, GetFlag(TempMat.Tag, BaseIsMap));
                float4 EmissTex = SampleTexture(BaseUv, SampleEmission, TempMat);
                if(!GetFlag(TempMat.Tag, IsEmissionMask)) {//IS a mask
                    TempMat.emission *= luminance(EmissTex.xyz);
                } else EmissCol *= EmissTex.xyz;
                TempMat.surfaceColor = lerp(TempMat.surfaceColor, EmissCol, saturate(TempMat.emission) * GetFlag(TempMat.Tag, ReplaceBase));
            }
        }
    #endif
    const bool InvalidateScreenSpaceInfo = ((!UseASVGF && CurBounce == 0));
    float4 PrevScreenData = InvalidateScreenSpaceInfo ? 0 : ScreenSpaceInfo[id.xy];
    if(CurBounce == 0 && UseReSTIRGI) PrevScreenData.w = asfloat(0);
    float4 PrevPrev = PrevScreenData;
    #ifdef RadianceCache
        calcFinalColor(ray, Color, TempMat, bestHit, id.xy, GlobRay.last_pdf, pixel_index, MaterialIndex, BaseUv, PrevScreenData, CacheBuffer[pixel_index]);
    #else
        calcFinalColor(ray, Color, TempMat, bestHit, id.xy, GlobRay.last_pdf, pixel_index, MaterialIndex, BaseUv, PrevScreenData);
    #endif
    if(CurBounce == 0 || ((UseASVGF ^ InvalidateScreenSpaceInfo) && any(PrevPrev != PrevScreenData))) ScreenSpaceInfo[id.xy] = PrevScreenData;
    GlobalColors[pixel_index] = Color;

}





#ifdef HDRP
    Texture2DArray<float4> DiffuseGBuffer;
    Texture2DArray<float4> SpecularGBuffer;
    Texture2DArray<float4> NormalTexture;
#else
    Texture2D<float4> DiffuseGBuffer;
    Texture2D<float4> SpecularGBuffer;
    Texture2D<float4> NormalTexture;
#endif

#pragma kernel kernel_finalize
int UpscalerMethod;
[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance
    if (id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;

    float3 GBufferCol = 1;
    [branch]if(DiffRes && UpscalerMethod != 0) {
        float2 UV = id.xy / float2(screen_width, screen_height);
        #ifdef HDRP
            float3 SpecularAlbedo = 0;
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        #else
            float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        #endif
    }
    float3 res = (GetBounceData(GlobalColors[final_pixel_index].MetRoughIsSpec) == 1) ? GlobalColors[final_pixel_index].Data.xyz : ((float)PartialRenderingFactor * ((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * GlobalColors[final_pixel_index].Data.xyz) + pow(unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay),2.2f) / GBufferCol);
    // float3 res = (GlobalColors[final_pixel_index].Data.w == 0) ? GlobalColors[final_pixel_index].Data.xyz : ((float)PartialRenderingFactor * ((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * GlobalColors[final_pixel_index].Data.xyz) / GBufferCol);
    if (!all(res < 10000000)) res = 0;
    #if DebugView != -1
        #if DebugView == DVGIView
            res = (GetBounceData(GlobalColors[final_pixel_index].MetRoughIsSpec) == 1) ? GlobalColors[final_pixel_index].Data.xyz : ((float)PartialRenderingFactor * ((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) + pow(unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay),2.2f)));
        #elif defined(RadianceCache) && DebugView == DVRadCache
            res = 0;
            RetrieveCacheRadiance(CacheBuffer[final_pixel_index], _DebugTex[id.xy].xyz, i_octahedral_32(asuint(_DebugTex[id.xy].w)), res);
        #else
            res = _DebugTex[id.xy];
        #endif
    #endif
    Result[id.xy] = float4(res, 1.0f);
}


#pragma kernel TransferKernel
int Type;
[numthreads(1, 1, 1)]
void TransferKernel(uint3 id : SV_DispatchThreadID) {
    if(Type == 0) {
        BufferData[0] = uint3(ceil(BufferSizes[CurBounce].tracerays / 32.0f), 1, 1);
        if(CurBounce != 0) BufferSizes[CurBounce - 1].tracerays = BufferSizes[CurBounce].tracerays;
    } else {
        BufferData[0] = uint3(ceil(BufferSizes[CurBounce].shadow_rays / 32.0f), 1, 1);
    }

}

RWStructuredBuffer<float3> OutputBuffer;
RWStructuredBuffer<float3> AlbedoBuffer;
RWStructuredBuffer<float3> NormalBuffer;

#pragma kernel OIDNtoTTKernel
[numthreads(16, 16, 1)]
void OIDNtoTTKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    Result[id.xy] = float4(lerp(OutputBuffer[id.x + id.y * screen_width], Result[id.xy].xyz, 1.0f - OIDNBlendRatio), 1);
}


#pragma kernel TTtoOIDNKernel
[numthreads(16, 16, 1)]
void TTtoOIDNKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x > screen_width || id.y > screen_height) return;
    int pixel_index = id.x + id.y * screen_width;
    if(OIDNGuideWrite) {
        NormalBuffer[pixel_index] = i_octahedral_32(ScreenSpaceInfo[id.xy].y);
        AlbedoBuffer[pixel_index] = unpackRGBE(GlobalColors[pixel_index].Flags);
    }
    OutputBuffer[id.x + id.y * screen_width] = Result[id.xy].xyz;
}



#pragma kernel TTtoOIDNKernelPanorama
[numthreads(16, 16, 1)]
void TTtoOIDNKernelPanorama(uint3 id : SV_DispatchThreadID) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    int pixel_index = id.x + id.y * screen_width;
    if(OIDNGuideWrite) {
        NormalBuffer[pixel_index] = i_octahedral_32(ScreenSpaceInfo[id.xy].y);
        AlbedoBuffer[pixel_index] = unpackRGBE(GlobalColors[pixel_index].Flags);
    }
    OutputBuffer[id.x + id.y * screen_width] = Result[id.xy].xyz;
}
