#include "../GlobalDefines.cginc"
#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "CommonData.cginc"
#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif

RWTexture2D<uint4> _PrimaryTriangleInfo;
#pragma kernel kernel_trace 

void IntersectTriangle(int mesh_id, const int tri_id, const SmallerRay ray, inout RayHit ray_hit, const int MatOffset, const float RandNum) {
    TrianglePos tri = triangle_get_positions(tri_id);

    float3 h = cross(ray.direction, tri.posedge2);
    float  a = dot(tri.posedge1, h);

    float  f = rcp(a);
    float3 s = ray.origin - tri.pos0;
    float  u = f * dot(s, h);

    float3 q = cross(s, tri.posedge1);
    float  v = f * dot(ray.direction, q);

    [branch]if (u >= 0 && v >= 0.0f && u + v <= 1.0f) {
        float t = f * dot(tri.posedge2, q);

        [branch]if (t > 0 && t < ray_hit.t) {
            const TriangleUvs tri2 = triangle_get_positions2(tri_id);
            const int MaterialIndex = (MatOffset + AggTrisA[tri_id].MatDat);
            //major slowdown
            #ifdef AdvancedAlphaMapped
                [branch]if(_IntersectionMaterials[MaterialIndex].MatType == CutoutIndex) {
                    float2 BaseUv = tri2.pos0 * (1.0f - u - v) + tri2.posedge1 * u + tri2.posedge2 * v;
                    if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0) 
                        if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x < _IntersectionMaterials[MaterialIndex].AlphaCutoff) return;
                }
            #endif
            #ifdef IgnoreGlassMain
                if(_IntersectionMaterials[MaterialIndex].specTrans == 1) return;
            #endif
            #ifdef IgnoreBackfacing
                if(_IntersectionMaterials[MaterialIndex].specTrans != 1 && dot(normalize(cross(normalize(tri.posedge1), normalize(tri.posedge2))), ray.direction) <= 0) return;
            #endif
            #ifdef FadeMapping
                if(_IntersectionMaterials[MaterialIndex].MatType == FadeIndex) {
                    float2 BaseUv = tri2.pos0 * (1.0f - u - v) + tri2.posedge1 * u + tri2.posedge2 * v;
                    if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                        if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x - _IntersectionMaterials[MaterialIndex].AlphaCutoff <= RandNum) return;
                }
            #endif
            if(CurBounce == 0 && GetFlag(_IntersectionMaterials[MaterialIndex].Tag, Invisible)) return;
            ray_hit.t = t;
            ray_hit.u = u;
            ray_hit.v = v;
            ray_hit.mesh_id = mesh_id;
            ray_hit.triangle_id = tri_id;
        }
    }
}
#define YAmount 2
groupshared int nextRayArray[YAmount];

void IntersectBVH(int ray_index, int threadIdxy, int GTx) {
    #ifdef HardwareRT
        if(ray_index >= BufferSizes[CurBounce].tracerays) return;
    #endif
    RayHit bestHit;
    SmallerRay ray;
    #ifndef HardwareRT
        int Reps = 0;
        uint2 stack[16];
        int stack_size = 0;
        uint2 current_group;
        uint oct_inv4;
        int tlas_stack_size = -1;
        SmallerRay ray2;
        int NodeOffset = 0;
        int TriOffset = 0;
        int MatOffset = 0;
        int mesh_id = -1;
    #endif

        RayData GlobalRay;
        bestHit = CreateRayHit();
        float RandNum = random(43, GlobalRay.PixelIndex).x;

        #ifdef HardwareRT
            [branch]if(CurBounce % 2 == 1) ray_index += screen_width * screen_height;
            GlobalRay = GlobalRays[ray_index];
            if(CurBounce == 0) bestHit.t = asfloat(GlobalRay.hits.z);
            const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
            UnityRayQuery<rayFlags> q;
            RayDesc myRay;
            myRay.Origin = GlobalRays[ray_index].origin;
            myRay.Direction = GlobalRays[ray_index].direction;
            ray.origin = myRay.Origin;
            ray.direction = myRay.Direction;
            myRay.TMin = 0;
            myRay.TMax = bestHit.t;
            // bestHit.t = FarPlane;
            while(true) {
               q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
                while(q.Proceed()){}

                if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) {
                    bestHit.t = q.CommittedRayT();
                    bestHit.u = q.CommittedTriangleBarycentrics().y;
                    bestHit.v = q.CommittedTriangleBarycentrics().x;
                    bestHit.mesh_id = uint(q.CommittedInstanceID() | (q.CommittedGeometryIndex() << 25));
                    bestHit.triangle_id = q.CommittedPrimitiveIndex();
                    #if defined(AdvancedAlphaMapped) || defined(IgnoreBackfacing) || defined(FadeMapping) || defined(IgnoreGlassMain)
                        int2 Indexes = int2(bestHit.mesh_id & 0x1FFFFFF, bestHit.mesh_id >> 25);
                        int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
                        int tri_id = bestHit.triangle_id + triangleOffset;
                        int mesh_id = MeshOffsets[Indexes.x].y;
                        int MaterialIndex = (_MeshData[mesh_id].MaterialOffset + AggTrisA[tri_id].MatDat);
                    #endif
                    #ifdef AdvancedAlphaMapped
                        if(CurBounce == 0 && GetFlag(_IntersectionMaterials[MaterialIndex].Tag, Invisible)) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                        if(_IntersectionMaterials[MaterialIndex].MatType == CutoutIndex) {
                            float2 BaseUv = TOHALF(AggTrisA[tri_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTrisA[tri_id].texedge1) * bestHit.u + TOHALF(AggTrisA[tri_id].texedge2) * bestHit.v;
                            if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                                if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x < _IntersectionMaterials[MaterialIndex].AlphaCutoff) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                        }
                    #endif
                    #ifdef IgnoreGlassMain
                        if(_IntersectionMaterials[MaterialIndex].specTrans == 1) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                    #endif
                    #ifdef IgnoreBackfacing
                        TrianglePos tri = triangle_get_positions(tri_id);
                        if(_IntersectionMaterials[MaterialIndex].specTrans != 1 && dot(normalize(cross(normalize(tri.posedge1), normalize(tri.posedge2))), mul((float3x3)_MeshData[mesh_id].W2L, ray.direction)) <= 0) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                    #endif
                    #ifdef FadeMapping
                        if(_IntersectionMaterials[MaterialIndex].MatType == FadeIndex) {
                            float2 BaseUv = TOHALF(AggTrisA[tri_id].tex0) * (1.0f - bestHit.u - bestHit.v) + TOHALF(AggTrisA[tri_id].texedge1) * bestHit.u + TOHALF(AggTrisA[tri_id].texedge2) * bestHit.v;
                            if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                                if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x - _IntersectionMaterials[MaterialIndex].AlphaCutoff <= RandNum) {myRay.TMin = bestHit.t + 0.0001f; bestHit.t = FarPlane; continue;}
                        }
                    #endif
                }
                break;
            }


            int PixIndex = GlobalRay.PixelIndex;
            uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
            int2 Indexes = int2(bestHit.mesh_id & 0x1FFFFFF, bestHit.mesh_id >> 25);
            [branch]if(CurBounce == 0) {
                _PrimaryTriangleInfo[TempUv] = uint4(MeshOffsets[Indexes.x].y, bestHit.triangle_id + SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y] - _MeshData[MeshOffsets[Indexes.x].y].TriOffset, asuint(bestHit.u), asuint(bestHit.v));
            } else if(GetBounceData(GlobalColors[PixIndex].MetRoughIsSpec) == 0 || CurBounce + 1 == GetBounceData(GlobalColors[PixIndex].MetRoughIsSpec)) {
                _PrimaryTriangleInfo[TempUv] = ((UseReSTIRGI && bestHit.t != FarPlane) ? uint4(MeshOffsets[Indexes.x].y, bestHit.triangle_id + SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y] - _MeshData[MeshOffsets[Indexes.x].y].TriOffset, asuint(bestHit.u), asuint(bestHit.v)) : ((UseASVGF || bestHit.t != FarPlane) ? uint4(asuint(ray.direction), 99993) : uint4(asuint(ray.direction * bestHit.t + ray.origin), 99993)));
            }

            if(CurBounce == 0 && bestHit.t == asfloat(GlobalRay.hits.z)) bestHit.t = FarPlane;
            set(ray_index, bestHit);
        #else
            current_group.x = (uint)0;
            current_group.y = 0;//(uint)0x80000000;
            uint2 triangle_group = 0;
#ifndef DX11
            int Coun2 = 0;
            if(ray_index == 0) {
                nextRayArray[threadIdxy] = BufferSizes[CurBounce].TracedRays;
            }
            GroupMemoryBarrier();
            bool KilledNaturally = true;
#endif
            int rayidx = 0;
            const static int A = BufferSizes[CurBounce].tracerays;
#ifndef DX11
        [loop]do{
            Coun2++;
            bool                terminated = KilledNaturally;//(stack_size == 0 && current_group.y <= 0x00FFFFFF && triangle_group.y == 0);
            const uint  maskTerminated = WaveActiveBallot(terminated);
            const int           numTerminated = countbits(maskTerminated);
            const int           idxTerminated = countbits(maskTerminated & ((1u << GTx) - 1));
            KilledNaturally = false;
            if(terminated) {
            Reps = 0;
                current_group.y = 0b10000000000000000000000000000000;//(uint)0x80000000;
#else
                current_group.y = (uint)0x80000000;
#endif
                current_group.x = (uint)0;
                triangle_group = 0;
#ifndef DX11
                if(idxTerminated == 0) {
                    InterlockedAdd(BufferSizes[CurBounce].TracedRays, numTerminated, nextRayArray[threadIdxy]);
                }
                GroupMemoryBarrier();


                rayidx = nextRayArray[threadIdxy] + idxTerminated;
                if(rayidx >= A) break;
#else
                rayidx = ray_index;
                if(rayidx >= A) return;
#endif
                [branch]if(CurBounce % 2 == 1) rayidx += screen_width * screen_height;
                GlobalRay = GlobalRays[rayidx];
                RandNum = random(43, GlobalRay.PixelIndex).x;
                bestHit = CreateRayHit();
                if(CurBounce == 0) bestHit.t = asfloat(GlobalRay.hits.z);


                ray.origin = GlobalRay.origin;
                ray.direction = (GlobalRay.direction == 0 ? EPSILON : GlobalRay.direction);
                ray2 = ray;

                tlas_stack_size = -1;
                stack_size = 0;
                NodeOffset = 0;
                TriOffset = 0;
                MatOffset = 0;
                mesh_id = -1;
                oct_inv4 = ray_get_octant_inv4(ray.direction);
#ifndef DX11
            }

                int lostLoopIterations = 0;
#endif

            [loop]while (Reps < MaxTraversalSamples) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)          

                [branch]if (current_group.y > 0x00FFFFFF) {
                    uint child_index_offset = firstbithigh(current_group.y);

                    uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                    uint relative_index = countbits(current_group.y & ~(0xffffffff << slot_index));
                    uint child_node_index = current_group.x + relative_index;
                    const BVHNode8Data TempNode = cwbvh_nodes[child_node_index];

                    current_group.y &= ~(1 << child_index_offset);

                    if (current_group.y > 0x00FFFFFF) stack[stack_size++] = current_group;

                    uint hitmask = cwbvh_node_intersect(ray, oct_inv4, bestHit.t, TempNode);

                    current_group.y = (hitmask & 0xff000000) | ((TempNode.nodes[0].w >> 24) & 0xff);
                    triangle_group.y = (hitmask & 0x00ffffff);

                    current_group.x = (TempNode.nodes[1].x) + NodeOffset;
                    triangle_group.x = (TempNode.nodes[1].y) + TriOffset;

                    Reps += 4;
                } else {
                    triangle_group = current_group;
                    current_group = (uint)0;
                }

                if(triangle_group.y != 0) {
                    [branch]if(tlas_stack_size == -1) {
                        uint mesh_offset = firstbithigh(triangle_group.y);
                        triangle_group.y &= ~(1 << mesh_offset);
                        mesh_id = TLASBVH8Indices[triangle_group.x + mesh_offset];
                        NodeOffset = _MeshData[mesh_id].NodeOffset;
                        TriOffset = _MeshData[mesh_id].TriOffset;

                        if (triangle_group.y != 0) stack[stack_size++] = triangle_group;
                        if (current_group.y & 0xff000000) stack[stack_size++] = current_group;

                        tlas_stack_size = stack_size;

                        int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                        MatOffset = _MeshData[mesh_id].MaterialOffset;
                        ray.direction = (mul((float3x3)_MeshData[mesh_id].W2L, ray.direction));
                        ray.origin = (mul(_MeshData[mesh_id].W2L, float4(ray.origin, 1))).xyz;

                        oct_inv4 = ray_get_octant_inv4(ray.direction);

                        current_group.x = (uint)root_index;
                        current_group.y = (uint)0x80000000;
                    } else {
                        while (triangle_group.y != 0) {
                            uint triangle_index = firstbithigh(triangle_group.y);
                            triangle_group.y &= ~(1 << triangle_index);
                            IntersectTriangle(mesh_id, triangle_group.x + triangle_index, ray, bestHit, MatOffset, RandNum);//Intersect Mesh Triangles
                        }
                    }
                }
              
                if ((current_group.y & 0xff000000) == 0) {
                    if (stack_size == 0) {//thread has finished traversing
                        int PixIndex = GlobalRay.PixelIndex;
                        uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
                        [branch]if(CurBounce == 0) {
                            _PrimaryTriangleInfo[TempUv] = uint4(bestHit.mesh_id, bestHit.triangle_id - _MeshData[bestHit.mesh_id].TriOffset, asuint(bestHit.u), asuint(bestHit.v));
                            #if DebugView == DVBVHView
                                _DebugTex[TempUv] = float4(Reps / 43.0f, Reps > 80, 0, 1);
                            #endif
                        } else if(GetBounceData(GlobalColors[PixIndex].MetRoughIsSpec) == 0 || CurBounce + 1 == GetBounceData(GlobalColors[PixIndex].MetRoughIsSpec)) {
                            _PrimaryTriangleInfo[TempUv] = ((UseReSTIRGI && bestHit.t != FarPlane) ? uint4(bestHit.mesh_id, bestHit.triangle_id - _MeshData[bestHit.mesh_id].TriOffset, asuint(bestHit.u), asuint(bestHit.v)) : ((UseASVGF || bestHit.t != FarPlane) ? uint4(asuint(ray2.direction), 99993) : uint4(asuint(ray2.direction * bestHit.t + ray2.origin), 99993)));
                        }
                        if(CurBounce == 0 && bestHit.t == asfloat(GlobalRay.hits.z)) bestHit.t = FarPlane;
                        set(rayidx, bestHit);
#ifndef DX11
                        KilledNaturally = true;
#endif
                        break;
                    }

                    if (stack_size == tlas_stack_size) {
                        NodeOffset = 0;
                        TriOffset = 0;
                        tlas_stack_size = -1;
                        ray = ray2;
                        oct_inv4 = ray_get_octant_inv4(ray.direction);
                    }
                    current_group = stack[--stack_size];
                }
#ifndef DX11
                    const static int Nd = 4;
                    const static int Nw = 16;
                    lostLoopIterations += countbits(~WaveActiveBallot(true)) - Nd;
                    if(lostLoopIterations >= Nw) break;
#endif
            }
#ifndef DX11
    } while(true);
#endif
    #endif
}


#ifdef DX11
[numthreads(64, 1, 1)]
#else
#ifdef HardwareRT
[numthreads(32, 1, 1)]
#else
[numthreads(32, YAmount, 1)]
#endif
#endif
void kernel_trace(uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function
    IntersectBVH(id.x, GT.y, GT.x);
}

#pragma kernel kernel_shadow

void IntersectBVHShadow(int ray_index, int threadIdxy, int GTx) {
    #ifdef HardwareRT
        if(ray_index >= BufferSizes[CurBounce].shadow_rays) return;
    #endif
    SmallerRay ray;

    #ifndef HardwareRT
        uint2 stack[16];
        int stack_size = 0;
        uint2 current_group;
        int NodeOffset;
        int TriOffset;
        int MatOffset;
        uint oct_inv4;
        int tlas_stack_size;
        SmallerRay ray2;
        int Reps = 0;
        bool Hit = false;
    #endif

        int mesh_id = -1;

        ShadowRayData ShadowRay;
        float3 throughput = 1;

        #ifdef HardwareRT
            const uint rayFlags = RAY_FLAG_CULL_NON_OPAQUE;
            UnityRayQuery<rayFlags> q;
            RayDesc myRay;
            ShadowRay = ShadowRaysBuffer[ray_index];
            myRay.Origin = ShadowRaysBuffer[ray_index].origin;
            float ShadowRayT = length(ShadowRaysBuffer[ray_index].EndPoint - myRay.Origin);
            myRay.Direction = normalize(ShadowRaysBuffer[ray_index].EndPoint - myRay.Origin);
            ray.origin = myRay.Origin;
            ray.direction = myRay.Direction;
            myRay.TMin = 0;
            myRay.TMax = ShadowRayT;
            while(true) {
                q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
                while(q.Proceed()){}

                if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) {

                    float u = q.CommittedTriangleBarycentrics().y;
                    float v = q.CommittedTriangleBarycentrics().x;
                    int2 Indexes = int2(q.CommittedInstanceID(), q.CommittedGeometryIndex());
                    int triangle_id = q.CommittedPrimitiveIndex();
                    #if defined(IgnoreBackfacing) || defined(AdvancedAlphaMapped) || defined(IgnoreGlassShadow) || defined(AdvancedBackground)
                        int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.x].x + Indexes.y];
                        triangle_id += triangleOffset;
                        mesh_id = MeshOffsets[Indexes.x].y;
                        int MaterialIndex = (_MeshData[mesh_id].MaterialOffset + AggTrisA[triangle_id].MatDat);
                        if(GetFlag(_IntersectionMaterials[MaterialIndex].Tag, IsBackground) || GetFlag(_IntersectionMaterials[MaterialIndex].Tag, ShadowCaster))  {myRay.TMin = q.CommittedRayT() + 0.0001f; continue;} 
                    #endif
                    #ifdef AdvancedAlphaMapped
                        if(_IntersectionMaterials[MaterialIndex].MatType == CutoutIndex) {
                            float2 BaseUv = TOHALF(AggTrisA[triangle_id].tex0) * (1.0f - u - v) + TOHALF(AggTrisA[triangle_id].texedge1) * u + TOHALF(AggTrisA[triangle_id].texedge2) * v;
                            if(_IntersectionMaterials[MaterialIndex].AlphaTex.x > 0)
                                if(SampleTexture(BaseUv, SampleAlpha, _IntersectionMaterials[MaterialIndex]).x < _IntersectionMaterials[MaterialIndex].AlphaCutoff) {myRay.TMin = q.CommittedRayT() + 0.0001f; continue;}
                        }
                    #endif
                    #ifdef IgnoreBackfacing
                        TrianglePos tri = triangle_get_positions(triangle_id);
                        if(_IntersectionMaterials[MaterialIndex].specTrans != 1 && dot(normalize(cross(normalize(tri.posedge1), normalize(tri.posedge2))), mul((float3x3)_MeshData[mesh_id].W2L, ray.direction)) <= 0) {myRay.TMin = q.CommittedRayT() + 0.0001f; continue;}
                    #endif
                    #ifdef IgnoreGlassShadow
                        if(_IntersectionMaterials[MaterialIndex].specTrans == 1) {
                            #ifdef StainedGlassShadows
                                float2 BaseUv = TOHALF(AggTrisA[triangle_id].tex0) * (1.0f - u - v) + TOHALF(AggTrisA[triangle_id].texedge1) * u + TOHALF(AggTrisA[triangle_id].texedge2) * v;
                                float3 MatCol = _IntersectionMaterials[MaterialIndex].surfaceColor;
                                if(_IntersectionMaterials[MaterialIndex].AlbedoTex.x > 0) MatCol *= SampleTexture(BaseUv, SampleAlbedo, _IntersectionMaterials[MaterialIndex]) / 3.0f;
                                // MatCol = lerp(MatCol, _IntersectionMaterials[MaterialIndex].BlendColor, _IntersectionMaterials[MaterialIndex].BlendFactor);
                                throughput *= sqrt(exp(-CalculateExtinction2(1.0f - MatCol, _IntersectionMaterials[MaterialIndex].scatterDistance == 0.0f ? 1.0f : _IntersectionMaterials[MaterialIndex].scatterDistance)));
                            #endif
                            myRay.TMin = q.CommittedRayT() + 0.0001f; 
                            continue;
                        }
                    #endif

                    ShadowRaysBuffer[ray_index].FIELD = -2;//WHY
                } else {
                    if(!TerrainExists) {
                        uint PixelIndex = ShadowRay.PixelIndex & 0xFFFFFFF;
                        bool IsNotPrimaryNEERay = (ShadowRay.PixelIndex >> 30);
                        if(CurBounce == 0) NEEPosA[uint2(PixelIndex % screen_width, PixelIndex / screen_width)] = float4(ray.origin + ray.direction * ShadowRayT,asfloat(ShadowRay.FIELD));
                        #ifdef RadCache
                            CacheBuffer[PixelIndex].RunningIlluminance = packRGBE(unpackRGBE(ShadowRay.DiffuseIlluminance) * throughput + unpackRGBE(CacheBuffer[PixelIndex].RunningIlluminance));
                            AddHitToCachePartial(CacheBuffer[PixelIndex], ray.origin);
                        #endif
                        if (IsNotPrimaryNEERay) {

                            if (CurBounce == 0) {
                                #ifdef RadCache
                                    GlobalColors[PixelIndex].PrimaryNEERay = packRGBE(pow(unpackRGBE(GlobalColors[PixelIndex].PrimaryNEERay),2.2f) + pow(ShadowRay.illumination,rcp(2.2f)) * throughput);
                                #else
                                    GlobalColors[PixelIndex].Direct += ShadowRay.illumination * throughput;
                                #endif
                            } else {
                                #ifdef RadCache
                                    if(GetBounceData(CacheBuffer[PixelIndex].pathLength) == 0) GlobalColors[PixelIndex].Indirect += ShadowRay.illumination * throughput;
                                #else
                                    GlobalColors[PixelIndex].Indirect += ShadowRay.illumination * throughput;
                                #endif
                            }
                        } else {
                            if(CurBounce != 0 && ((!UseReSTIRGI && GetBounceData(GlobalColors[PixelIndex].MetRoughIsSpec) == 0) || !UseASVGF)) GlobalColors[PixelIndex].Indirect += ShadowRay.illumination * throughput;// * unpackRGBE(asuint(ShadowRay.DiffuseIlluminance));
                            else GlobalColors[PixelIndex].PrimaryNEERay = packRGBE(pow(unpackRGBE(GlobalColors[PixelIndex].PrimaryNEERay),2.2f) + pow(ShadowRay.illumination,rcp(2.2f)) * throughput);
                        }
                    } else {
                        ShadowRaysBuffer[ray_index].illumination *= throughput;
                        ShadowRaysBuffer[ray_index].DiffuseIlluminance = packRGBE(unpackRGBE(ShadowRaysBuffer[ray_index].DiffuseIlluminance) * throughput);
                    }
                }
                break;
            }
        #else


            current_group.x = (uint)0;
            current_group.y = 0;//(uint)0x80000000;
            uint2 triangle_group = 0;
#ifndef DX11
            int Coun2 = 0;
            if(ray_index == 0) {
                nextRayArray[threadIdxy] = BufferSizes[CurBounce].TracedRaysShadow;
            }
            GroupMemoryBarrier();
            bool KilledNaturally = true;
#endif
            int rayidx = 0;
            const static int A = BufferSizes[CurBounce].shadow_rays;
            float max_distance;
#ifndef DX11
        [loop]do{
            Coun2++;
            Reps = 0;
            bool                terminated = KilledNaturally;//(stack_size == 0 && current_group.y <= 0x00FFFFFF && triangle_group.y == 0);
            const uint  maskTerminated = WaveActiveBallot(terminated);
            const int           numTerminated = countbits(maskTerminated);
            const int           idxTerminated = countbits(maskTerminated & ((1u << GTx) - 1));
            KilledNaturally = false;
            if(terminated) {
                current_group.y = 0b10000000000000000000000000000000;//(uint)0x80000000;
#else
                current_group.y = (uint)0x80000000;
#endif
                current_group.x = (uint)0;
                triangle_group = 0;
#ifndef DX11
                if(idxTerminated == 0) {
                    InterlockedAdd(BufferSizes[CurBounce].TracedRaysShadow, numTerminated, nextRayArray[threadIdxy]);
                }
                GroupMemoryBarrier();
                rayidx = nextRayArray[threadIdxy] + idxTerminated;
                if(rayidx >= A) break;
#else
                rayidx = ray_index;
                if(rayidx >= A) return;
#endif
                ShadowRay = ShadowRaysBuffer[rayidx];

                max_distance = length(ShadowRaysBuffer[rayidx].EndPoint - ShadowRay.origin);
                ray.origin = ShadowRay.origin;
                ray.direction = normalize(ShadowRaysBuffer[rayidx].EndPoint - ShadowRay.origin);
                ray.direction = (ray.direction == 0 ? EPSILON : ray.direction);
                ray2 = ray;
                TriOffset = 0;
                MatOffset = 0;
                Reps = 0;
                NodeOffset = 0;
                throughput = 1;
                Hit = false;
                stack_size = 0;
                mesh_id = -1;

                oct_inv4 = ray_get_octant_inv4(ray.direction);

                current_group.x = (uint)0;
                current_group.y = (uint)0x80000000;
                tlas_stack_size = -1;
#ifndef DX11
            }
                int lostLoopIterations = 0;
#endif
                [loop] while (Reps < MaxTraversalSamples) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)            
                    [branch]if (current_group.y & 0xff000000) {
                       uint child_index_offset = firstbithigh(current_group.y);

                        uint slot_index = (child_index_offset - 24) ^ (oct_inv4 & 0xff);
                        uint relative_index = countbits(current_group.y & ~(0xffffffff << slot_index));
                        uint child_node_index = current_group.x + relative_index;
                        const BVHNode8Data TempNode = cwbvh_nodes[child_node_index];

                        current_group.y &= ~(1 << child_index_offset);

                        if (current_group.y & 0xff000000) stack[stack_size++] = current_group;


                        uint hitmask = cwbvh_node_intersect(ray, oct_inv4, max_distance, TempNode);

                        current_group.y = (hitmask & 0xff000000) | ((TempNode.nodes[0].w >> 24) & 0xff);
                        triangle_group.y = (hitmask & 0x00ffffff);

                        current_group.x = (TempNode.nodes[1].x) + NodeOffset;
                        triangle_group.x = (TempNode.nodes[1].y) + TriOffset;

                        Reps++;
                    } else {
                        triangle_group = current_group;
                        current_group = (uint)0;
                    }


                    if(triangle_group.y != 0) {
                        [branch]if (tlas_stack_size == -1) {//Transfer from Top Level Accelleration Structure to Bottom Level Accelleration Structure
                            uint mesh_offset = firstbithigh(triangle_group.y);
                            triangle_group.y &= ~(1 << mesh_offset);

                            mesh_id = TLASBVH8Indices[triangle_group.x + mesh_offset];
                            NodeOffset = _MeshData[mesh_id].NodeOffset;
                            TriOffset = _MeshData[mesh_id].TriOffset;

                            if (triangle_group.y != 0) stack[stack_size++] = triangle_group;

                            if (current_group.y & 0xff000000) stack[stack_size++] = current_group;

                            tlas_stack_size = stack_size;

                            int root_index = (_MeshData[mesh_id].mesh_data_bvh_offsets & 0x7fffffff);

                            MatOffset = _MeshData[mesh_id].MaterialOffset;
                            ray.direction = (mul((float3x3)_MeshData[mesh_id].W2L, ray.direction)).xyz;
                            ray.origin = (mul(_MeshData[mesh_id].W2L, float4(ray.origin, 1))).xyz;

                            oct_inv4 = ray_get_octant_inv4(ray.direction);

                            current_group.x = (uint)root_index;
                            current_group.y = (uint)0x80000000;
                        } else {
                            while (triangle_group.y != 0) {    
                                uint triangle_index = firstbithigh(triangle_group.y);
                                triangle_group.y &= ~(1 << triangle_index);

                                if (triangle_intersect_shadow(triangle_group.x + triangle_index, ray, max_distance, throughput, MatOffset)) {
                                    ShadowRaysBuffer[rayidx].FIELD = -2;//WHY
#ifndef DX11
                                    KilledNaturally = true;
                                    break;
#else
                                    return;
#endif
                                }
                            }
                        }
                    }
#ifndef DX11
                    if(KilledNaturally) break;
#endif


                    if ((current_group.y & 0xff000000) == 0) {
                        if (stack_size == 0) {//thread has finished traversing
                            if(!TerrainExists) {
                                uint PixelIndex = ShadowRay.PixelIndex & 0xFFFFFFF;
                                bool IsNotPrimaryNEERay = (ShadowRay.PixelIndex >> 30);
                                if(CurBounce == 0) NEEPosA[uint2(PixelIndex % screen_width, PixelIndex / screen_width)] = float4(ray2.origin + ray2.direction * max_distance, asfloat(ShadowRay.FIELD));
                                #ifdef RadCache
                                    CacheBuffer[PixelIndex].RunningIlluminance = packRGBE(unpackRGBE(ShadowRay.DiffuseIlluminance) * throughput + unpackRGBE(CacheBuffer[PixelIndex].RunningIlluminance));
                                    AddHitToCachePartial(CacheBuffer[PixelIndex], ray2.origin);
                                #endif
                                if (IsNotPrimaryNEERay) {
                                    if (CurBounce == 0) {
                                        #ifdef RadCache
                                            GlobalColors[PixelIndex].PrimaryNEERay = packRGBE(pow(unpackRGBE(GlobalColors[PixelIndex].PrimaryNEERay),2.2f) + pow(ShadowRay.illumination,rcp(2.2f)) * throughput);
                                        #else
                                            GlobalColors[PixelIndex].Direct += ShadowRay.illumination * throughput;
                                        #endif
                                    } else {
                                        #ifdef RadCache
                                            if(GetBounceData(CacheBuffer[PixelIndex].pathLength) == 0) GlobalColors[PixelIndex].Indirect += ShadowRay.illumination * throughput;
                                        #else
                                            GlobalColors[PixelIndex].Indirect += ShadowRay.illumination * throughput;
                                        #endif
                                    }
                                } else {
                                    if(CurBounce != 0 && ((!UseReSTIRGI && GetBounceData(GlobalColors[PixelIndex].MetRoughIsSpec) == 0) || !UseASVGF)) GlobalColors[PixelIndex].Indirect += ShadowRay.illumination * throughput;// * unpackRGBE(asuint(ShadowRay.DiffuseIlluminance));
                                    else GlobalColors[PixelIndex].PrimaryNEERay = packRGBE(pow(unpackRGBE(GlobalColors[PixelIndex].PrimaryNEERay),2.2f) + pow(ShadowRay.illumination,rcp(2.2f)) * throughput);
                                }
                            } else {
                                ShadowRaysBuffer[rayidx].illumination *= throughput;
                                ShadowRaysBuffer[rayidx].DiffuseIlluminance = packRGBE(unpackRGBE(ShadowRaysBuffer[rayidx].DiffuseIlluminance) * throughput);
                            }
#ifndef DX11
                            KilledNaturally = true;
                            break;
#else
                            return;
#endif
                        }

                        if (stack_size == tlas_stack_size) {
                            NodeOffset = 0;
                            TriOffset = 0;
                            tlas_stack_size = -1;
                            ray = ray2;
                            oct_inv4 = ray_get_octant_inv4(ray.direction);
                        }
                        current_group = stack[--stack_size];
                    }
#ifndef DX11
                    const int Nd = 4;
                    const int Nw = 16;
                    lostLoopIterations += countbits(~WaveActiveBallot(true)) - Nd;
                    if(lostLoopIterations >= Nw) break;
#endif
                }
#ifndef DX11
        } while(Coun2 < 1000);
#endif
        #endif
}


#ifdef DX11
[numthreads(64, 1, 1)]
#else
#ifdef HardwareRT
[numthreads(32, 1, 1)]
#else
[numthreads(32, YAmount, 1)]
#endif
#endif
void kernel_shadow(uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function
    IntersectBVHShadow(id.x, GT.y, GT.x);
}



#pragma kernel kernel_shadow_heightmap


static float g = sin(atan(1.0f / 2.0f));

inline bool rayBoxIntersection(const float3 ray_orig, const float3 ray_dir, const float3 Min, const float3 Max, float tMax, inout float t0) {
    const float3 tmp_min = (Min - ray_orig) / ray_dir;
    const float3 tmp_max = (Max - ray_orig) / ray_dir;
    const float3 tmin = min(tmp_min, tmp_max);
    const float3 tmax = max(tmp_min, tmp_max);
    t0 = max(tmin.x, max(tmin.y, max(tmin.z, 0.025f))); // Usually ray_tmin = 0
    float t1 = min(tmax.x, min(tmax.y, min(tmax.z, tMax)));
    return (t0 <= t1);
}

bool GetDist(float3 CurrentPos, out float2 uv, out float dist, const TerrainData Terrain) {
    float3 b = float3(Terrain.TerrainDim.x, 0.01f, Terrain.TerrainDim.y);
    float3 q = (abs(CurrentPos) - b);
    q.x /= Terrain.TerrainDim.x;
    q.z /= Terrain.TerrainDim.y;
    uv = float2(min(CurrentPos.x / Terrain.TerrainDim.x, 1), min(CurrentPos.z / Terrain.TerrainDim.y, 1));
    float h = Heightmap.SampleLevel(sampler_trilinear_clamp, uv * (Terrain.HeightMap.xy - Terrain.HeightMap.zw) + Terrain.HeightMap.zw, 0).x;
    h *= Terrain.HeightScale * 2.0f;
    q.y -= h;
    q.y *= g;
    float b2 = q.y;
    q = max(0, q);
    dist = length(q);
    return b2 != abs(b2);
}


bool IntersectHeightMapShadow(SmallerRay ray, float MaxDist) {
    float3 Origin = ray.origin;
    for (int i = 0; i < TerrainCount; i++) {
        const TerrainData Terrain = Terrains[i];
        float t0;
        if (rayBoxIntersection(Origin, ray.direction, Terrain.PositionOffset, Terrain.PositionOffset + float3(Terrain.TerrainDim.x, Terrain.TerrainDim.x, Terrain.TerrainDim.y), MaxDist, t0)) {
            ray.origin = Origin + ray.direction * (t0 + 0.001f) - Terrain.PositionOffset;
            float3 CurrentPos = ray.origin;
            int step_count = 0;
            float Dist = 0;
            bool RefinementPhase = false;
            while (step_count < 2000 && Dist < MaxDist) {
                CurrentPos = ray.origin + ray.direction * Dist;
                float3 b = float3(Terrain.TerrainDim.x, 0.01f, Terrain.TerrainDim.y);
                float3 q = (abs(CurrentPos) - b);
                q.x /= Terrain.TerrainDim.x;
                q.z /= Terrain.TerrainDim.y;
                float2 uv = float2(min(CurrentPos.x / Terrain.TerrainDim.x, 1), min(CurrentPos.z / Terrain.TerrainDim.y, 1)) * (Terrain.HeightMap.xy - Terrain.HeightMap.zw) + Terrain.HeightMap.zw;
                step_count++;
                float h = Heightmap.SampleLevel(sampler_trilinear_clamp, uv, 0).x;
                h *= Terrain.HeightScale * 2.0f;
                q.y -= h;
                q.y *= g;

                q = max(0, q);
                float dist = length(q);
                if (dist < 0.0001f) {
                    return true;
                }
                if(!RefinementPhase) dist += (float)step_count / 200.0f;
                Dist += dist / 2.0f;
                if(Dist >= MaxDist || !(all(ray.origin + ray.direction * Dist < float3(Terrain.TerrainDim.x, 1000.0f, Terrain.TerrainDim.y)) && all(ray.origin + ray.direction * Dist > 0))) {
                    if(RefinementPhase) break;
                    float dist2;
                    bool throwa = GetDist(ray.origin + ray.direction * Dist, uv, dist2, Terrain);
                    dist -= (float)step_count / 200.0f;
                    Dist -= (float)step_count / 200.0f;
                    RefinementPhase = true;
                }

            }
        }
    }
    return false;

}

void IntersectShadowHeightmap(int ray_index) {
    if(ray_index >= BufferSizes[CurBounce].shadow_rays) return;
    int pixel_index = ShadowRaysBuffer[ray_index].PixelIndex;
    SmallerRay ray = CreateRay(ShadowRaysBuffer[ray_index].origin, normalize(ShadowRaysBuffer[ray_index].EndPoint - ShadowRaysBuffer[ray_index].origin));
    ray.direction = (ray.direction == 0 ? EPSILON : ray.direction);
    bool HitHeightmap = TerrainExists;
    if(ShadowRaysBuffer[ray_index].FIELD != -2) {
        if (TerrainExists) HitHeightmap = IntersectHeightMapShadow(ray, length(ShadowRaysBuffer[ray_index].EndPoint - ShadowRaysBuffer[ray_index].origin));                  
        if(!HitHeightmap) {
            uint PixelIndex = ShadowRaysBuffer[ray_index].PixelIndex & 0xFFFFFFF;
            bool IsNotPrimaryNEERay = (ShadowRaysBuffer[ray_index].PixelIndex >> 30);
            if(CurBounce == 0) NEEPosA[uint2(PixelIndex % screen_width, PixelIndex / screen_width)] = float4(ShadowRaysBuffer[ray_index].EndPoint, 0);
            #ifdef RadCache
                CacheBuffer[PixelIndex].RunningIlluminance = packRGBE(unpackRGBE(ShadowRaysBuffer[ray_index].DiffuseIlluminance) + unpackRGBE(CacheBuffer[PixelIndex].RunningIlluminance));
                AddHitToCachePartial(CacheBuffer[PixelIndex], ShadowRaysBuffer[ray_index].origin);
            #endif
            if (IsNotPrimaryNEERay) {
                if (CurBounce == 0) {
                    #ifdef RadCache
                        GlobalColors[PixelIndex].PrimaryNEERay = packRGBE(pow(unpackRGBE(GlobalColors[PixelIndex].PrimaryNEERay),2.2f) + pow(ShadowRaysBuffer[ray_index].illumination,rcp(2.2f)));
                    #else
                        GlobalColors[PixelIndex].Direct += ShadowRaysBuffer[ray_index].illumination;
                    #endif
                } else {
                    #ifdef RadCache
                        if(GetBounceData(CacheBuffer[PixelIndex].pathLength) == 0) GlobalColors[PixelIndex].Indirect += ShadowRaysBuffer[ray_index].illumination;
                    #else
                        GlobalColors[PixelIndex].Indirect += ShadowRaysBuffer[ray_index].illumination;
                    #endif
                }
            } else {
                if(CurBounce != 0 && ((!UseReSTIRGI && GetBounceData(GlobalColors[PixelIndex].MetRoughIsSpec) == 0) || !UseASVGF)) GlobalColors[PixelIndex].Indirect += ShadowRaysBuffer[ray_index].illumination;// * unpackRGBE(asuint(ShadowRay.DiffuseIlluminance));
                else GlobalColors[PixelIndex].PrimaryNEERay = packRGBE(pow(unpackRGBE(GlobalColors[PixelIndex].PrimaryNEERay),2.2f) + pow(ShadowRaysBuffer[ray_index].illumination,rcp(2.2f)));
            }
        }
    }
}


#ifdef DX11
[numthreads(64, 1, 1)]
#else
[numthreads(32, 1, 1)]
#endif
void kernel_shadow_heightmap(uint3 id : SV_DispatchThreadID) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function
    IntersectShadowHeightmap(id.x);
}
#pragma kernel kernel_heightmap


float4 computeRayPatchIntersectionLinear(float3 r0, float3 rD, float4 _value, float4 Pd, float nextIntersection, float2 sizeBig, TerrainData Terrain, int2 id, inout int iterationCounter)
{
    // here we store the result
    float4 result = 0;

    // linear search steps
    const int LINEAR_STEPS = 5;
    float ds = nextIntersection / (float)LINEAR_STEPS;

            // _DebugTex[id.xy] = nextIntersection * 1200.0f;//abs(r0.y);// / 120.0f;
    // perform linear search of the intersection point
    for (int i=0; i < LINEAR_STEPS; i++)
    {
        // move ray 
        r0 = r0 + ds * rD;

        // get height on the current position
        //float4 Texel = texture2DLod(heightmapTex, r0.xz, 0).xyzw * maxHeight;
        //float Zmin = max(max(Texel.x, Texel.y), max(Texel.z, Texel.w));
        float Zmin = Heightmap.SampleLevel(my_linear_clamp_sampler, r0.xz, 0.0) / 1024.0f* Terrain.HeightScale * 2.0f;// * Terrain.HeightScale / Terrain.HeightScale * 2.0f;// * 2.0f;
        //float Zmin = max(max(Texel.x, Texel.y), max(Texel.z, Texel.w));

        // check if we found intersection point 
        if (Zmin >= r0.y)
        {
            result.w = 1;
            result.xyz = r0;
            break;
        }         
        // iterationCounter ++;
    }

    // size of the search window
    float size = ds;
    float step = 1.0;

    // now do a binary search to find the correct intersection point
    for (int i=0; i < 3; i++)
    {
        size *= 0.5;

        // get current texel value 
        //float4 Texel = texture2DLod(heightmapTex, r0.xz, 0).xyzw * maxHeight;
        //float Zmin = max(max(Texel.x, Texel.y), max(Texel.z, Texel.w));
        float Zmin = Heightmap.SampleLevel(my_linear_clamp_sampler, r0.xz, 0.0) / 1024.0f* Terrain.HeightScale * 2.0f;// * Terrain.HeightScale/ Terrain.HeightScale * 2.0f;// * 2.0f;

        // check if we allowed to move to the boundary
        if (r0.y < Zmin){
            step = -1.0;
        }else{
            step = 1.0;
        }

        // move the ray on the current depth
        r0 = r0 + step * size * rD;

        // iterationCounter ++;
    }
    result.xyz = r0;
    return result;
}

float4 propagateRay(float3 _r0, float3 rS, float3 rD, float3 eyePosLocal, float3 _min, float3 _max, TerrainData Terrain, int2 id, float MaxT)
{
    // we start from this level 
    int stepCounter = 0;
    float4 r0 = float4(_r0, 0);

    // compute starting level
    float2 texSizeBig = 1024;//Terrain.TerrainDim.xy;//textureSize2D(heightmapTex, 0);
    int level = log2(texSizeBig.x);

    // texture and inverse texture size
    float2 texSize = float2(1,1);
    // rS.y /= texSizeBig;
    // here we store ray coordinates in texture size domain
    // r0.xz /= texSizeBig;
    float2 rC = r0.xz * texSize;
    float srDy = sign(rD.y);
    int iterationCounter = 0;
    // repeat
    float lodBaseDistance = 10.0f;
    int lodLevel = 0;
    float TotDist = 0;
    const float ValModifier = 1.0f / 1024.0f * Terrain.HeightScale * 2.0f;
    while(stepCounter++ < 2222 && (TotDist * 1024.0f) < MaxT)
    {
        // check if pos is on horizontal and/or vertical plane
        //float2 hv = frac(rC) < 0.000001;
        float2 hv = floor(1 - frac(rC));
    
        // compue sampling coordinates based on this information
        int2 st = (floor(rC)  + floor(min(rD.xz, float2(0,0))) * hv);
        // _DebugTex[id.xy] = float4((((float2)st) / float2(texSize)) / 23.0f, 0, 1);
        // sample the sampler and return the value 
        float Texel = Heightmap.SampleLevel(my_linear_clamp_sampler, ((float2)st) / float2(texSize), max(level, 0)) * ValModifier;// * 2.0f;// * 2.0f;
        // _DebugTex[id.xy] = TotDist * 1024.0f / 12.0f;
        // set size of the heightmap below the ray
        float Zmin = Texel.x;//max(max(Texel.x, Texel.y), max(Texel.z, Texel.w));

        // compute distancies of mipmap boundaries
        float4 Pd;
        Pd.xy = float2(st + 0) / float2(texSize.xy);
        Pd.zw = float2(st + 1) / float2(texSize.xy);

        // we store here the nearest intersection
        float intersection;
        float nextIntersection;

        // decide on the direction of the ray which intersection to compute
        if (rD.x < 0)
        {
            if (rD.z < 0)
            {
                // there are two possible intersection (left and top)
                float2 t = (Pd.xy - r0.xz) / rD.xz;
                intersection = t.x;
                intersection = min(intersection, t.y);
            }else
            {
                // there are two possible intersection (left and bottom)
                float2 t = (Pd.xw - r0.xz) / rD.xz;
                intersection = t.x;
                intersection = min(intersection, t.y);
            }
        }else
        {
            if (rD.z < 0)
            {
                // there are two possible intersection (right and top)
                float2 t = (Pd.zy - r0.xz) / rD.xz;
                intersection = t.x;
                intersection = min(intersection, t.y);
            }else
            {
                // there are two possible intersection (right and bottom)
                float2 t = (Pd.zw - r0.xz) / rD.xz;
                intersection = t.x;
                intersection = min(intersection, t.y);
            }
        }

        // compute intersection with the Z-plane
        nextIntersection = intersection;
        intersection = min(srDy * (r0.y - Zmin) / rD.y, intersection);

        
        // based on the distance of the ray to the eye, we compute the lod level 
        // if (dot(r0.xyz - eyePosLocal, r0.xyz - eyePosLocal) > pow(lodBaseDistance, 2))
        // if (distance(r0.xyz, eyePosLocal) > lodBaseDistance)
        // {
        //     // lodLevel ++;
        //     // lodBaseDistance *= 2.0; 
        // }

        // stop iteration only if ray falls below of the z map
        if (level == lodLevel && r0.y <= Zmin )
        {
            // do only compute the intersection, if lod level is 0
            // if (lodLevel >= 0){r0.w = 1; break; }
            // else 
            // {
            
                // now compute the interpolated bilinar patch corners
        // return r0;
                float4 pos = computeRayPatchIntersectionLinear(r0, rD, Texel, Pd, nextIntersection, texSizeBig, Terrain, id, iterationCounter);
                // if intersection was successfull, then move the ray there and stop 
                if (pos.w > 0)
                {
                    r0 = pos;
                    break;
                }else{
                    // move the ray on the next best position and continue the propagation
                    intersection = nextIntersection;
                }
            // }
        }

        // we only move the ray if it intersects with the mipmaps boundaries or in level 0
        if ((r0.y > Zmin ) || level == lodLevel)
        {           
            // move ray to the nearest intersection point
            r0.xyz = r0.xyz + intersection * rD;
            TotDist += intersection;

            // compute new coordinates
            float2 _r = r0.xz * float2(texSize);
        
            // check if divided by two we get a rest
            _r = _r * 0.5;
            _r = floor(1 - frac(_r));
            float inc = max(_r.x, _r.y);
            level += inc;

        }else{

            // go deeper in the mipmap
            level = max(level - 1, lodLevel);            
        }

        // else decrement level
        level = max(level, lodLevel);

        // get current texture size
        texSize = (1024 >> (level));//textureSize2D(heightmapTex, max(level, 0));
        rC = r0.xz * texSize;
        // iteration counter
        // iterationCounter ++;
        // check if we are moving outside
        if (any(rC.xy >= texSize)) break;
        if (any(r0.xyz <= 0.0)) break;    
        // _DebugTex[id.xy] = stepCounter / 120.0f;
    }
    return r0;//
}


void IntersectHeightMap2(int ray_index) {
    if(ray_index >= BufferSizes[CurBounce].tracerays) return;
    if(CurBounce % 2 == 1) ray_index += screen_width * screen_height;
    SmallerRay ray;
    SmallerRay ray2;

    RayHit bestHit;

    bool DidHit = false;
    float3 CurrentPos;
    int step_count = 0;
    ray.origin = GlobalRays[ray_index].origin;
    CurrentPos = ray.origin;
    ray.direction = GlobalRays[ray_index].direction;
    ray.direction = (ray.direction == 0 ? EPSILON : ray.direction);
    ray2 = ray;
    bestHit = get(ray_index);
    float dist = FarPlane;
    float2 uv;


    for (int i = 0; i < TerrainCount; i++) {
        float t0;
        float CurDist = 0;
        const TerrainData Terrain = Terrains[i];
        if (rayBoxIntersection(ray2.origin, ray.direction, Terrain.PositionOffset + 0.001f, Terrain.PositionOffset + float3(Terrain.TerrainDim.x, Terrain.TerrainDim.x, Terrain.TerrainDim.y) - 0.001f, bestHit.t, t0)) {
            int CurLevel = 9;
            CurDist = 0;
            dist = FarPlane;
            ray.origin = ray2.origin + ray.direction * max(t0 + 0.0001f, 0) - Terrain.PositionOffset;
            CurrentPos = ray.origin;
            float PrevDist = 0;
            step_count = 0;

                    int PixIndex = GlobalRays[ray_index].PixelIndex;
                    uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);

            // while (step_count < 2000 && CurDist < bestHit.t && all(ray.origin + ray.direction * CurDist < float3(Terrain.TerrainDim.x, 1000, Terrain.TerrainDim.y)) && all(ray.origin + ray.direction * CurDist > float3(0, 0, 0))) {
                CurrentPos = ray.origin + ray.direction * CurDist;
                step_count++;
                
                // if(rayBoxIntersection(ray2.origin, ray.direction, Terrain.PositionOffset + 0.001f, Terrain.PositionOffset + float3(Terrain.TerrainDim.x, Terrain.TerrainDim.x, Terrain.TerrainDim.y) - 0.001f, bestHit.t, t0)) {
                    // Heightmap
                    // float3 temp2 = ray2.origin;
                    // temp2.xyz /= 1024.0f;
                    // temp2.y /= Terrain.HeightScale;
                float4 CurrentPos2 = propagateRay((CurrentPos) / 1024.0f, (ray2.origin) / 1024.0f, ray.direction, ray2.origin / 1024.0f, 0, 1, Terrain, TempUv, bestHit.t);
                    CurrentPos = CurrentPos2.xyz * 1024.0f;
                    // CurrentPos -= float3(512, 0, 512);
                    // CurrentPos.y *= Terrain.HeightScale;
                bool throwa = GetDist(CurrentPos, uv, dist, Terrain);
                    // if(CurrentPos2.w)_DebugTex[TempUv] = length((float3)CurrentPos - ray.origin) / 12.0f;
                if (CurrentPos2.w) {
                    // _DebugTex[TempUv] = 1;//(float)stepCounter / 120.0f;

                    // if (throwa) {
                    //     CurDist -= PrevDist /= 2;
                    //     for (int i = 0; i < 10; i++) {
                    //         if (GetDist(ray.origin + ray.direction * CurDist, uv, dist, Terrain)) {
                    //             CurDist -= PrevDist /= 2;
                    //         }
                    //         else {
                    //             for (int i2 = 0; i2 < 10; i2++) {
                    //                 if (!GetDist(ray.origin + ray.direction * CurDist, uv, dist, Terrain)) {
                    //                     CurDist += PrevDist /= 2;
                    //                 }
                    //                 else {
                    //                     CurDist -= PrevDist;
                    //                     break;
                    //                 }
                    //             }
                    //             break;
                    //         }
                    //     }
                    // }


                    bestHit.u = uv.x;
                    bestHit.v = uv.y;
                    bestHit.t = length(CurrentPos - ray2.origin);// + t0;
                    bestHit.triangle_id = i;
                    bestHit.mesh_id = 9999999;
                    [branch]if(CurBounce == 0) {
                        _PrimaryTriangleInfo[TempUv] = uint4(asuint(ray2.direction * bestHit.t + ray2.origin), 1);
                    } else if(CurBounce == 1) {
                        _PrimaryTriangleInfo[TempUv] = uint4(((!UseReSTIRGI) ? asuint(ray2.direction) : asuint(ray2.direction * bestHit.t + ray2.origin)), 1);
                    }
                    set(ray_index, bestHit);
                    break;
                }
                PrevDist = dist;
                CurDist += dist;

            // }
        }
    }

}

void IntersectHeightMap(int ray_index) {
    if(ray_index >= BufferSizes[CurBounce].tracerays) return;
    if(CurBounce % 2 == 1) ray_index += screen_width * screen_height;
    SmallerRay ray;
    SmallerRay ray2;

    RayHit bestHit;

    bool DidHit = false;
    float3 CurrentPos;
    int step_count = 0;
    ray.origin = GlobalRays[ray_index].origin;
    CurrentPos = ray.origin;
    ray.direction = GlobalRays[ray_index].direction;
    ray.direction = (ray.direction == 0 ? EPSILON : ray.direction);
    ray2 = ray;
    bestHit = get(ray_index);
    float dist = FarPlane;
    float2 uv;
    for (int i = 0; i < TerrainCount; i++) {
        float t0;
        float CurDist = 0;
        const TerrainData Terrain = Terrains[i];
        if (rayBoxIntersection(ray2.origin, ray.direction, Terrain.PositionOffset + 0.001f, Terrain.PositionOffset + float3(Terrain.TerrainDim.x, Terrain.TerrainDim.x, Terrain.TerrainDim.y) - 0.001f, bestHit.t, t0)) {
            CurDist = max(t0 + 0.0001f, 0);
            dist = FarPlane;
            ray.origin = ray2.origin + ray.direction * 0 - Terrain.PositionOffset;
            CurrentPos = ray.origin;
            float PrevDist = 0;
            step_count = 0;
                CurrentPos = ray.origin + ray.direction * CurDist;
                bool RefinementPhase = false;
            while (step_count++ < 2000 && CurDist < bestHit.t) {
                bool throwa = GetDist(CurrentPos, uv, dist, Terrain);
                if (dist < 0.0001f) {
                    if (throwa) {
                        float size = PrevDist / 2.0f;
                        float step = -1.0;
                        [unroll]for (int i=0; i < 12; i++) {
                            CurDist += step * size;
                            size *= 0.5;
                            if (GetDist(ray.origin + ray.direction * CurDist, uv, dist, Terrain)) step = -1.0;
                            else step = 1.0;
                        }
                    }

                    int PixIndex = GlobalRays[ray_index].PixelIndex;
                    uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);

                    bestHit.u = uv.x;
                    bestHit.v = uv.y;
                    bestHit.t = CurDist;
                    bestHit.triangle_id = i;
                    bestHit.mesh_id = 9999999;
                    [branch]if(CurBounce == 0) {
                        _PrimaryTriangleInfo[TempUv] = uint4(asuint(ray2.direction * bestHit.t + ray2.origin), 1);
                    } else if(CurBounce == 1) {
                        _PrimaryTriangleInfo[TempUv] = uint4(((!UseReSTIRGI) ? asuint(ray2.direction) : asuint(ray2.direction * bestHit.t + ray2.origin)), 1);
                    }
                    set(ray_index, bestHit);
                    break;
                }
                if(!RefinementPhase) dist += (float)step_count / 200.0f;
                CurDist += dist / 2.0f;
                if(CurDist >= bestHit.t || !(all(ray.origin + ray.direction * CurDist < float3(Terrain.TerrainDim.x, 1000.0f, Terrain.TerrainDim.y)) && all(ray.origin + ray.direction * CurDist > 0))) {
                    if(RefinementPhase) break;
                    float dist2;
                    throwa = GetDist(ray.origin + ray.direction * CurDist, uv, dist2, Terrain);
                    dist -= (float)step_count / 200.0f;
                    CurDist -= (float)step_count / 200.0f;
                    RefinementPhase = true;
                }
                PrevDist = dist;
                CurrentPos = ray.origin + ray.direction * CurDist;
            }
        }
    }

}


#ifdef DX11
[numthreads(64, 1, 1)]
#else
[numthreads(32, 1, 1)]
#endif
void kernel_heightmap(uint3 id : SV_DispatchThreadID) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function

    IntersectHeightMap(id.x);
}






#pragma kernel IntersectcBVHKernel


void IntersectcBVH(int ray_index, int threadIdxy, int GTx) {
    #ifdef HardwareRT
        if(ray_index >= BufferSizes[CurBounce].tracerays) return;
    #endif
    RayHit bestHit;
    SmallerRay ray;
    #ifndef HardwareRT
        int Reps = 0;
        int2 stack[32];
        int stack_size = 0;
        int2 current_group;
        SmallerRay ray2;
        int MatOffset = 0;
        int mesh_id = -1;
        float tmin;
        float tmax;
        float3 tsmaller;
        float3 tbigger;
        uint node_memory_counter = 0;
        uint triangle_memory_counter = 0;
        uint stack_memory_counter = 0;
        uint node_traverse_counter = 0;
        uint triangle_traverse_counter = 0;

    #endif
                        float3 tmin3;
                        float3 tmax3;
        RayData GlobalRay;
        bestHit = CreateRayHit();
        float RandNum = random(43, GlobalRay.PixelIndex).x;

      
            current_group.x = 122222;
            current_group.y = 0;//(uint)0x80000000;
#ifndef DX11
            int Coun2 = 0;
            if(ray_index == 0) {
                nextRayArray[threadIdxy] = BufferSizes[CurBounce].TracedRays;
            }
            GroupMemoryBarrier();
            bool KilledNaturally = true;
#endif
            int rayidx = 0;
            const static int A = BufferSizes[CurBounce].tracerays;
#ifndef DX11
        [loop]do{
            Coun2++;
            bool                terminated = KilledNaturally;//(stack_size == 0 && current_group.y <= 0x00FFFFFF && triangle_group.y == 0);
            const uint  maskTerminated = WaveActiveBallot(terminated);
            const int           numTerminated = countbits(maskTerminated);
            const int           idxTerminated = countbits(maskTerminated & ((1u << GTx) - 1));
            KilledNaturally = false;
            if(terminated) {
            Reps = 0;
#else
                current_group.y = (uint)0x80000000;
#endif
                current_group.x = (uint)0;
                current_group.y = 0;
#ifndef DX11
                if(idxTerminated == 0) {
                    InterlockedAdd(BufferSizes[CurBounce].TracedRays, numTerminated, nextRayArray[threadIdxy]);
                }
                GroupMemoryBarrier();


                rayidx = nextRayArray[threadIdxy] + idxTerminated;
                if(rayidx >= A) break;
#else
                rayidx = ray_index;
                if(rayidx >= A) return;
#endif
                [branch]if(CurBounce % 2 == 1) rayidx += screen_width * screen_height;
                GlobalRay = GlobalRays[rayidx];
                RandNum = random(43, GlobalRay.PixelIndex).x;
                bestHit = CreateRayHit();
                if(CurBounce == 0) bestHit.t = asfloat(GlobalRay.hits.z);


                ray.origin = GlobalRay.origin;
                ray.direction = (GlobalRay.direction == 0 ? EPSILON : GlobalRay.direction);
                ray2 = ray;

                stack_size = 0;
                MatOffset = 0;
                mesh_id = -1;

                node_memory_counter = 0;
                triangle_memory_counter = 0;
                stack_memory_counter = 0;
                node_traverse_counter = 0;
                triangle_traverse_counter = 0;

#ifndef DX11
            }

                int lostLoopIterations = 0;
#endif

            [loop]while (Reps < MaxTraversalSamples) {//Traverse Accelleration Structure(Compressed Wide Bounding Volume Hierarchy)          
                [branch]if (asfloat(current_group.x) < bestHit.t) {
                    const cBVHData TempNode = cBVH[current_group.y];

                    const uint imask = TempNode.D >> 24;
                    const bool2 Leafs = bool2((imask & 0x80) != 0, (imask & 0x40) != 0);
                    const float3 adjusted_ray_direction_inv = float3(
                        asfloat((TempNode.D & 0xff) << 23),
                        asfloat(((TempNode.D >> 8) & 0xff) << 23),
                        asfloat(((TempNode.D >> 16) & 0xff) << 23)
                        ) / ray.direction;
                    const float3 adjusted_ray_origin = (asfloat(TempNode.p) - ray.origin) / ray.direction;

                    uint minA = TempNode.A & 0x00FFFFFF;
                    uint maxA = TempNode.B & 0x00FFFFFF;
                    float2 LocalDistances = -1;
                    int IterCount = 0;
                    [unroll]for(int i = 0; i < 2; i++) {
                        [branch]if(Leafs[i]) {
                            IntersectTriangle(0, (i == 0) ? (minA | ((TempNode.B & 0x000000FF) << 24)) : TempNode.C, ray, bestHit, 0, RandNum);//Intersect Mesh Triangles
                            triangle_memory_counter += 52;
                            triangle_traverse_counter += 1;
                        } else {
                            tmin3 = float3(minA & 0xFF, (minA >> 8) & 0xFF, (minA >> 16) & 0xFF);
                            tmax3 = float3(maxA & 0xFF, (maxA >> 8) & 0xFF, (maxA >> 16) & 0xFF);

                            tmin3 = mad(tmin3, adjusted_ray_direction_inv, adjusted_ray_origin);
                            tmax3 = mad(tmax3, adjusted_ray_direction_inv, adjusted_ray_origin);

                            tsmaller = min(tmin3, tmax3);
                            tbigger = max(tmin3, tmax3);
                                        
                            tmin = max(tsmaller[0], max(tsmaller[1], tsmaller[2]));
                            tmax = min(tbigger[0], min(tbigger[1], tbigger[2]));
                            
                            bool intersected = tmin < bestHit.t && tmax >= max(tmin, 0);
                            [branch]
                            if (intersected) {
                                IterCount++;
                                LocalDistances[i] = min(max(tmin, 0), tmax);
                            }
                        }
                        minA = TempNode.C & 0x00FFFFFF;
                        maxA = ((TempNode.A) >> 24) | (((TempNode.B) >> 24) << 8) | (((TempNode.C) >> 24) << 16);
                    }

                    [branch]if(IterCount == 2) {
                        const bool swap = LocalDistances.x <= LocalDistances.y;
                        stack[stack_size++] = int2(asint(LocalDistances[swap]), TempNode.left + swap);
                        current_group = int2(asint(LocalDistances[!swap]), TempNode.left + !swap);
                    } else if(IterCount == 1) {
                        [branch]if(LocalDistances[0] == -1) current_group = int2(asint(LocalDistances[1]), TempNode.left+(!(Leafs[0] ^ Leafs[1])));
                        else current_group = int2(asint(LocalDistances[0]), TempNode.left);
                    } else current_group = -1;
                    node_memory_counter += 32;
                    node_traverse_counter += 2;

                } else current_group = -1;



                [flatten]if(current_group.y == -1) {
                    [flatten]if (stack_size == 0) {//thread has finished traversing
                        int PixIndex = GlobalRay.PixelIndex;
                        uint2 TempUv = uint2(PixIndex % screen_width, PixIndex / screen_width);
                        [branch]if(CurBounce == 0) {
                            _PrimaryTriangleInfo[TempUv] = uint4(bestHit.mesh_id, bestHit.triangle_id - _MeshData[bestHit.mesh_id].TriOffset, asuint(bestHit.u), asuint(bestHit.v));
                            #if DebugView == DVBVHView

                                uint memory_counter = node_memory_counter + triangle_memory_counter + stack_memory_counter;
                                uint traverse_counter = node_traverse_counter + 6 * triangle_traverse_counter;
                                uint total_counter = memory_counter / 64 + traverse_counter;

                                float scaled_heatmap_value = float(total_counter) / float(500);

                                float heatmap_value = 781 - (781-380) * exp(-scaled_heatmap_value);

                                // _DebugTex[TempUv] = float4(Reps / 43.0f, Reps > 16, 0, 1);
                                _DebugTex[TempUv] = float4(waveLengthToRGB(heatmap_value), 1);
                            #endif
                        } else if(GetBounceData(GlobalColors[PixIndex].MetRoughIsSpec) == 0 || CurBounce + 1 == GetBounceData(GlobalColors[PixIndex].MetRoughIsSpec)) {
                            _PrimaryTriangleInfo[TempUv] = ((UseReSTIRGI && bestHit.t != FarPlane) ? uint4(bestHit.mesh_id, bestHit.triangle_id - _MeshData[bestHit.mesh_id].TriOffset, asuint(bestHit.u), asuint(bestHit.v)) : ((UseASVGF || bestHit.t != FarPlane) ? uint4(asuint(ray2.direction), 99993) : uint4(asuint(ray2.direction * bestHit.t + ray2.origin), 99993)));
                        }
                        if(CurBounce == 0 && bestHit.t == asfloat(GlobalRay.hits.z)) bestHit.t = FarPlane;
                        set(rayidx, bestHit);
#ifndef DX11
                        KilledNaturally = true;
#endif
                        break;
                    }

                   
                    current_group = stack[--stack_size];
                    stack_memory_counter += 2;
                }
#ifndef DX11
                    const static int Nd = 4;
                    const static int Nw = 16;
                    lostLoopIterations += countbits(~WaveActiveBallot(true)) - Nd;
                    if(lostLoopIterations >= Nw) break;
#endif
            }
#ifndef DX11
    } while(Coun2 < 10000);
#endif
}


#ifdef DX11
[numthreads(64, 1, 1)]
#else
#ifdef HardwareRT
[numthreads(32, 1, 1)]
#else
[numthreads(32, YAmount, 1)]
#endif
#endif
void IntersectcBVHKernel(uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {//If I move the function contents into here, unity yells at me, so for now its just gonna continue to live in its function
    IntersectcBVH(id.x, GT.y, GT.x);
}
